diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..7026f90
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,795 @@
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
+# src/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+
+
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
+pkgdatadir = $(datadir)/glamor-egl
+pkgincludedir = $(includedir)/glamor-egl
+pkglibdir = $(libdir)/glamor-egl
+pkglibexecdir = $(libexecdir)/glamor-egl
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = x86_64-pc-linux-gnu
+host_triplet = x86_64-pc-linux-gnu
+subdir = src
+DIST_COMMON = $(sdk_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
+	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__installdirs = "$(DESTDIR)$(instdir)" "$(DESTDIR)$(moduledir)" \
+	"$(DESTDIR)$(sdkdir)"
+LTLIBRARIES = $(inst_LTLIBRARIES) $(module_LTLIBRARIES)
+am__DEPENDENCIES_1 =
+libglamor_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
+#libglamor_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
+am_libglamor_la_OBJECTS = glamor.lo glamor_copyarea.lo \
+	glamor_copywindow.lo glamor_core.lo glamor_fill.lo \
+	glamor_fillspans.lo glamor_getspans.lo glamor_glyphs.lo \
+	glamor_polyfillrect.lo glamor_polylines.lo glamor_putimage.lo \
+	glamor_setspans.lo glamor_render.lo glamor_gradient.lo \
+	glamor_trapezoid.lo glamor_tile.lo glamor_triangles.lo \
+	glamor_addtraps.lo glamor_getimage.lo glamor_copyplane.lo \
+	glamor_glyphblt.lo glamor_polyops.lo glamor_pixmap.lo \
+	glamor_largepixmap.lo glamor_picture.lo glamor_window.lo \
+	glamor_gl_dispatch.lo glamor_fbo.lo glamor_compositerects.lo
+libglamor_la_OBJECTS = $(am_libglamor_la_OBJECTS)
+AM_V_lt = $(am__v_lt_$(V))
+am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
+am__v_lt_0 = --silent
+libglamor_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libglamor_la_LDFLAGS) $(LDFLAGS) -o $@
+libglamoregl_la_LIBADD =
+am__libglamoregl_la_SOURCES_DIST = glamor_eglmodule.c \
+	$(top_srcdir)/src/glamor_egl.c
+am_libglamoregl_la_OBJECTS =  \
+	libglamoregl_la-glamor_eglmodule.lo \
+	libglamoregl_la-glamor_egl.lo
+libglamoregl_la_OBJECTS = $(am_libglamoregl_la_OBJECTS)
+libglamoregl_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(libglamoregl_la_CFLAGS) $(CFLAGS) $(libglamoregl_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+am_libglamoregl_la_rpath = -rpath $(moduledir)
+DEFAULT_INCLUDES = -I. -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_$(V))
+am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
+am__v_CC_0 = @echo "  CC    " $@;
+AM_V_at = $(am__v_at_$(V))
+am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
+am__v_at_0 = @
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_$(V))
+am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
+am__v_CCLD_0 = @echo "  CCLD  " $@;
+AM_V_GEN = $(am__v_GEN_$(V))
+am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
+am__v_GEN_0 = @echo "  GEN   " $@;
+SOURCES = $(libglamor_la_SOURCES) $(libglamoregl_la_SOURCES)
+DIST_SOURCES = $(libglamor_la_SOURCES) \
+	$(am__libglamoregl_la_SOURCES_DIST)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+HEADERS = $(sdk_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = ${SHELL} /home/portage.tmp/portage/x11-libs/glamor-0.4.1/work/glamor-0.4.1/missing --run aclocal-1.11
+ADMIN_MAN_DIR = $(mandir)/man$(ADMIN_MAN_SUFFIX)
+ADMIN_MAN_SUFFIX = 8
+AMTAR = $${TAR-tar}
+AM_DEFAULT_VERBOSITY = 0
+APP_MAN_DIR = $(mandir)/man$(APP_MAN_SUFFIX)
+APP_MAN_SUFFIX = 1
+AR = x86_64-pc-linux-gnu-ar
+AUTOCONF = ${SHELL} /home/portage.tmp/portage/x11-libs/glamor-0.4.1/work/glamor-0.4.1/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/portage.tmp/portage/x11-libs/glamor-0.4.1/work/glamor-0.4.1/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/portage.tmp/portage/x11-libs/glamor-0.4.1/work/glamor-0.4.1/missing --run automake-1.11
+AWK = gawk
+BASE_CFLAGS =  -Wall -Wpointer-arith -Wmissing-declarations -Wformat=2 -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Wbad-function-cast -Wold-style-definition -Wdeclaration-after-statement -Wunused -Wuninitialized -Wshadow -Wcast-qual -Wmissing-noreturn -Wmissing-format-attribute -Wredundant-decls -Werror=implicit -Werror=nonnull -Werror=init-self -Werror=main -Werror=missing-braces -Werror=sequence-point -Werror=return-type -Werror=trigraphs -Werror=array-bounds -Werror=write-strings -Werror=address -Werror=int-to-pointer-cast -Werror=pointer-to-int-cast
+CC = x86_64-pc-linux-gnu-gcc -std=gnu99
+CCDEPMODE = depmode=none
+CFLAGS = -g -O2
+CHANGELOG_CMD = (GIT_DIR=$(top_srcdir)/.git git log > $(top_srcdir)/.changelog.tmp && mv $(top_srcdir)/.changelog.tmp $(top_srcdir)/ChangeLog) || (rm -f $(top_srcdir)/.changelog.tmp; touch $(top_srcdir)/ChangeLog; echo 'git directory not found: installing possibly empty changelog.' >&2)
+CPP = x86_64-pc-linux-gnu-gcc -E
+CPPFLAGS = 
+CWARNFLAGS =  -Wall -Wpointer-arith -Wmissing-declarations -Wformat=2 -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Wbad-function-cast -Wold-style-definition -Wdeclaration-after-statement -Wunused -Wuninitialized -Wshadow -Wcast-qual -Wmissing-noreturn -Wmissing-format-attribute -Wredundant-decls -Werror=implicit -Werror=nonnull -Werror=init-self -Werror=main -Werror=missing-braces -Werror=sequence-point -Werror=return-type -Werror=trigraphs -Werror=array-bounds -Werror=write-strings -Werror=address -Werror=int-to-pointer-cast -Werror=pointer-to-int-cast -fno-strict-aliasing
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DLLTOOL = false
+DRI2_CFLAGS = 
+DRI2_LIBS = 
+DRIVER_MAN_DIR = $(mandir)/man$(DRIVER_MAN_SUFFIX)
+DRIVER_MAN_SUFFIX = 4
+DSYMUTIL = 
+DUMPBIN = 
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGL_CFLAGS = -I/usr/include/libdrm 
+EGL_LIBS = -lEGL 
+EGREP = /bin/grep -E
+EXEEXT = 
+FGREP = /bin/grep -F
+FILE_MAN_DIR = $(mandir)/man$(FILE_MAN_SUFFIX)
+FILE_MAN_SUFFIX = 5
+GBM_CFLAGS = 
+GBM_LIBS = -lgbm 
+GLAMOR_GL_CFLAGS = -I/usr/include/libdrm  -DGLAMOR_GL
+GLESV2_CFLAGS = 
+GLESV2_LIBS = 
+GLX_DEFINES = -DGLX_USE_TLS -DPTHREADS
+GLX_SYS_LIBS =  -lpthread
+GLX_TLS = yes
+GL_CFLAGS = -I/usr/include/libdrm 
+GL_LIBS = -lGL 
+GREP = /bin/grep
+INSTALL = /usr/bin/install -c
+INSTALL_CMD = (cp -f /usr/share/util-macros/INSTALL $(top_srcdir)/.INSTALL.tmp && mv $(top_srcdir)/.INSTALL.tmp $(top_srcdir)/INSTALL) || (rm -f $(top_srcdir)/.INSTALL.tmp; touch $(top_srcdir)/INSTALL; echo 'util-macros "pkgdatadir" from xorg-macros.pc not found: installing possibly empty INSTALL.' >&2)
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
+LD = /usr/x86_64-pc-linux-gnu/bin/ld -m elf_x86_64
+LDFLAGS = 
+LIBDRM_CFLAGS = -I/usr/include/libdrm 
+LIBDRM_LIBS = -ldrm 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LIB_MAN_DIR = $(mandir)/man$(LIB_MAN_SUFFIX)
+LIB_MAN_SUFFIX = 3
+LIPO = 
+LN_S = ln -s
+LTLIBOBJS = 
+MAINT = 
+MAKEINFO = ${SHELL} /home/portage.tmp/portage/x11-libs/glamor-0.4.1/work/glamor-0.4.1/missing --run makeinfo
+MANIFEST_TOOL = :
+MAN_SUBSTS = 	-e 's|__vendorversion__|"$(PACKAGE_STRING)" "$(XORG_MAN_PAGE)"|' 	-e 's|__xorgversion__|"$(PACKAGE_STRING)" "$(XORG_MAN_PAGE)"|' 	-e 's|__xservername__|Xorg|g' 	-e 's|__xconfigfile__|xorg.conf|g' 	-e 's|__projectroot__|$(prefix)|g' 	-e 's|__apploaddir__|$(appdefaultdir)|g' 	-e 's|__appmansuffix__|$(APP_MAN_SUFFIX)|g' 	-e 's|__drivermansuffix__|$(DRIVER_MAN_SUFFIX)|g' 	-e 's|__adminmansuffix__|$(ADMIN_MAN_SUFFIX)|g' 	-e 's|__libmansuffix__|$(LIB_MAN_SUFFIX)|g' 	-e 's|__miscmansuffix__|$(MISC_MAN_SUFFIX)|g' 	-e 's|__filemansuffix__|$(FILE_MAN_SUFFIX)|g'
+MISC_MAN_DIR = $(mandir)/man$(MISC_MAN_SUFFIX)
+MISC_MAN_SUFFIX = 7
+MKDIR_P = /bin/mkdir -p
+NM = /usr/bin/nm -B
+NMEDIT = 
+OBJDUMP = x86_64-pc-linux-gnu-objdump
+OBJEXT = o
+OTOOL = 
+OTOOL64 = 
+PACKAGE = glamor-egl
+PACKAGE_BUGREPORT = https://bugs.freedesktop.org/enter_bug.cgi?product=glamor
+PACKAGE_NAME = glamor-egl
+PACKAGE_STRING = glamor-egl 0.4.0
+PACKAGE_TARNAME = glamor-egl
+PACKAGE_URL = 
+PACKAGE_VERSION = 0.4.0
+PATH_SEPARATOR = :
+PKG_CONFIG = /usr/bin/pkg-config
+PKG_CONFIG_LIBDIR = 
+PKG_CONFIG_PATH = 
+RANLIB = x86_64-pc-linux-gnu-ranlib
+SED = /bin/sed
+SET_MAKE = 
+SHELL = /bin/sh
+STRICT_CFLAGS =  -pedantic -Werror -Werror=attributes
+STRIP = x86_64-pc-linux-gnu-strip
+VERSION = 0.4.0
+XORG_CFLAGS = -I/usr/include/pixman-1 -I/usr/include/X11/dri -I/usr/include/libdrm -I/usr/include/xorg -fvisibility=hidden 
+XORG_LIBS = 
+XORG_MAN_PAGE = X Version 11
+abs_builddir = /home/portage.tmp/portage/x11-libs/glamor-0.4.1/work/glamor-0.4.1/src
+abs_srcdir = /home/portage.tmp/portage/x11-libs/glamor-0.4.1/work/glamor-0.4.1/src
+abs_top_builddir = /home/portage.tmp/portage/x11-libs/glamor-0.4.1/work/glamor-0.4.1
+abs_top_srcdir = /home/portage.tmp/portage/x11-libs/glamor-0.4.1/work/glamor-0.4.1
+ac_ct_AR = 
+ac_ct_CC = 
+ac_ct_DUMPBIN = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+am__tar = $${TAR-tar} chof - "$$tardir"
+am__untar = $${TAR-tar} xf -
+bindir = ${exec_prefix}/bin
+build = x86_64-pc-linux-gnu
+build_alias = x86_64-pc-linux-gnu
+build_cpu = x86_64
+build_os = linux-gnu
+build_vendor = pc
+builddir = .
+configdir = /usr/share/X11/xorg.conf.d
+datadir = /usr/share
+datarootdir = ${prefix}/share
+docdir = /usr/share/doc/glamor-0.4.1
+dvidir = ${docdir}
+exec_prefix = ${prefix}
+host = x86_64-pc-linux-gnu
+host_alias = x86_64-pc-linux-gnu
+host_cpu = x86_64
+host_os = linux-gnu
+host_vendor = pc
+htmldir = ${docdir}
+includedir = ${prefix}/include
+infodir = /usr/share/info
+install_sh = ${SHELL} /home/portage.tmp/portage/x11-libs/glamor-0.4.1/work/glamor-0.4.1/install-sh
+libdir = /usr/lib64
+libexecdir = ${exec_prefix}/libexec
+localedir = ${datarootdir}/locale
+localstatedir = /var/lib
+mandir = /usr/share/man
+mkdir_p = /bin/mkdir -p
+moduledir = /usr/lib64/xorg/modules
+oldincludedir = /usr/include
+pdfdir = ${docdir}
+prefix = /usr
+program_transform_name = s,x,x,
+psdir = ${docdir}
+sbindir = ${exec_prefix}/sbin
+sdkdir = /usr/include/xorg
+sharedstatedir = ${prefix}/com
+srcdir = .
+sysconfdir = /etc
+target_alias = 
+top_build_prefix = ../
+top_builddir = ..
+top_srcdir = ..
+inst_LTLIBRARIES = libglamor.la
+
+# Override these since glamor doesn't need them and the needed files aren't
+# built (in hw/xfree86/os-support/solaris) until after glamor is built
+SOLARIS_ASM_CFLAGS = ""
+libglamor_la_LIBADD = $(GL_LIBS)
+#libglamor_la_LIBADD = $(GLESV2_LIBS)
+instdir = $(moduledir)
+INCLUDES = \
+	$(XORG_INCS)
+
+AM_CFLAGS = $(CWARNFLAGS) $(XORG_CFLAGS) $(DIX_CFLAGS) $(LIBDRM_CFLAGS)
+libglamor_la_LDFLAGS = -avoid-version
+libglamor_la_SOURCES = \
+	glamor.c \
+	glamor_copyarea.c \
+	glamor_copywindow.c \
+	glamor_core.c \
+	glamor_fill.c \
+	glamor_fillspans.c \
+	glamor_getspans.c \
+	glamor_glyphs.c \
+	glamor_polyfillrect.c \
+	glamor_polylines.c \
+	glamor_putimage.c \
+	glamor_setspans.c \
+	glamor_render.c \
+	glamor_gradient.c \
+	glamor_trapezoid.c \
+	glamor_tile.c \
+	glamor_triangles.c\
+	glamor_addtraps.c\
+	glamor_getimage.c\
+	glamor_copyplane.c\
+	glamor_glyphblt.c\
+	glamor_polyops.c\
+	glamor_pixmap.c\
+	glamor_largepixmap.c\
+	glamor_picture.c\
+	glamor_window.c\
+	glamor_gl_dispatch.c\
+	glamor_fbo.c\
+	glamor_compositerects.c\
+	glamor.h
+
+sdk_HEADERS = glamor.h
+LIBGLAMOREGL = libglamoregl.la
+module_LTLIBRARIES = $(LIBGLAMOREGL)
+libglamoregl_la_DEPENDENCIES = libglamor.la
+libglamoregl_la_LDFLAGS = -avoid-version -module $(EGL_LIBS) -lglamor $(GLX_SYS_LIBS)
+libglamoregl_la_SOURCES = glamor_eglmodule.c $(top_srcdir)/src/glamor_egl.c
+libglamoregl_la_CFLAGS = $(AM_CFLAGS) $(GLX_DEFINES) -I$(top_srcdir)/src $(LIBDRM_CFLAGS) $(EGL_CFLAGS)
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+install-instLTLIBRARIES: $(inst_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	@list='$(inst_LTLIBRARIES)'; test -n "$(instdir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(instdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(instdir)" || exit 1; \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(instdir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(instdir)"; \
+	}
+
+uninstall-instLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(inst_LTLIBRARIES)'; test -n "$(instdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(instdir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(instdir)/$$f"; \
+	done
+
+clean-instLTLIBRARIES:
+	-test -z "$(inst_LTLIBRARIES)" || rm -f $(inst_LTLIBRARIES)
+	@list='$(inst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+install-moduleLTLIBRARIES: $(module_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	@list='$(module_LTLIBRARIES)'; test -n "$(moduledir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(moduledir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(moduledir)" || exit 1; \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(moduledir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(moduledir)"; \
+	}
+
+uninstall-moduleLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(module_LTLIBRARIES)'; test -n "$(moduledir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(moduledir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(moduledir)/$$f"; \
+	done
+
+clean-moduleLTLIBRARIES:
+	-test -z "$(module_LTLIBRARIES)" || rm -f $(module_LTLIBRARIES)
+	@list='$(module_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libglamor.la: $(libglamor_la_OBJECTS) $(libglamor_la_DEPENDENCIES) $(EXTRA_libglamor_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libglamor_la_LINK) -rpath $(instdir) $(libglamor_la_OBJECTS) $(libglamor_la_LIBADD) $(LIBS)
+libglamoregl.la: $(libglamoregl_la_OBJECTS) $(libglamoregl_la_DEPENDENCIES) $(EXTRA_libglamoregl_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libglamoregl_la_LINK) $(am_libglamoregl_la_rpath) $(libglamoregl_la_OBJECTS) $(libglamoregl_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+#include ./$(DEPDIR)/glamor.Plo
+#include ./$(DEPDIR)/glamor_addtraps.Plo
+#include ./$(DEPDIR)/glamor_compositerects.Plo
+#include ./$(DEPDIR)/glamor_copyarea.Plo
+#include ./$(DEPDIR)/glamor_copyplane.Plo
+#include ./$(DEPDIR)/glamor_copywindow.Plo
+#include ./$(DEPDIR)/glamor_core.Plo
+#include ./$(DEPDIR)/glamor_fbo.Plo
+#include ./$(DEPDIR)/glamor_fill.Plo
+#include ./$(DEPDIR)/glamor_fillspans.Plo
+#include ./$(DEPDIR)/glamor_getimage.Plo
+#include ./$(DEPDIR)/glamor_getspans.Plo
+#include ./$(DEPDIR)/glamor_gl_dispatch.Plo
+#include ./$(DEPDIR)/glamor_glyphblt.Plo
+#include ./$(DEPDIR)/glamor_glyphs.Plo
+#include ./$(DEPDIR)/glamor_gradient.Plo
+#include ./$(DEPDIR)/glamor_largepixmap.Plo
+#include ./$(DEPDIR)/glamor_picture.Plo
+#include ./$(DEPDIR)/glamor_pixmap.Plo
+#include ./$(DEPDIR)/glamor_polyfillrect.Plo
+#include ./$(DEPDIR)/glamor_polylines.Plo
+#include ./$(DEPDIR)/glamor_polyops.Plo
+#include ./$(DEPDIR)/glamor_putimage.Plo
+#include ./$(DEPDIR)/glamor_render.Plo
+#include ./$(DEPDIR)/glamor_setspans.Plo
+#include ./$(DEPDIR)/glamor_tile.Plo
+#include ./$(DEPDIR)/glamor_trapezoid.Plo
+#include ./$(DEPDIR)/glamor_triangles.Plo
+#include ./$(DEPDIR)/glamor_window.Plo
+#include ./$(DEPDIR)/libglamoregl_la-glamor_egl.Plo
+#include ./$(DEPDIR)/libglamoregl_la-glamor_eglmodule.Plo
+
+.c.o:
+#	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+#	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+#	$(AM_V_CC)source='$<' object='$@' libtool=no 
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) 
+	$(AM_V_CC)$(COMPILE) -c $<
+
+.c.obj:
+#	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+#	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+#	$(AM_V_CC)source='$<' object='$@' libtool=no 
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) 
+	$(AM_V_CC)$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+#	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+#	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+#	$(AM_V_CC)source='$<' object='$@' libtool=yes 
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) 
+	$(AM_V_CC)$(LTCOMPILE) -c -o $@ $<
+
+libglamoregl_la-glamor_eglmodule.lo: glamor_eglmodule.c
+#	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libglamoregl_la_CFLAGS) $(CFLAGS) -MT libglamoregl_la-glamor_eglmodule.lo -MD -MP -MF $(DEPDIR)/libglamoregl_la-glamor_eglmodule.Tpo -c -o libglamoregl_la-glamor_eglmodule.lo `test -f 'glamor_eglmodule.c' || echo '$(srcdir)/'`glamor_eglmodule.c
+#	$(AM_V_at)$(am__mv) $(DEPDIR)/libglamoregl_la-glamor_eglmodule.Tpo $(DEPDIR)/libglamoregl_la-glamor_eglmodule.Plo
+#	$(AM_V_CC)source='glamor_eglmodule.c' object='libglamoregl_la-glamor_eglmodule.lo' libtool=yes 
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) 
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libglamoregl_la_CFLAGS) $(CFLAGS) -c -o libglamoregl_la-glamor_eglmodule.lo `test -f 'glamor_eglmodule.c' || echo '$(srcdir)/'`glamor_eglmodule.c
+
+libglamoregl_la-glamor_egl.lo: $(top_srcdir)/src/glamor_egl.c
+#	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libglamoregl_la_CFLAGS) $(CFLAGS) -MT libglamoregl_la-glamor_egl.lo -MD -MP -MF $(DEPDIR)/libglamoregl_la-glamor_egl.Tpo -c -o libglamoregl_la-glamor_egl.lo `test -f '$(top_srcdir)/src/glamor_egl.c' || echo '$(srcdir)/'`$(top_srcdir)/src/glamor_egl.c
+#	$(AM_V_at)$(am__mv) $(DEPDIR)/libglamoregl_la-glamor_egl.Tpo $(DEPDIR)/libglamoregl_la-glamor_egl.Plo
+#	$(AM_V_CC)source='$(top_srcdir)/src/glamor_egl.c' object='libglamoregl_la-glamor_egl.lo' libtool=yes 
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) 
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libglamoregl_la_CFLAGS) $(CFLAGS) -c -o libglamoregl_la-glamor_egl.lo `test -f '$(top_srcdir)/src/glamor_egl.c' || echo '$(srcdir)/'`$(top_srcdir)/src/glamor_egl.c
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-sdkHEADERS: $(sdk_HEADERS)
+	@$(NORMAL_INSTALL)
+	@list='$(sdk_HEADERS)'; test -n "$(sdkdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(sdkdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(sdkdir)" || exit 1; \
+	fi; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(sdkdir)'"; \
+	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(sdkdir)" || exit $$?; \
+	done
+
+uninstall-sdkHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(sdk_HEADERS)'; test -n "$(sdkdir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	dir='$(DESTDIR)$(sdkdir)'; $(am__uninstall_files_from_dir)
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(instdir)" "$(DESTDIR)$(moduledir)" "$(DESTDIR)$(sdkdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-instLTLIBRARIES clean-libtool \
+	clean-moduleLTLIBRARIES mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-instLTLIBRARIES install-moduleLTLIBRARIES \
+	install-sdkHEADERS
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-instLTLIBRARIES uninstall-moduleLTLIBRARIES \
+	uninstall-sdkHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-instLTLIBRARIES clean-libtool clean-moduleLTLIBRARIES \
+	ctags distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-instLTLIBRARIES install-man \
+	install-moduleLTLIBRARIES install-pdf install-pdf-am \
+	install-ps install-ps-am install-sdkHEADERS install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-instLTLIBRARIES \
+	uninstall-moduleLTLIBRARIES uninstall-sdkHEADERS
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/Makefile.am b/Makefile.am
index c4be4c0..766aac7 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,4 +1,4 @@
-lib_LTLIBRARIES = libglamor.la
+inst_LTLIBRARIES = libglamor.la
 
 # Override these since glamor doesn't need them and the needed files aren't
 # built (in hw/xfree86/os-support/solaris) until after glamor is built
@@ -15,7 +15,7 @@ instdir = $(moduledir)
 INCLUDES = \
 	$(XORG_INCS)
 
-AM_CFLAGS = $(XORG_CFLAGS) $(DIX_CFLAGS) $(LIBDRM_CFLAGS)
+AM_CFLAGS = $(CWARNFLAGS) $(XORG_CFLAGS) $(DIX_CFLAGS) $(LIBDRM_CFLAGS)
 
 libglamor_la_LDFLAGS = -avoid-version
 
@@ -33,6 +33,8 @@ libglamor_la_SOURCES = \
 	glamor_putimage.c \
 	glamor_setspans.c \
 	glamor_render.c \
+	glamor_gradient.c \
+	glamor_trapezoid.c \
 	glamor_tile.c \
 	glamor_triangles.c\
 	glamor_addtraps.c\
@@ -41,10 +43,12 @@ libglamor_la_SOURCES = \
 	glamor_glyphblt.c\
 	glamor_polyops.c\
 	glamor_pixmap.c\
+	glamor_largepixmap.c\
 	glamor_picture.c\
 	glamor_window.c\
 	glamor_gl_dispatch.c\
 	glamor_fbo.c\
+	glamor_compositerects.c\
 	glamor.h
 
 sdk_HEADERS = glamor.h
diff --git a/Makefile.in b/Makefile.in
index c71ef2d..57d3f8d 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -93,9 +93,9 @@ am__uninstall_files_from_dir = { \
     || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
          $(am__cd) "$$dir" && rm -f $$files; }; \
   }
-am__installdirs = "$(DESTDIR)$(libdir)" "$(DESTDIR)$(moduledir)" \
+am__installdirs = "$(DESTDIR)$(instdir)" "$(DESTDIR)$(moduledir)" \
 	"$(DESTDIR)$(sdkdir)"
-LTLIBRARIES = $(lib_LTLIBRARIES) $(module_LTLIBRARIES)
+LTLIBRARIES = $(inst_LTLIBRARIES) $(module_LTLIBRARIES)
 am__DEPENDENCIES_1 =
 @GLAMOR_GLES2_FALSE@libglamor_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
 @GLAMOR_GLES2_TRUE@libglamor_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
@@ -103,11 +103,12 @@ am_libglamor_la_OBJECTS = glamor.lo glamor_copyarea.lo \
 	glamor_copywindow.lo glamor_core.lo glamor_fill.lo \
 	glamor_fillspans.lo glamor_getspans.lo glamor_glyphs.lo \
 	glamor_polyfillrect.lo glamor_polylines.lo glamor_putimage.lo \
-	glamor_setspans.lo glamor_render.lo glamor_tile.lo \
-	glamor_triangles.lo glamor_addtraps.lo glamor_getimage.lo \
-	glamor_copyplane.lo glamor_glyphblt.lo glamor_polyops.lo \
-	glamor_pixmap.lo glamor_picture.lo glamor_window.lo \
-	glamor_gl_dispatch.lo glamor_fbo.lo
+	glamor_setspans.lo glamor_render.lo glamor_gradient.lo \
+	glamor_trapezoid.lo glamor_tile.lo glamor_triangles.lo \
+	glamor_addtraps.lo glamor_getimage.lo glamor_copyplane.lo \
+	glamor_glyphblt.lo glamor_polyops.lo glamor_pixmap.lo \
+	glamor_largepixmap.lo glamor_picture.lo glamor_window.lo \
+	glamor_gl_dispatch.lo glamor_fbo.lo glamor_compositerects.lo
 libglamor_la_OBJECTS = $(am_libglamor_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -323,7 +324,7 @@ target_alias = @target_alias@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
-lib_LTLIBRARIES = libglamor.la
+inst_LTLIBRARIES = libglamor.la
 
 # Override these since glamor doesn't need them and the needed files aren't
 # built (in hw/xfree86/os-support/solaris) until after glamor is built
@@ -334,7 +335,7 @@ instdir = $(moduledir)
 INCLUDES = \
 	$(XORG_INCS)
 
-AM_CFLAGS = $(XORG_CFLAGS) $(DIX_CFLAGS) $(LIBDRM_CFLAGS)
+AM_CFLAGS = $(CWARNFLAGS) $(XORG_CFLAGS) $(DIX_CFLAGS) $(LIBDRM_CFLAGS)
 libglamor_la_LDFLAGS = -avoid-version
 libglamor_la_SOURCES = \
 	glamor.c \
@@ -350,6 +351,8 @@ libglamor_la_SOURCES = \
 	glamor_putimage.c \
 	glamor_setspans.c \
 	glamor_render.c \
+	glamor_gradient.c \
+	glamor_trapezoid.c \
 	glamor_tile.c \
 	glamor_triangles.c\
 	glamor_addtraps.c\
@@ -358,10 +361,12 @@ libglamor_la_SOURCES = \
 	glamor_glyphblt.c\
 	glamor_polyops.c\
 	glamor_pixmap.c\
+	glamor_largepixmap.c\
 	glamor_picture.c\
 	glamor_window.c\
 	glamor_gl_dispatch.c\
 	glamor_fbo.c\
+	glamor_compositerects.c\
 	glamor.h
 
 sdk_HEADERS = glamor.h
@@ -405,33 +410,33 @@ $(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
 $(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(am__aclocal_m4_deps):
-install-libLTLIBRARIES: $(lib_LTLIBRARIES)
+install-instLTLIBRARIES: $(inst_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
-	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
+	@list='$(inst_LTLIBRARIES)'; test -n "$(instdir)" || list=; \
 	list2=; for p in $$list; do \
 	  if test -f $$p; then \
 	    list2="$$list2 $$p"; \
 	  else :; fi; \
 	done; \
 	test -z "$$list2" || { \
-	  echo " $(MKDIR_P) '$(DESTDIR)$(libdir)'"; \
-	  $(MKDIR_P) "$(DESTDIR)$(libdir)" || exit 1; \
-	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(libdir)'"; \
-	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(libdir)"; \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(instdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(instdir)" || exit 1; \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(instdir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(instdir)"; \
 	}
 
-uninstall-libLTLIBRARIES:
+uninstall-instLTLIBRARIES:
 	@$(NORMAL_UNINSTALL)
-	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
+	@list='$(inst_LTLIBRARIES)'; test -n "$(instdir)" || list=; \
 	for p in $$list; do \
 	  $(am__strip_dir) \
-	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libdir)/$$f'"; \
-	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(libdir)/$$f"; \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(instdir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(instdir)/$$f"; \
 	done
 
-clean-libLTLIBRARIES:
-	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
-	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+clean-instLTLIBRARIES:
+	-test -z "$(inst_LTLIBRARIES)" || rm -f $(inst_LTLIBRARIES)
+	@list='$(inst_LTLIBRARIES)'; for p in $$list; do \
 	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
 	  test "$$dir" != "$$p" || dir=.; \
 	  echo "rm -f \"$${dir}/so_locations\""; \
@@ -470,7 +475,7 @@ clean-moduleLTLIBRARIES:
 	  rm -f "$${dir}/so_locations"; \
 	done
 libglamor.la: $(libglamor_la_OBJECTS) $(libglamor_la_DEPENDENCIES) $(EXTRA_libglamor_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(libglamor_la_LINK) -rpath $(libdir) $(libglamor_la_OBJECTS) $(libglamor_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libglamor_la_LINK) -rpath $(instdir) $(libglamor_la_OBJECTS) $(libglamor_la_LIBADD) $(LIBS)
 libglamoregl.la: $(libglamoregl_la_OBJECTS) $(libglamoregl_la_DEPENDENCIES) $(EXTRA_libglamoregl_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(libglamoregl_la_LINK) $(am_libglamoregl_la_rpath) $(libglamoregl_la_OBJECTS) $(libglamoregl_la_LIBADD) $(LIBS)
 
@@ -482,6 +487,7 @@ distclean-compile:
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_addtraps.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_compositerects.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_copyarea.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_copyplane.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_copywindow.Plo@am__quote@
@@ -494,6 +500,8 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_gl_dispatch.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_glyphblt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_glyphs.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_gradient.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_largepixmap.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_picture.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_pixmap.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_polyfillrect.Plo@am__quote@
@@ -503,6 +511,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_render.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_setspans.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_tile.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_trapezoid.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_triangles.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glamor_window.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libglamoregl_la-glamor_egl.Plo@am__quote@
@@ -656,7 +665,7 @@ check-am: all-am
 check: check-am
 all-am: Makefile $(LTLIBRARIES) $(HEADERS)
 installdirs:
-	for dir in "$(DESTDIR)$(libdir)" "$(DESTDIR)$(moduledir)" "$(DESTDIR)$(sdkdir)"; do \
+	for dir in "$(DESTDIR)$(instdir)" "$(DESTDIR)$(moduledir)" "$(DESTDIR)$(sdkdir)"; do \
 	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
 	done
 install: install-am
@@ -691,7 +700,7 @@ maintainer-clean-generic:
 	@echo "it deletes files that may require special tools to rebuild."
 clean: clean-am
 
-clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
+clean-am: clean-generic clean-instLTLIBRARIES clean-libtool \
 	clean-moduleLTLIBRARIES mostlyclean-am
 
 distclean: distclean-am
@@ -712,13 +721,14 @@ info: info-am
 
 info-am:
 
-install-data-am: install-moduleLTLIBRARIES install-sdkHEADERS
+install-data-am: install-instLTLIBRARIES install-moduleLTLIBRARIES \
+	install-sdkHEADERS
 
 install-dvi: install-dvi-am
 
 install-dvi-am:
 
-install-exec-am: install-libLTLIBRARIES
+install-exec-am:
 
 install-html: install-html-am
 
@@ -758,25 +768,25 @@ ps: ps-am
 
 ps-am:
 
-uninstall-am: uninstall-libLTLIBRARIES uninstall-moduleLTLIBRARIES \
+uninstall-am: uninstall-instLTLIBRARIES uninstall-moduleLTLIBRARIES \
 	uninstall-sdkHEADERS
 
 .MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libLTLIBRARIES clean-libtool clean-moduleLTLIBRARIES \
+	clean-instLTLIBRARIES clean-libtool clean-moduleLTLIBRARIES \
 	ctags distclean distclean-compile distclean-generic \
 	distclean-libtool distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
 	install-data-am install-dvi install-dvi-am install-exec \
 	install-exec-am install-html install-html-am install-info \
-	install-info-am install-libLTLIBRARIES install-man \
+	install-info-am install-instLTLIBRARIES install-man \
 	install-moduleLTLIBRARIES install-pdf install-pdf-am \
 	install-ps install-ps-am install-sdkHEADERS install-strip \
 	installcheck installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-libLTLIBRARIES \
+	tags uninstall uninstall-am uninstall-instLTLIBRARIES \
 	uninstall-moduleLTLIBRARIES uninstall-sdkHEADERS
 
 
diff --git a/compat-api.h b/compat-api.h
new file mode 100644
index 0000000..1608478
--- /dev/null
+++ b/compat-api.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2012 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Dave Airlie <airlied@redhat.com>
+ */
+
+/* this file provides API compat between server post 1.13 and pre it,
+   it should be reused inside as many drivers as possible */
+#ifndef COMPAT_API_H
+#define COMPAT_API_H
+
+#ifndef GLYPH_HAS_GLYPH_PICTURE_ACCESSOR
+#define GetGlyphPicture(g, s) GlyphPicture((g))[(s)->myNum]
+#define SetGlyphPicture(g, s, p) GlyphPicture((g))[(s)->myNum] = p
+#endif
+
+#ifndef XF86_HAS_SCRN_CONV
+#define xf86ScreenToScrn(s) xf86Screens[(s)->myNum]
+#define xf86ScrnToScreen(s) screenInfo.screens[(s)->scrnIndex]
+#endif
+
+#ifndef XF86_SCRN_INTERFACE
+
+#define SCRN_ARG_TYPE int
+#define SCRN_INFO_PTR(arg1) ScrnInfoPtr scrn = xf86Screens[(arg1)]
+
+#define SCREEN_ARG_TYPE int
+#define SCREEN_PTR(arg1) ScreenPtr screen = screenInfo.screens[(arg1)]
+
+#define SCREEN_INIT_ARGS_DECL int scrnIndex, ScreenPtr screen, int argc, char **argv
+
+#define BLOCKHANDLER_ARGS_DECL int arg, pointer blockData, pointer timeout, pointer read_mask
+#define BLOCKHANDLER_ARGS arg, blockData, timeout, read_mask
+
+#define WAKEUPHANDLER_ARGS_DECL int arg, pointer wakeupData, unsigned long result, pointer read_mask
+#define WAKEUPHANDLER_ARGS arg, wakeupData, result, read_mask
+
+#define CLOSE_SCREEN_ARGS_DECL int scrnIndex, ScreenPtr screen
+#define CLOSE_SCREEN_ARGS scrnIndex, screen
+
+#define ADJUST_FRAME_ARGS_DECL int arg, int x, int y, int flags
+#define ADJUST_FRAME_ARGS(arg, x, y) (arg)->scrnIndex, x, y, 0
+
+#define SWITCH_MODE_ARGS_DECL int arg, DisplayModePtr mode, int flags
+#define SWITCH_MODE_ARGS(arg, m) (arg)->scrnIndex, m, 0
+
+#define FREE_SCREEN_ARGS_DECL int arg, int flags
+#define FREE_SCREEN_ARGS	arg, flags
+
+#define VT_FUNC_ARGS_DECL int arg, int flags
+#define VT_FUNC_ARGS(flags) scrn->scrnIndex, (flags)
+
+#define XF86_ENABLEDISABLEFB_ARG(x) ((x)->scrnIndex)
+
+#else
+#define SCRN_ARG_TYPE ScrnInfoPtr
+#define SCRN_INFO_PTR(arg1) ScrnInfoPtr scrn = (arg1)
+
+#define SCREEN_ARG_TYPE ScreenPtr
+#define SCREEN_PTR(arg1) ScreenPtr screen = (arg1)
+
+#define SCREEN_INIT_ARGS_DECL ScreenPtr screen, int argc, char **argv
+
+#define BLOCKHANDLER_ARGS_DECL ScreenPtr arg, pointer timeout, pointer read_mask
+#define BLOCKHANDLER_ARGS arg, timeout, read_mask
+
+#define WAKEUPHANDLER_ARGS_DECL ScreenPtr arg, unsigned long result, pointer read_mask
+#define WAKEUPHANDLER_ARGS arg, result, read_mask
+
+#define CLOSE_SCREEN_ARGS_DECL ScreenPtr screen
+#define CLOSE_SCREEN_ARGS screen
+
+#define ADJUST_FRAME_ARGS_DECL ScrnInfoPtr arg, int x, int y
+#define ADJUST_FRAME_ARGS(arg, x, y) arg, x, y
+
+#define SWITCH_MODE_ARGS_DECL ScrnInfoPtr arg, DisplayModePtr mode
+#define SWITCH_MODE_ARGS(arg, m) arg, m
+
+#define FREE_SCREEN_ARGS_DECL ScrnInfoPtr arg
+#define FREE_SCREEN_ARGS	arg
+
+#define VT_FUNC_ARGS_DECL ScrnInfoPtr arg
+#define VT_FUNC_ARGS(flags) scrn
+
+#define XF86_ENABLEDISABLEFB_ARG(x) (x)
+
+#endif
+#endif
diff --git a/compiler.h b/compiler.h
new file mode 100644
index 0000000..fa28959
--- /dev/null
+++ b/compiler.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2011 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Authors:
+ *    Chris Wilson <chris@chris-wilson.co.uk>
+ *
+ *    Copied from sna 
+ *
+ */
+
+#ifndef _GLAMOR_COMPILER_H_
+#define _GLAMOR_COMPILER_H_
+
+#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
+#define likely(expr) (__builtin_expect (!!(expr), 1))
+#define unlikely(expr) (__builtin_expect (!!(expr), 0))
+#define noinline __attribute__((noinline))
+#define fastcall __attribute__((regparm(3)))
+#define must_check __attribute__((warn_unused_result))
+#define constant __attribute__((const))
+#else
+#define likely(expr) (expr)
+#define unlikely(expr) (expr)
+#define noinline
+#define fastcall
+#define must_check
+#define constant
+#endif
+
+#ifdef HAVE_VALGRIND
+#define VG(x) x
+#else
+#define VG(x)
+#endif
+
+#define VG_CLEAR(s) VG(memset(&s, 0, sizeof(s)))
+
+#define COMPILE_TIME_ASSERT(E) ((void)sizeof(char[1 - 2*!(E)]))
+
+#endif /* _SNA_COMPILER_H_ */
diff --git a/glamor.c b/glamor.c
index 691f758..d51811e 100644
--- a/glamor.c
+++ b/glamor.c
@@ -73,8 +73,8 @@ glamor_set_pixmap_type(PixmapPtr pixmap, glamor_pixmap_type_t type)
 	if (pixmap_priv == NULL) {
 		pixmap_priv = calloc(sizeof(*pixmap_priv), 1);
 		glamor_set_pixmap_private(pixmap, pixmap_priv);
-		pixmap_priv->container = pixmap;
-		pixmap_priv->glamor_priv = glamor_priv;
+		pixmap_priv->base.pixmap = pixmap;
+		pixmap_priv->base.glamor_priv = glamor_priv;
 	}
 	pixmap_priv->type = type;
 }
@@ -91,7 +91,7 @@ glamor_set_pixmap_texture(PixmapPtr pixmap, unsigned int tex)
 	glamor_priv = glamor_get_screen_private(screen);
 	pixmap_priv = glamor_get_pixmap_private(pixmap);
 
-	if (pixmap_priv->fbo) {
+	if (pixmap_priv->base.fbo) {
 		fbo = glamor_pixmap_detach_fbo(pixmap_priv);
 		glamor_destroy_fbo(fbo);
 	}
@@ -117,10 +117,10 @@ glamor_set_screen_pixmap(PixmapPtr screen_pixmap, PixmapPtr *back_pixmap)
 
 	glamor_priv = glamor_get_screen_private(screen_pixmap->drawable.pScreen);
 	pixmap_priv = glamor_get_pixmap_private(screen_pixmap);
-	glamor_priv->screen_fbo = pixmap_priv->fbo->fb;
+	glamor_priv->screen_fbo = pixmap_priv->base.fbo->fb;
 
-	pixmap_priv->fbo->width = screen_pixmap->drawable.width;
-	pixmap_priv->fbo->height = screen_pixmap->drawable.height;
+	pixmap_priv->base.fbo->width = screen_pixmap->drawable.width;
+	pixmap_priv->base.fbo->height = screen_pixmap->drawable.height;
 
 	glamor_priv->back_pixmap = back_pixmap;
 }
@@ -141,9 +141,12 @@ glamor_create_pixmap(ScreenPtr screen, int w, int h, int depth,
 	if (w > 32767 || h > 32767)
 		return NullPixmap;
 
-	if (usage == GLAMOR_CREATE_PIXMAP_CPU
-	    || (w == 0 && h == 0)
-	    || !glamor_check_pixmap_fbo_depth(depth))
+	if ((usage == GLAMOR_CREATE_PIXMAP_CPU
+	     || (usage == CREATE_PIXMAP_USAGE_GLYPH_PICTURE && w <= 64 && h <= 64)
+		|| (w == 0 && h == 0)
+		|| !glamor_check_pixmap_fbo_depth(depth))
+	    || (!GLAMOR_TEXTURED_LARGE_PIXMAP &&
+		!glamor_check_fbo_size(glamor_priv, w, h)))
 		return fbCreatePixmap(screen, w, h, depth, usage);
 	else
 		pixmap = fbCreatePixmap(screen, 0, 0, depth, usage);
@@ -159,12 +162,26 @@ glamor_create_pixmap(ScreenPtr screen, int w, int h, int depth,
 	if (usage == GLAMOR_CREATE_PIXMAP_MAP)
 		type = GLAMOR_MEMORY_MAP;
 
-	pixmap_priv->container = pixmap;
-	pixmap_priv->glamor_priv = glamor_priv;
-	pixmap_priv->type = type;
+	pixmap_priv->base.pixmap = pixmap;
+	pixmap_priv->base.glamor_priv = glamor_priv;
 
 	gl_iformat_for_depth(depth, &format);
-	fbo = glamor_create_fbo(glamor_priv, w, h, format, usage);
+
+	pitch = (((w * pixmap->drawable.bitsPerPixel + 7) / 8) + 3) & ~3;
+	screen->ModifyPixmapHeader(pixmap, w, h, 0, 0, pitch, NULL);
+
+	if (type == GLAMOR_MEMORY_MAP || glamor_check_fbo_size(glamor_priv, w, h)) {
+		pixmap_priv->type = type;
+		fbo = glamor_create_fbo(glamor_priv, w, h, format, usage);
+	}
+	else {
+		DEBUGF("Create LARGE pixmap %p width %d height %d\n", pixmap, w, h);
+		pixmap_priv->type = GLAMOR_TEXTURE_LARGE;
+		fbo = glamor_create_fbo_array(glamor_priv, w, h, format, usage,
+					      glamor_priv->max_fbo_size,
+					      glamor_priv->max_fbo_size,
+					      pixmap_priv);
+	}
 
 	if (fbo == NULL) {
 		fbDestroyPixmap(pixmap);
@@ -174,8 +191,6 @@ glamor_create_pixmap(ScreenPtr screen, int w, int h, int depth,
 
 	glamor_pixmap_attach_fbo(pixmap, fbo);
 
-	pitch = (((w * pixmap->drawable.bitsPerPixel + 7) / 8) + 3) & ~3;
-	screen->ModifyPixmapHeader(pixmap, w, h, 0, 0, pitch, NULL);
 	return pixmap;
 }
 
@@ -186,13 +201,8 @@ glamor_destroy_textured_pixmap(PixmapPtr pixmap)
 		glamor_pixmap_private *pixmap_priv;
 
 		pixmap_priv = glamor_get_pixmap_private(pixmap);
-		if (pixmap_priv != NULL) {
-			glamor_pixmap_fbo *fbo;
-			fbo = glamor_pixmap_detach_fbo(pixmap_priv);
-			if (fbo)
-				glamor_destroy_fbo(fbo);
-			free(pixmap_priv);
-		}
+		if (pixmap_priv != NULL)
+			glamor_pixmap_destroy_fbo(pixmap_priv);
 	}
 }
 
@@ -215,6 +225,11 @@ glamor_block_handler(ScreenPtr screen)
 	dispatch->glFlush();
 	glamor_fbo_expire(glamor_priv);
 	glamor_put_dispatch(glamor_priv);
+	if (glamor_priv->state == RENDER_STATE
+	    && glamor_priv->render_idle_cnt++ > RENDER_IDEL_MAX) {
+		glamor_priv->state = IDLE_STATE;
+		glamor_priv->render_idle_cnt = 0;
+	}
 }
 
 static void
@@ -315,6 +330,9 @@ glamor_init(ScreenPtr screen, unsigned int flags)
 	    glamor_gl_has_extension("GL_EXT_framebuffer_blit");
 	glamor_priv->_dispatch.glGetIntegerv(GL_MAX_RENDERBUFFER_SIZE,
 					     &glamor_priv->max_fbo_size);
+#ifdef MAX_FBO_SIZE
+	glamor_priv->max_fbo_size = MAX_FBO_SIZE;
+#endif
 
 	glamor_set_debug_level(&glamor_debug_level);
 
@@ -370,11 +388,10 @@ glamor_init(ScreenPtr screen, unsigned int flags)
 		glamor_priv->saved_procs.composite = ps->Composite;
 		ps->Composite = glamor_composite;
 
+
 		glamor_priv->saved_procs.trapezoids = ps->Trapezoids;
 		ps->Trapezoids = glamor_trapezoids;
 
-		glamor_priv->saved_procs.glyphs = ps->Glyphs;
-		ps->Glyphs = glamor_glyphs;
 
 		glamor_priv->saved_procs.triangles = ps->Triangles;
 		ps->Triangles = glamor_triangles;
@@ -382,9 +399,17 @@ glamor_init(ScreenPtr screen, unsigned int flags)
 		glamor_priv->saved_procs.addtraps = ps->AddTraps;
 		ps->AddTraps = glamor_add_traps;
 
-		glamor_priv->saved_procs.unrealize_glyph = ps->UnrealizeGlyph;
-		ps->UnrealizeGlyph = glamor_glyph_unrealize;
 	}
+
+	glamor_priv->saved_procs.composite_rects = ps->CompositeRects;
+	ps->CompositeRects = glamor_composite_rectangles;
+
+	glamor_priv->saved_procs.glyphs = ps->Glyphs;
+	ps->Glyphs = glamor_glyphs;
+
+	glamor_priv->saved_procs.unrealize_glyph = ps->UnrealizeGlyph;
+	ps->UnrealizeGlyph = glamor_glyph_unrealize;
+
 	glamor_priv->saved_procs.create_picture = ps->CreatePicture;
 	ps->CreatePicture = glamor_create_picture;
 
@@ -395,6 +420,9 @@ glamor_init(ScreenPtr screen, unsigned int flags)
 	glamor_init_pixmap_fbo(screen);
 	glamor_init_solid_shader(screen);
 	glamor_init_tile_shader(screen);
+#ifdef GLAMOR_TRAPEZOID_SHADER
+	glamor_init_trapezoid_shader(screen);
+#endif
 	glamor_init_putimage_shaders(screen);
 	glamor_init_finish_access_shaders(screen);
 #ifdef GLAMOR_GRADIENT_SHADER
@@ -425,6 +453,9 @@ glamor_release_screen_priv(ScreenPtr screen)
 	glamor_fini_pixmap_fbo(screen);
 	glamor_fini_solid_shader(screen);
 	glamor_fini_tile_shader(screen);
+#ifdef GLAMOR_TRAPEZOID_SHADER
+	glamor_fini_trapezoid_shader(screen);
+#endif
 	glamor_fini_putimage_shaders(screen);
 	glamor_fini_finish_access_shaders(screen);
 #ifdef GLAMOR_GRADIENT_SHADER
@@ -460,17 +491,16 @@ glamor_set_pixmap_private(PixmapPtr pixmap, glamor_pixmap_private *priv)
 }
 
 Bool
-glamor_close_screen(int idx, ScreenPtr screen)
+glamor_close_screen(CLOSE_SCREEN_ARGS_DECL)
 {
 	glamor_screen_private *glamor_priv;
 	PixmapPtr screen_pixmap;
 	int flags;
-
-	glamor_priv = glamor_get_screen_private(screen);
-	flags = glamor_priv->flags;
 #ifdef RENDER
 	PictureScreenPtr ps = GetPictureScreenIfSet(screen);
 #endif
+	glamor_priv = glamor_get_screen_private(screen);
+	flags = glamor_priv->flags;
 	glamor_glyphs_fini(screen);
 	screen->CloseScreen = glamor_priv->saved_procs.close_screen;
 	if (flags & GLAMOR_USE_SCREEN) {
@@ -489,10 +519,12 @@ glamor_close_screen(int idx, ScreenPtr screen)
 
 		ps->Composite = glamor_priv->saved_procs.composite;
 		ps->Trapezoids = glamor_priv->saved_procs.trapezoids;
-		ps->Glyphs = glamor_priv->saved_procs.glyphs;
 		ps->Triangles = glamor_priv->saved_procs.triangles;
 		ps->CreatePicture = glamor_priv->saved_procs.create_picture;
 	}
+	ps->CompositeRects = glamor_priv->saved_procs.composite_rects;
+	ps->Glyphs = glamor_priv->saved_procs.glyphs;
+	ps->UnrealizeGlyph = glamor_priv->saved_procs.unrealize_glyph;
 #endif
 	screen_pixmap = screen->GetScreenPixmap(screen);
 	glamor_set_pixmap_private(screen_pixmap, NULL);
@@ -501,7 +533,7 @@ glamor_close_screen(int idx, ScreenPtr screen)
 
 	glamor_release_screen_priv(screen);
 
-	return screen->CloseScreen(idx, screen);
+	return screen->CloseScreen(CLOSE_SCREEN_ARGS);
 }
 
 
diff --git a/glamor.h b/glamor.h
index da45acc..bafd543 100644
--- a/glamor.h
+++ b/glamor.h
@@ -30,9 +30,8 @@
 #define GLAMOR_H
 
 #include <scrnintstr.h>
-#ifdef GLAMOR_FOR_XORG
+#include <xf86.h>
 #include <xf86str.h>
-#endif
 #include <pixmapstr.h>
 #include <gcstruct.h>
 #include <picturestr.h>
@@ -55,7 +54,9 @@ typedef enum  glamor_pixmap_type {
 	GLAMOR_TEXTURE_DRM,
 	GLAMOR_SEPARATE_TEXTURE,
 	GLAMOR_DRM_ONLY,
-	GLAMOR_TEXTURE_ONLY
+	GLAMOR_TEXTURE_ONLY,
+	GLAMOR_TEXTURE_LARGE,
+	GLAMOR_TEXTURE_PACK
 } glamor_pixmap_type_t;
 
 #define GLAMOR_EGL_EXTERNAL_BUFFER 3
@@ -115,7 +116,11 @@ extern _X_EXPORT void glamor_fini(ScreenPtr screen);
  * screen pixmap which must be a glamor pixmap and requires
  * the internal data structure still exist at that time.
  * Otherwise, the glamor internal structure will not be freed.*/
-extern _X_EXPORT Bool glamor_close_screen(int idx, ScreenPtr screen);
+#ifndef XF86_SCRN_INTERFACE
+extern _X_EXPORT Bool glamor_close_screen(int scrnIndex, ScreenPtr screen);
+#else
+extern _X_EXPORT Bool glamor_close_screen(ScreenPtr screen);
+#endif
 
 
 /* Let glamor to know the screen's fbo. The low level
@@ -157,6 +162,9 @@ extern _X_EXPORT void glamor_egl_restore_context(ScreenPtr screen);
  * */
 extern _X_EXPORT void glamor_egl_exchange_buffers(PixmapPtr front, PixmapPtr back);
 
+extern _X_EXPORT void glamor_pixmap_exchange_fbos(PixmapPtr front, PixmapPtr back);
+
+
 #ifdef GLAMOR_FOR_XORG
 
 #define GLAMOR_EGL_MODULE_NAME  "glamoregl"
diff --git a/glamor_compositerects.c b/glamor_compositerects.c
new file mode 100644
index 0000000..5fe1bbf
--- /dev/null
+++ b/glamor_compositerects.c
@@ -0,0 +1,278 @@
+/*
+ * Copyright  2009 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ * 	Zhigang Gong <zhigang.gong@linux.intel.com>
+ *
+ * 	original author is Chris Wilson at sna.
+ *
+ */
+
+#include "glamor_priv.h"
+#include "mipict.h"
+#include "damage.h"
+
+/** @file glamor_compositerects.
+ *
+ * compositeRects acceleration implementation
+ */
+
+static int16_t bound(int16_t a, uint16_t b)
+{
+	int v = (int)a + (int)b;
+	if (v > MAXSHORT)
+		return MAXSHORT;
+	return v;
+}
+
+static Bool
+_pixman_region_init_clipped_rectangles(pixman_region16_t *region,
+				       unsigned int num_rects,
+				       xRectangle *rects,
+				       int tx, int ty,
+				       BoxPtr extents)
+{
+	pixman_box16_t stack_boxes[64], *boxes = stack_boxes;
+	pixman_bool_t ret;
+	unsigned int i, j;
+
+	if (num_rects > ARRAY_SIZE(stack_boxes)) {
+		boxes = malloc(sizeof(pixman_box16_t) * num_rects);
+		if (boxes == NULL)
+			return FALSE;
+	}
+
+	for (i = j = 0; i < num_rects; i++) {
+		boxes[j].x1 = rects[i].x + tx;
+		if (boxes[j].x1 < extents->x1)
+			boxes[j].x1 = extents->x1;
+
+		boxes[j].y1 = rects[i].y + ty;
+		if (boxes[j].y1 < extents->y1)
+			boxes[j].y1 = extents->y1;
+
+		boxes[j].x2 = bound(rects[i].x + tx, rects[i].width);
+		if (boxes[j].x2 > extents->x2)
+			boxes[j].x2 = extents->x2;
+
+		boxes[j].y2 = bound(rects[i].y + ty, rects[i].height);
+		if (boxes[j].y2 > extents->y2)
+			boxes[j].y2 = extents->y2;
+
+		if (boxes[j].x2 > boxes[j].x1 && boxes[j].y2 > boxes[j].y1)
+			j++;
+	}
+
+	ret = FALSE;
+	if (j)
+	    ret = pixman_region_init_rects(region, boxes, j);
+
+	if (boxes != stack_boxes)
+		free(boxes);
+
+	DEBUGF("%s: nrects=%d, region=(%d, %d), (%d, %d) x %d\n",
+	     __FUNCTION__, num_rects,
+	     region->extents.x1, region->extents.y1,
+	     region->extents.x2, region->extents.y2,
+	     j);
+	return ret;
+}
+
+
+void
+glamor_composite_rectangles(CARD8	 op,
+			 PicturePtr	 dst,
+			 xRenderColor	*color,
+			 int		 num_rects,
+			 xRectangle	*rects)
+{
+	PixmapPtr pixmap;
+	struct glamor_pixmap_private *priv;
+	pixman_region16_t region;
+	pixman_box16_t *boxes;
+	int dst_x, dst_y;
+	int num_boxes;
+	PicturePtr source = NULL;
+	Bool need_free_region = FALSE;
+
+	DEBUGF("%s(op=%d, %08x x %d [(%d, %d)x(%d, %d) ...])\n",
+	     __FUNCTION__, op,
+	     (color->alpha >> 8 << 24) |
+	     (color->red   >> 8 << 16) |
+	     (color->green >> 8 << 8) |
+	     (color->blue  >> 8 << 0),
+	     num_rects,
+	     rects[0].x, rects[0].y, rects[0].width, rects[0].height);
+
+	if (!num_rects)
+		return;
+
+	if (region_is_empty(dst->pCompositeClip)) {
+		DEBUGF("%s: empty clip, skipping\n", __FUNCTION__);
+		return;
+	}
+
+	pixmap = glamor_get_drawable_pixmap(dst->pDrawable);
+	priv = glamor_get_pixmap_private(pixmap);
+
+	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(priv))
+		goto fallback;
+	if (dst->alphaMap) {
+		DEBUGF("%s: fallback, dst has an alpha-map\n", __FUNCTION__);
+		goto fallback;
+	}
+
+	if ((color->red|color->green|color->blue|color->alpha) <= 0x00ff) {
+		switch (op) {
+		case PictOpOver:
+		case PictOpOutReverse:
+		case PictOpAdd:
+			return;
+		case  PictOpInReverse:
+		case  PictOpSrc:
+			op = PictOpClear;
+			break;
+		case  PictOpAtopReverse:
+			op = PictOpOut;
+			break;
+		case  PictOpXor:
+			op = PictOpOverReverse;
+			break;
+		}
+	}
+	if (color->alpha <= 0x00ff) {
+		switch (op) {
+		case PictOpOver:
+		case PictOpOutReverse:
+			return;
+		case  PictOpInReverse:
+			op = PictOpClear;
+			break;
+		case  PictOpAtopReverse:
+			op = PictOpOut;
+			break;
+		case  PictOpXor:
+			op = PictOpOverReverse;
+			break;
+		}
+	} else if (color->alpha >= 0xff00) {
+		switch (op) {
+		case PictOpOver:
+			op = PictOpSrc;
+			break;
+		case PictOpInReverse:
+			return;
+		case PictOpOutReverse:
+			op = PictOpClear;
+			break;
+		case  PictOpAtopReverse:
+			op = PictOpOverReverse;
+			break;
+		case  PictOpXor:
+			op = PictOpOut;
+			break;
+		}
+	}
+	DEBUGF("%s: converted to op %d\n", __FUNCTION__, op);
+
+	if (!_pixman_region_init_clipped_rectangles(&region,
+						    num_rects, rects,
+						    dst->pDrawable->x,
+						    dst->pDrawable->y,
+						    &dst->pCompositeClip->extents))
+	{
+		DEBUGF("%s: allocation failed for region\n", __FUNCTION__);
+		return;
+	}
+
+	need_free_region = TRUE;
+
+	DEBUGF("%s: drawable extents (%d, %d),(%d, %d) x %d\n",
+	     __FUNCTION__,
+	     RegionExtents(&region)->x1, RegionExtents(&region)->y1,
+	     RegionExtents(&region)->x2, RegionExtents(&region)->y2,
+	     RegionNumRects(&region));
+
+	if (dst->pCompositeClip->data &&
+	    (!pixman_region_intersect(&region, &region, dst->pCompositeClip) ||
+	     region_is_empty(&region))) {
+		DEBUGF(("%s: zero-intersection between rectangles and clip\n",
+		     __FUNCTION__));
+		pixman_region_fini(&region);
+		return;
+	}
+
+	DEBUGF("%s: clipped extents (%d, %d),(%d, %d) x %d\n",
+	     __FUNCTION__,
+	     RegionExtents(&region)->x1, RegionExtents(&region)->y1,
+	     RegionExtents(&region)->x2, RegionExtents(&region)->y2,
+	     RegionNumRects(&region));
+
+	glamor_get_drawable_deltas(dst->pDrawable, pixmap, &dst_x, &dst_y);
+	pixman_region_translate(&region, dst_x, dst_y);
+
+	DEBUGF("%s: pixmap +(%d, %d) extents (%d, %d),(%d, %d)\n",
+	     __FUNCTION__, dst_x, dst_y,
+	     RegionExtents(&region)->x1, RegionExtents(&region)->y1,
+	     RegionExtents(&region)->x2, RegionExtents(&region)->y2);
+
+
+	boxes = pixman_region_rectangles(&region, &num_boxes);
+	if (op == PictOpSrc || op == PictOpClear) {
+		CARD32 pixel;
+		if (op == PictOpClear)
+			pixel = 0;
+		else
+			miRenderColorToPixel(dst->pFormat, color, &pixel);
+		glamor_solid_boxes(pixmap, boxes, num_boxes, pixel);
+
+		goto done;
+	} else {
+		if (likely(priv->type != GLAMOR_TEXTURE_LARGE)) {
+			int error;
+
+			source = CreateSolidPicture(0, color, &error);
+			if (!source)
+				goto done;
+			if (glamor_composite_clipped_region(op, source,
+						NULL, dst,
+						NULL, NULL, priv,
+						&region,
+						0,0,0,0,0,0))
+				goto done;
+		}
+	}
+fallback:
+	miCompositeRects(op, dst, color, num_rects, rects);
+done:
+	/* XXX xserver-1.8: CompositeRects is not tracked by Damage, so we must
+	 * manually append the damaged regions ourselves.
+	 */
+	DamageRegionAppend(&pixmap->drawable, &region);
+	DamageRegionProcessPending(&pixmap->drawable);
+
+	if (need_free_region)
+		pixman_region_fini(&region);
+	if (source)
+		FreePicture(source, 0);
+	return;
+}
diff --git a/glamor_copyarea.c b/glamor_copyarea.c
index 3bb077c..2994179 100644
--- a/glamor_copyarea.c
+++ b/glamor_copyarea.c
@@ -40,11 +40,13 @@ glamor_copy_n_to_n_fbo_blit(DrawablePtr src,
 	ScreenPtr screen = dst->pScreen;
 	PixmapPtr dst_pixmap = glamor_get_drawable_pixmap(dst);
 	PixmapPtr src_pixmap = glamor_get_drawable_pixmap(src);
-	glamor_pixmap_private *src_pixmap_priv;
+	glamor_pixmap_private *src_pixmap_priv, *dst_pixmap_priv;
 	glamor_screen_private *glamor_priv =
 	    glamor_get_screen_private(screen);
 	glamor_gl_dispatch *dispatch;
 	int dst_x_off, dst_y_off, src_x_off, src_y_off, i;
+	int fbo_x_off, fbo_y_off;
+	int src_fbo_x_off, src_fbo_y_off;
 
 	if (!glamor_priv->has_fbo_blit) {
 		glamor_delayed_fallback(screen,
@@ -52,17 +54,13 @@ glamor_copy_n_to_n_fbo_blit(DrawablePtr src,
 		return FALSE;
 	}
 	src_pixmap_priv = glamor_get_pixmap_private(src_pixmap);
+	dst_pixmap_priv = glamor_get_pixmap_private(dst_pixmap);
 
 	if (gc) {
 		if (gc->alu != GXcopy) {
 			glamor_delayed_fallback(screen, "non-copy ALU\n");
 			return FALSE;
 		}
-		if (!glamor_pm_is_solid(dst, gc->planemask)) {
-			glamor_delayed_fallback(screen,
-						"non-solid planemask\n");
-			return FALSE;
-		}
 	}
 
 	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(src_pixmap_priv)) {
@@ -73,14 +71,20 @@ glamor_copy_n_to_n_fbo_blit(DrawablePtr src,
 	if (glamor_set_destination_pixmap(dst_pixmap))
 		return FALSE;
 
+	pixmap_priv_get_fbo_off(dst_pixmap_priv, &fbo_x_off, &fbo_y_off);
+	pixmap_priv_get_fbo_off(src_pixmap_priv, &src_fbo_x_off, &src_fbo_y_off);
+
 	dispatch = glamor_get_dispatch(glamor_priv);
 	dispatch->glBindFramebuffer(GL_READ_FRAMEBUFFER_EXT,
-				    src_pixmap_priv->fbo->fb);
+				    src_pixmap_priv->base.fbo->fb);
 	glamor_get_drawable_deltas(dst, dst_pixmap, &dst_x_off,
 				   &dst_y_off);
 	glamor_get_drawable_deltas(src, src_pixmap, &src_x_off,
 				   &src_y_off);
-	src_y_off += dy;
+	dst_x_off += fbo_x_off;
+	dst_y_off += fbo_y_off;
+	src_y_off += dy + src_fbo_y_off;
+	src_x_off += src_fbo_x_off;
 
 	for (i = 0; i < nbox; i++) {
 		if (glamor_priv->yInverted) {
@@ -133,6 +137,7 @@ glamor_copy_n_to_n_fbo_blit(DrawablePtr src,
 		}
 	}
 	glamor_put_dispatch(glamor_priv);
+	glamor_priv->state = BLIT_STATE;
 	return TRUE;
 }
 #endif
@@ -154,17 +159,11 @@ glamor_copy_n_to_n_textured(DrawablePtr src,
 	int src_x_off, src_y_off, dst_x_off, dst_y_off;
 	enum glamor_pixmap_status src_status = GLAMOR_NONE;
 	GLfloat dst_xscale, dst_yscale, src_xscale, src_yscale;
-	int alu = GXcopy;
 
 	src_pixmap_priv = glamor_get_pixmap_private(src_pixmap);
 	dst_pixmap_priv = glamor_get_pixmap_private(dst_pixmap);
 
-	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(dst_pixmap_priv)) {
-		glamor_delayed_fallback(dst->pScreen, "dst has no fbo.\n");
-		return FALSE;
-	}
-
-	if (!src_pixmap_priv || !src_pixmap_priv->gl_fbo) {
+	if (!src_pixmap_priv->base.gl_fbo) {
 #ifndef GLAMOR_PIXMAP_DYNAMIC_UPLOAD
 		glamor_delayed_fallback(dst->pScreen, "src has no fbo.\n");
 		return FALSE;
@@ -177,13 +176,8 @@ glamor_copy_n_to_n_textured(DrawablePtr src,
 #endif
 	}
 
-	if (gc) {
-		if (!glamor_set_planemask(dst_pixmap, gc->planemask))
-			return FALSE;
-		alu = gc->alu;
-	}
 
-	pixmap_priv_get_scale(dst_pixmap_priv, &dst_xscale, &dst_yscale);
+	pixmap_priv_get_dest_scale(dst_pixmap_priv, &dst_xscale, &dst_yscale);
 	pixmap_priv_get_scale(src_pixmap_priv, &src_xscale, &src_yscale);
 
 	glamor_get_drawable_deltas(dst, dst_pixmap, &dst_x_off,
@@ -191,10 +185,6 @@ glamor_copy_n_to_n_textured(DrawablePtr src,
 
 	dispatch = glamor_get_dispatch(glamor_priv);
 
-	if (!glamor_set_alu(dispatch, alu)) {
-		glamor_put_dispatch(glamor_priv);
-		return FALSE;
-	}
 
 	glamor_set_destination_pixmap_priv_nc(dst_pixmap_priv);
 	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_POS, 2, GL_FLOAT,
@@ -206,12 +196,10 @@ glamor_copy_n_to_n_textured(DrawablePtr src,
 				   &src_y_off);
 	dx += src_x_off;
 	dy += src_y_off;
-	pixmap_priv_get_scale(src_pixmap_priv, &src_xscale,
-			      &src_yscale);
 
 	dispatch->glActiveTexture(GL_TEXTURE0);
 	dispatch->glBindTexture(GL_TEXTURE_2D,
-				src_pixmap_priv->fbo->tex);
+				src_pixmap_priv->base.fbo->tex);
 #ifndef GLAMOR_GLES2
 	dispatch->glEnable(GL_TEXTURE_2D);
 	dispatch->glTexParameteri(GL_TEXTURE_2D,
@@ -241,7 +229,8 @@ glamor_copy_n_to_n_textured(DrawablePtr src,
 
 	for (i = 0; i < nbox; i++) {
 
-		glamor_set_normalize_vcoords(dst_xscale, dst_yscale,
+		glamor_set_normalize_vcoords(dst_pixmap_priv,
+					     dst_xscale, dst_yscale,
 					     box[i].x1 + dst_x_off,
 					     box[i].y1 + dst_y_off,
 					     box[i].x2 + dst_x_off,
@@ -249,7 +238,8 @@ glamor_copy_n_to_n_textured(DrawablePtr src,
 					     glamor_priv->yInverted,
 					     vertices);
 
-		glamor_set_normalize_tcoords(src_xscale,
+		glamor_set_normalize_tcoords(src_pixmap_priv,
+					     src_xscale,
 					     src_yscale,
 					     box[i].x1 + dx,
 					     box[i].y1 + dy,
@@ -268,22 +258,23 @@ glamor_copy_n_to_n_textured(DrawablePtr src,
 	dispatch->glUseProgram(0);
 	/* The source texture is bound to a fbo, we have to flush it here. */
 	glamor_put_dispatch(glamor_priv);
+	glamor_priv->state = RENDER_STATE;
+	glamor_priv->render_idle_cnt = 0;
 	return TRUE;
 }
 
-static Bool 
-_glamor_copy_n_to_n(DrawablePtr src,
-		    DrawablePtr dst,
-		    GCPtr gc,
-		    BoxPtr box,
-		    int nbox,
-		    int dx,
-		    int dy,
-		    Bool reverse,
-		    Bool upsidedown, Pixel bitplane, 
-		    void *closure, Bool fallback)
+static Bool
+__glamor_copy_n_to_n(DrawablePtr src,
+		     DrawablePtr dst,
+		     GCPtr gc,
+		     BoxPtr box,
+		     int nbox,
+		     int dx,
+		     int dy,
+		     Bool reverse,
+		     Bool upsidedown, Pixel bitplane,
+		     void *closure)
 {
-	glamor_access_t dst_access;
 	PixmapPtr dst_pixmap, src_pixmap, temp_pixmap = NULL;
 	DrawablePtr temp_src = src;
 	glamor_pixmap_private *dst_pixmap_priv, *src_pixmap_priv;
@@ -297,32 +288,20 @@ _glamor_copy_n_to_n(DrawablePtr src,
 	int overlaped = 0;
 	Bool ret = FALSE;
 
-	if (nbox == 0)
-		return TRUE;
 	dst_pixmap = glamor_get_drawable_pixmap(dst);
 	dst_pixmap_priv = glamor_get_pixmap_private(dst_pixmap);
 	src_pixmap = glamor_get_drawable_pixmap(src);
 	src_pixmap_priv = glamor_get_pixmap_private(src_pixmap);
 	screen = dst_pixmap->drawable.pScreen;
 	glamor_priv = glamor_get_screen_private(dst->pScreen);
-
-	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(dst_pixmap_priv)) {
-		glamor_fallback("dest pixmap %p has no fbo. \n",
-				dst_pixmap);
-		goto fail;
-	}
-
-	if (!src_pixmap_priv) {
-		glamor_set_pixmap_type(src_pixmap, GLAMOR_MEMORY);
-		src_pixmap_priv = glamor_get_pixmap_private(src_pixmap);
-	}
-
 	glamor_get_drawable_deltas(src, src_pixmap, &src_x_off,
 				   &src_y_off);
+
 	glamor_get_drawable_deltas(dst, dst_pixmap, &dst_x_off,
 				   &dst_y_off);
 
-	if (src_pixmap_priv->fbo && src_pixmap_priv->fbo->fb == dst_pixmap_priv->fbo->fb) {
+	if (src_pixmap_priv->base.fbo
+		&& src_pixmap_priv->base.fbo->fb == dst_pixmap_priv->base.fbo->fb) {
 		int x_shift = abs(src_x_off - dx - dst_x_off);
 		int y_shift = abs(src_y_off - dy - dst_y_off);
 		for (i = 0; i < nbox; i++) {
@@ -333,9 +312,14 @@ _glamor_copy_n_to_n(DrawablePtr src,
 			}
 		}
 	}
+	DEBUGF("Copy %d %d %dx%d dx %d dy %d from %p to %p \n",
+		box[0].x1, box[0].y1,
+		box[0].x2 - box[0].x1, box[0].y2 - box[0].y1,
+		dx, dy,
+		src_pixmap, dst_pixmap);
 #ifndef GLAMOR_GLES2
-	if ((overlaped
-	     || !src_pixmap_priv->gl_tex || !dst_pixmap_priv->gl_tex)
+	if ((overlaped || glamor_priv->state != RENDER_STATE
+	     || !src_pixmap_priv->base.gl_tex || !dst_pixmap_priv->base.gl_tex)
 	    && glamor_copy_n_to_n_fbo_blit(src, dst, gc, box, nbox, dx,
 					   dy)) {
 		ret = TRUE;
@@ -346,10 +330,13 @@ _glamor_copy_n_to_n(DrawablePtr src,
 
 	/*  Overlaped indicate the src and dst are the same pixmap. */
 	if (overlaped || (!GLAMOR_PIXMAP_PRIV_HAS_FBO(src_pixmap_priv)
-			  && ((bound.x2 - bound.x1) * (bound.y2 - bound.y1)
+			  && (((bound.x2 - bound.x1) * (bound.y2 - bound.y1)
 			      * 4 >
 			      src_pixmap->drawable.width *
-			      src_pixmap->drawable.height))) {
+			      src_pixmap->drawable.height)
+		             || !(glamor_check_fbo_size(glamor_priv,
+					src_pixmap->drawable.width,
+					src_pixmap->drawable.height))))) {
 
 		temp_pixmap = glamor_create_pixmap(screen,
 						   bound.x2 - bound.x1,
@@ -358,9 +345,11 @@ _glamor_copy_n_to_n(DrawablePtr src,
 						   drawable.depth,
 						   overlaped ? 0 :
 						   GLAMOR_CREATE_PIXMAP_CPU);
+		assert(bound.x2 - bound.x1 <= glamor_priv->max_fbo_size);
+		assert(bound.y2 - bound.y1 <= glamor_priv->max_fbo_size);
 		if (!temp_pixmap)
-			goto fail;
-		glamor_transform_boxes(box, nbox, -bound.x1, -bound.y1);
+			goto done;
+		glamor_translate_boxes(box, nbox, -bound.x1, -bound.y1);
 		temp_src = &temp_pixmap->drawable;
 
 		if (overlaped)
@@ -372,7 +361,7 @@ _glamor_copy_n_to_n(DrawablePtr src,
 			fbCopyNtoN(src, temp_src, gc, box, nbox,
 				   temp_dx + bound.x1, temp_dy + bound.y1,
 				   reverse, upsidedown, bitplane, closure);
-		glamor_transform_boxes(box, nbox, bound.x1, bound.y1);
+		glamor_translate_boxes(box, nbox, bound.x1, bound.y1);
 		temp_dx = -bound.x1;
 		temp_dy = -bound.y1;
 	} else {
@@ -384,13 +373,228 @@ _glamor_copy_n_to_n(DrawablePtr src,
 	if (glamor_copy_n_to_n_textured
 	    (temp_src, dst, gc, box, nbox, temp_dx, temp_dy)) {
 		ret = TRUE;
-		goto done;
 	}
+done:
+	if (temp_src != src)
+		glamor_destroy_pixmap(temp_pixmap);
+	return ret;
+}
 
+static Bool
+_glamor_copy_n_to_n(DrawablePtr src,
+		    DrawablePtr dst,
+		    GCPtr gc,
+		    BoxPtr box,
+		    int nbox,
+		    int dx,
+		    int dy,
+		    Bool reverse,
+		    Bool upsidedown, Pixel bitplane,
+		    void *closure, Bool fallback)
+{
+	glamor_access_t dst_access;
+	PixmapPtr dst_pixmap, src_pixmap;
+	glamor_pixmap_private *dst_pixmap_priv, *src_pixmap_priv;
+	glamor_screen_private *glamor_priv;
+	glamor_gl_dispatch *dispatch;
+	BoxPtr extent;
+	RegionRec region;
+	ScreenPtr screen;
+	int src_x_off, src_y_off, dst_x_off, dst_y_off;
+	Bool ok = FALSE;
+	int force_clip = 0;
+
+	if (nbox == 0)
+		return TRUE;
+	dst_pixmap = glamor_get_drawable_pixmap(dst);
+	dst_pixmap_priv = glamor_get_pixmap_private(dst_pixmap);
+	src_pixmap = glamor_get_drawable_pixmap(src);
+	src_pixmap_priv = glamor_get_pixmap_private(src_pixmap);
+	screen = dst_pixmap->drawable.pScreen;
+
+	glamor_priv = glamor_get_screen_private(dst->pScreen);
+
+	DEBUGF("Copy %d %d %dx%d dx %d dy %d from %p to %p \n",
+		box[0].x1, box[0].y1,
+		box[0].x2 - box[0].x1, box[0].y2 - box[0].y1,
+		dx, dy,
+		src_pixmap, dst_pixmap);
+
+	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(dst_pixmap_priv))
+		goto fall_back;
 
-      fail:
-	
-	if (!fallback 
+	if (gc) {
+		if (!glamor_set_planemask(dst_pixmap, gc->planemask))
+			goto fall_back;
+		dispatch = glamor_get_dispatch(glamor_priv);
+		if (!glamor_set_alu(dispatch, gc->alu)) {
+			glamor_put_dispatch(glamor_priv);
+			goto fail;
+		}
+		glamor_put_dispatch(glamor_priv);
+	}
+
+	if (!src_pixmap_priv) {
+		glamor_set_pixmap_type(src_pixmap, GLAMOR_MEMORY);
+		src_pixmap_priv = glamor_get_pixmap_private(src_pixmap);
+	}
+
+	glamor_get_drawable_deltas(src, src_pixmap, &src_x_off,
+				   &src_y_off);
+	glamor_get_drawable_deltas(dst, dst_pixmap, &dst_x_off,
+				   &dst_y_off);
+
+	RegionInitBoxes(&region, box, nbox);
+	extent = RegionExtents(&region);
+
+	if (!glamor_check_fbo_size(glamor_priv,
+		extent->x2 - extent->x1, extent->y2 - extent->y1)
+	   && (src_pixmap_priv->type == GLAMOR_MEMORY
+		|| (src_pixmap_priv == dst_pixmap_priv))) {
+		force_clip = 1;
+	}
+
+	if (force_clip || dst_pixmap_priv->type == GLAMOR_TEXTURE_LARGE
+	    || src_pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
+			glamor_pixmap_clipped_regions *clipped_dst_regions;
+			int n_dst_region, i, j;
+			PixmapPtr temp_source_pixmap;
+			glamor_pixmap_private *temp_source_priv = NULL;
+
+			RegionTranslate(&region, dst_x_off, dst_y_off);
+			if (!force_clip)
+				clipped_dst_regions = glamor_compute_clipped_regions(dst_pixmap_priv,
+										     &region, &n_dst_region, 0,
+										     reverse, upsidedown);
+			else
+				clipped_dst_regions = glamor_compute_clipped_regions_ext(dst_pixmap_priv,
+										         &region, &n_dst_region,
+											 glamor_priv->max_fbo_size,
+											 glamor_priv->max_fbo_size,
+											 reverse, upsidedown);
+			for(i = 0; i < n_dst_region; i++)
+			{
+				int n_src_region;
+				glamor_pixmap_clipped_regions *clipped_src_regions;
+				BoxPtr current_boxes;
+				int n_current_boxes;
+
+				SET_PIXMAP_FBO_CURRENT(dst_pixmap_priv, clipped_dst_regions[i].block_idx);
+
+				temp_source_pixmap = NULL;
+				if (src_pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
+					RegionTranslate(clipped_dst_regions[i].region,
+							-dst_x_off + src_x_off + dx, -dst_y_off + src_y_off + dy);
+					clipped_src_regions = glamor_compute_clipped_regions(src_pixmap_priv,
+											     clipped_dst_regions[i].region,
+											     &n_src_region, 0,
+											     reverse, upsidedown);
+					DEBUGF("Source is large pixmap.\n");
+					for (j = 0; j < n_src_region; j++)
+					{
+						if (src_pixmap_priv != dst_pixmap_priv)
+							SET_PIXMAP_FBO_CURRENT(src_pixmap_priv, clipped_src_regions[j].block_idx);
+						else if (src_pixmap_priv == dst_pixmap_priv &&
+						    clipped_src_regions[j].block_idx != clipped_dst_regions[i].block_idx) {
+							/* source and the dest are the same, but need different block_idx.
+							 * we create a empty pixmap and fill the required source fbo and box to
+							 * it. It's a little hacky, but avoid extra copy. */
+							temp_source_pixmap = glamor_create_pixmap(src->pScreen, 0, 0,
+												  src->depth, 0);
+							if (!temp_source_pixmap) {
+								ok = FALSE;
+								goto fail;
+							}
+							src->pScreen->ModifyPixmapHeader(temp_source_pixmap,
+										      src_pixmap->drawable.width,
+										      src_pixmap->drawable.height,
+										      0, 0, src_pixmap->devKind, NULL);
+							temp_source_priv = glamor_get_pixmap_private(temp_source_pixmap);
+							*temp_source_priv = *src_pixmap_priv;
+							temp_source_priv->large.box = src_pixmap_priv->large.box_array[clipped_src_regions[j].block_idx];
+							temp_source_priv->base.fbo = src_pixmap_priv->large.fbo_array[clipped_src_regions[j].block_idx];
+							temp_source_priv->base.pixmap = temp_source_pixmap;
+						}
+						assert(temp_source_pixmap || !(src_pixmap_priv == dst_pixmap_priv
+							&& (clipped_src_regions[j].block_idx != clipped_dst_regions[i].block_idx)));
+
+						RegionTranslate(clipped_src_regions[j].region,
+								-src_x_off - dx,
+								-src_y_off - dy);
+						current_boxes = RegionRects(clipped_src_regions[j].region);
+						n_current_boxes = RegionNumRects(clipped_src_regions[j].region);
+						DEBUGF("dst pixmap fbo idx %d src pixmap fbo idx %d \n",
+							clipped_dst_regions[i].block_idx,
+							clipped_src_regions[j].block_idx);
+						DEBUGF("Copy %d %d %d %d dx %d dy %d from %p to %p \n",
+							current_boxes[0].x1, current_boxes[0].y1,
+							current_boxes[0].x2, current_boxes[0].y2,
+							dx, dy, src_pixmap, dst_pixmap);
+						if (!temp_source_pixmap)
+							ok = __glamor_copy_n_to_n(src, dst, gc, current_boxes,
+										  n_current_boxes, dx, dy, reverse,
+										  upsidedown, bitplane, closure);
+						else {
+							ok = __glamor_copy_n_to_n(&temp_source_pixmap->drawable,
+										  dst, gc, current_boxes,
+										  n_current_boxes, dx, dy, reverse,
+										  upsidedown, bitplane, closure);
+							temp_source_priv->type = GLAMOR_MEMORY;
+							temp_source_priv->base.fbo = NULL;
+							glamor_destroy_pixmap(temp_source_pixmap);
+							temp_source_pixmap = NULL;
+						}
+
+						RegionDestroy(clipped_src_regions[j].region);
+						if (!ok) {
+							assert(0);
+							goto fail;
+						}
+					}
+
+					if (n_src_region == 0)
+						ok = TRUE;
+					free(clipped_src_regions);
+				} else {
+					RegionTranslate(clipped_dst_regions[i].region,
+							- dst_x_off,
+							- dst_y_off);
+					current_boxes = RegionRects(clipped_dst_regions[i].region);
+					n_current_boxes = RegionNumRects(clipped_dst_regions[i].region);
+
+						DEBUGF("dest pixmap fbo idx %d \n",
+							clipped_dst_regions[i].block_idx);
+						DEBUGF("Copy %d %d %d %d dx %d dy %d from %p to %p \n",
+							current_boxes[0].x1, current_boxes[0].y1,
+							current_boxes[0].x2, current_boxes[0].y2,
+							dx, dy, src_pixmap, dst_pixmap);
+
+					ok = __glamor_copy_n_to_n(src, dst, gc, current_boxes,
+								  n_current_boxes, dx, dy, reverse,
+								  upsidedown, bitplane, closure);
+
+				}
+				RegionDestroy(clipped_dst_regions[i].region);
+			}
+		if (n_dst_region == 0)
+			ok = TRUE;
+		free(clipped_dst_regions);
+		RegionUninit(&region);
+	} else {
+		ok = __glamor_copy_n_to_n(src, dst, gc, box, nbox, dx, dy,
+					  reverse, upsidedown, bitplane,
+					  closure);
+	}
+
+fail:
+	dispatch = glamor_get_dispatch(glamor_priv);
+	glamor_set_alu(dispatch, GXcopy);
+	glamor_put_dispatch(glamor_priv);
+
+	if (ok)
+		return TRUE;
+fall_back:
+	if (!fallback
 	    && glamor_ddx_fallback_check_pixmap(src)
 	    && glamor_ddx_fallback_check_pixmap(dst))
 		goto done;
@@ -424,14 +628,12 @@ _glamor_copy_n_to_n(DrawablePtr src,
 		}
 		glamor_finish_access(dst, GLAMOR_ACCESS_RW);
 	}
-	ret = TRUE;
+	ok = TRUE;
 
       done:
 	glamor_clear_delayed_fallbacks(src->pScreen);
 	glamor_clear_delayed_fallbacks(dst->pScreen);
-	if (temp_src != src)
-		glamor_destroy_pixmap(temp_pixmap);
-	return ret;
+	return ok;
 }
 
 RegionPtr
@@ -456,10 +658,10 @@ glamor_copy_n_to_n(DrawablePtr src,
 		   int dx,
 		   int dy,
 		   Bool reverse,
-		   Bool upsidedown, Pixel bitplane, 
+		   Bool upsidedown, Pixel bitplane,
 		   void *closure)
 {
-	_glamor_copy_n_to_n(src, dst, gc, box, nbox, dx, 
+	_glamor_copy_n_to_n(src, dst, gc, box, nbox, dx,
 			    dy, reverse, upsidedown, bitplane, closure, TRUE);
 }
 
@@ -472,10 +674,10 @@ glamor_copy_n_to_n_nf(DrawablePtr src,
 		   int dx,
 		   int dy,
 		   Bool reverse,
-		   Bool upsidedown, Pixel bitplane, 
+		   Bool upsidedown, Pixel bitplane,
 		   void *closure)
 {
-	return _glamor_copy_n_to_n(src, dst, gc, box, nbox, dx, 
+	return _glamor_copy_n_to_n(src, dst, gc, box, nbox, dx,
 				    dy, reverse, upsidedown, bitplane, closure, FALSE);
 }
 
diff --git a/glamor_core.c b/glamor_core.c
index 009a089..8ba3347 100644
--- a/glamor_core.c
+++ b/glamor_core.c
@@ -43,9 +43,9 @@ glamor_get_drawable_location(const DrawablePtr drawable)
 	    glamor_get_pixmap_private(pixmap);
 	glamor_screen_private *glamor_priv =
 	    glamor_get_screen_private(drawable->pScreen);
-	if (pixmap_priv == NULL || pixmap_priv->gl_fbo == 0)
+	if (pixmap_priv == NULL || pixmap_priv->base.gl_fbo == 0)
 		return 'm';
-	if (pixmap_priv->fbo->fb == glamor_priv->screen_fbo)
+	if (pixmap_priv->base.fbo->fb == glamor_priv->screen_fbo)
 		return 's';
 	else
 		return 'f';
@@ -327,7 +327,7 @@ glamor_finish_access(DrawablePtr drawable, glamor_access_t access_mode)
 		glamor_restore_pixmap_to_texture(pixmap);
 	}
 
-	if (pixmap_priv->fbo->pbo != 0 && pixmap_priv->fbo->pbo_valid) {
+	if (pixmap_priv->base.fbo->pbo != 0 && pixmap_priv->base.fbo->pbo_valid) {
 		glamor_gl_dispatch *dispatch;
 
 		assert(glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP);
@@ -335,20 +335,20 @@ glamor_finish_access(DrawablePtr drawable, glamor_access_t access_mode)
 		dispatch = glamor_get_dispatch(glamor_priv);
 		dispatch->glBindBuffer(GL_PIXEL_PACK_BUFFER, 0);
 		dispatch->glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
-		dispatch->glDeleteBuffers(1, &pixmap_priv->fbo->pbo);
+		dispatch->glDeleteBuffers(1, &pixmap_priv->base.fbo->pbo);
 		glamor_put_dispatch(glamor_priv);
 
-		pixmap_priv->fbo->pbo_valid = FALSE;
-		pixmap_priv->fbo->pbo = 0;
+		pixmap_priv->base.fbo->pbo_valid = FALSE;
+		pixmap_priv->base.fbo->pbo = 0;
 	} else {
 		free(pixmap->devPrivate.ptr);
 	}
 
 	if (pixmap_priv->type == GLAMOR_TEXTURE_DRM)
-		pixmap->devKind = pixmap_priv->drm_stride;
+		pixmap->devKind = pixmap_priv->base.drm_stride;
 
-	if (pixmap_priv->gl_fbo == GLAMOR_FBO_DOWNLOADED)
-		pixmap_priv->gl_fbo = GLAMOR_FBO_NORMAL;
+	if (pixmap_priv->base.gl_fbo == GLAMOR_FBO_DOWNLOADED)
+		pixmap_priv->base.gl_fbo = GLAMOR_FBO_NORMAL;
 
 	pixmap->devPrivate.ptr = NULL;
 }
diff --git a/glamor_debug.h b/glamor_debug.h
index 99dce04..f0c969b 100644
--- a/glamor_debug.h
+++ b/glamor_debug.h
@@ -107,8 +107,10 @@ AbortServer(void)
 		     _glamor_priv_->delayed_fallback_string);		\
       _glamor_priv_->delayed_fallback_pending = 0;  } } while(0)
 
-#define DEBUGF(str, ...)
+#define DEBUGF(str, ...)  do {} while(0)
 //#define DEBUGF(str, ...) ErrorF(str, ##__VA_ARGS__)
+#define DEBUGRegionPrint(x) do {} while (0)
+//#define DEBUGRegionPrint RegionPrint
 
 
 #endif
diff --git a/glamor_egl.c b/glamor_egl.c
index 35bcc9e..da9283b 100644
--- a/glamor_egl.c
+++ b/glamor_egl.c
@@ -59,6 +59,7 @@
 #include <EGL/eglext.h>
 
 #include "glamor.h"
+#include "compat-api.h"
 #include "glamor_gl_dispatch.h"
 #ifdef GLX_USE_SHARED_DISPATCH
 #include "glapi.h"
@@ -91,7 +92,8 @@ struct glamor_egl_screen_private {
 	struct gbm_device *gbm;
 #endif
 	int has_gem;
-	void *gl_context, *old_context;
+	void *glamor_context;
+	void *current_context;
 	int gl_context_depth;
 
 	PFNEGLCREATEIMAGEKHRPROC egl_create_image_khr;
@@ -121,10 +123,9 @@ glamor_egl_make_current(ScreenPtr screen)
 	if (glamor_egl->gl_context_depth++)
 		return;
 
-	GET_CURRENT_CONTEXT(current);
-	glamor_egl->old_context = current;
+	GET_CURRENT_CONTEXT(glamor_egl->current_context);
 
-	if (glamor_egl->gl_context != current) {
+	if (glamor_egl->glamor_context != glamor_egl->current_context) {
 		eglMakeCurrent(glamor_egl->display, EGL_NO_SURFACE,
 			       EGL_NO_SURFACE, EGL_NO_CONTEXT);
 		if (!eglMakeCurrent(glamor_egl->display,
@@ -145,9 +146,9 @@ glamor_egl_restore_context(ScreenPtr screen)
 	if (--glamor_egl->gl_context_depth)
 		return;
 
-	if (glamor_egl->old_context &&
-	    glamor_egl->gl_context != glamor_egl->old_context)
-		SET_CURRENT_CONTEXT(glamor_egl->old_context);
+	if (glamor_egl->current_context &&
+	    glamor_egl->glamor_context != glamor_egl->current_context)
+		SET_CURRENT_CONTEXT(glamor_egl->current_context);
 }
 #else
 #define glamor_egl_make_current(x)
@@ -255,7 +256,7 @@ glamor_egl_create_textured_screen_ext(ScreenPtr screen,
 	return TRUE;
 }
 
-Bool
+static Bool
 glamor_egl_check_has_gem(int fd)
 {
 	struct drm_gem_flink flink;
@@ -365,7 +366,7 @@ glamor_egl_destroy_textured_pixmap(PixmapPtr pixmap)
 }
 
 static Bool
-glamor_egl_close_screen(int idx, ScreenPtr screen)
+glamor_egl_close_screen(CLOSE_SCREEN_ARGS_DECL)
 {
 	ScrnInfoPtr scrn;
 	struct glamor_egl_screen_private *glamor_egl;
@@ -391,7 +392,7 @@ glamor_egl_close_screen(int idx, ScreenPtr screen)
 
 	screen->CloseScreen = glamor_egl->saved_close_screen;
 
-	return screen->CloseScreen(idx, screen);
+	return screen->CloseScreen(CLOSE_SCREEN_ARGS);
 }
 
 static Bool
@@ -430,10 +431,15 @@ glamor_egl_screen_init(ScreenPtr screen)
 }
 
 static void
-glamor_egl_free_screen(int scrnIndex, int flags)
+glamor_egl_free_screen(FREE_SCREEN_ARGS_DECL)
 {
-	ScrnInfoPtr scrn = xf86Screens[scrnIndex];
+	ScrnInfoPtr scrn;
 	struct glamor_egl_screen_private *glamor_egl;
+#ifndef XF86_SCRN_INTERFACE
+	scrn = xf86Screens[arg];
+#else
+	scrn = arg;
+#endif
 
 	glamor_egl = glamor_egl_get_screen_private(scrn);
 	if (glamor_egl != NULL) {
@@ -447,7 +453,7 @@ glamor_egl_free_screen(int scrnIndex, int flags)
 #endif
 		scrn->FreeScreen = glamor_egl->saved_free_screen;
 		free(glamor_egl);
-		scrn->FreeScreen(scrnIndex, flags);
+		scrn->FreeScreen(FREE_SCREEN_ARGS);
 	}
 }
 
@@ -548,8 +554,7 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
 		return FALSE;
 	}
 #ifdef GLX_USE_SHARED_DISPATCH
-	GET_CURRENT_CONTEXT(current);
-	glamor_egl->gl_context = current;
+	GET_CURRENT_CONTEXT(glamor_egl->glamor_context);
 #endif
 	glamor_egl->saved_free_screen = scrn->FreeScreen;
 	scrn->FreeScreen = glamor_egl_free_screen;
diff --git a/glamor_fbo.c b/glamor_fbo.c
index d80771a..4af831d 100644
--- a/glamor_fbo.c
+++ b/glamor_fbo.c
@@ -34,7 +34,6 @@
 
 #define GLAMOR_CACHE_DEFAULT    0
 #define GLAMOR_CACHE_EXACT_SIZE 1
-#define GLAMOR_CACHE_TEXTURE	2
 
 //#define NO_FBO_CACHE 1
 #define FBO_CACHE_THRESHOLD  (256*1024*1024)
@@ -52,30 +51,6 @@
          &pos->member != (head);                                        \
          pos = tmp, tmp = __container_of(pos->member.prev, tmp, member))
 
-#ifdef __i386__
-static inline unsigned long __fls(unsigned long x)
-{
-        asm("bsr %1,%0"
-            : "=r" (x)
-            : "rm" (x));
-        return x;
-}
-#else
-static inline unsigned long __fls(unsigned long x)
-{
-   int n;
-
-   if (x == 0) return(0);
-   n = 0;
-   if (x <= 0x0000FFFF) {n = n +16; x = x <<16;}
-   if (x <= 0x00FFFFFF) {n = n + 8; x = x << 8;}
-   if (x <= 0x0FFFFFFF) {n = n + 4; x = x << 4;}
-   if (x <= 0x3FFFFFFF) {n = n + 2; x = x << 2;}
-   if (x <= 0x7FFFFFFF) {n = n + 1;}
-   return 31 - n;
-}
-#endif
-
 inline static int cache_wbucket(int size)
 {
 	int order = __fls(size / 32);
@@ -92,7 +67,7 @@ inline static int cache_hbucket(int size)
 	return order;
 }
 
-glamor_pixmap_fbo *
+static glamor_pixmap_fbo *
 glamor_pixmap_fbo_cache_get(glamor_screen_private *glamor_priv,
 			    int w, int h, GLenum format, int flag)
 {
@@ -105,14 +80,9 @@ glamor_pixmap_fbo_cache_get(glamor_screen_private *glamor_priv,
 	n_format = cache_format(format);
 	if (n_format == -1)
 		return NULL;
-	if (!(flag & GLAMOR_CACHE_TEXTURE))
-		cache = &glamor_priv->fbo_cache[n_format]
-					       [cache_wbucket(w)]
-					       [cache_hbucket(h)];
-	else
-		cache = &glamor_priv->tex_cache[n_format]
-					       [cache_wbucket(w)]
-					       [cache_hbucket(h)];
+	cache = &glamor_priv->fbo_cache[n_format]
+				       [cache_wbucket(w)]
+				       [cache_hbucket(h)];
 	if (!(flag & GLAMOR_CACHE_EXACT_SIZE)) {
 		xorg_list_for_each_entry(fbo_entry, cache, list) {
 			if (fbo_entry->width >= w && fbo_entry->height >= h) {
@@ -181,19 +151,15 @@ glamor_pixmap_fbo_cache_put(glamor_pixmap_fbo *fbo)
 
 	if (fbo->fb == 0 || n_format == -1
 	   || fbo->glamor_priv->fbo_cache_watermark >= FBO_CACHE_THRESHOLD) {
-		fbo->glamor_priv->tick ++;
+		fbo->glamor_priv->tick += GLAMOR_CACHE_EXPIRE_MAX;
+		glamor_fbo_expire(fbo->glamor_priv);
 		glamor_purge_fbo(fbo);
 		return;
 	}
 
-	if (fbo->fb)
-		cache = &fbo->glamor_priv->fbo_cache[n_format]
-						    [cache_wbucket(fbo->width)]
-						    [cache_hbucket(fbo->height)];
-	else
-		cache = &fbo->glamor_priv->tex_cache[n_format]
-						    [cache_wbucket(fbo->width)]
-						    [cache_hbucket(fbo->height)];
+	cache = &fbo->glamor_priv->fbo_cache[n_format]
+					    [cache_wbucket(fbo->width)]
+					    [cache_hbucket(fbo->height)];
 	DEBUGF("Put cache entry %p to cache %p w %d h %d format %x fbo %d tex %d \n", fbo, cache,
 		fbo->width, fbo->height, fbo->format, fbo->fb, fbo->tex);
 
@@ -310,19 +276,6 @@ glamor_fbo_expire(glamor_screen_private *glamor_priv)
 						fbo_entry->expire, glamor_priv->tick);
 					glamor_purge_fbo(fbo_entry);
 				}
-#if 0
-				cache = &glamor_priv->tex_cache[i][j][k];
-				xorg_list_for_each_entry_safe_reverse(fbo_entry, tmp, cache, list) {
-					if (GLAMOR_TICK_AFTER(fbo_entry->expire, glamor_priv->tick)) {
-						empty_cache = FALSE;
-						break;
-					}
-					xorg_list_del(&fbo_entry->list);
-					DEBUGF("cache %p fbo %p expired %d current %d \n", cache, fbo_entry,
-						fbo_entry->expire, glamor_priv->tick);
-					glamor_purge_fbo(fbo_entry);
-				}
-#endif
 			}
 
 }
@@ -339,7 +292,6 @@ glamor_init_pixmap_fbo(ScreenPtr screen)
 			for(k = 0; k < CACHE_BUCKET_HCOUNT; k++)
 			{
 				xorg_list_init(&glamor_priv->fbo_cache[i][j][k]);
-				xorg_list_init(&glamor_priv->tex_cache[i][j][k]);
 			}
 	glamor_priv->fbo_cache_watermark = 0;
 }
@@ -362,13 +314,6 @@ glamor_fini_pixmap_fbo(ScreenPtr screen)
 					xorg_list_del(&fbo_entry->list);
 					glamor_purge_fbo(fbo_entry);
 				}
-#if 0
-				cache = &glamor_priv->tex_cache[i][j][k];
-				xorg_list_for_each_entry_safe_reverse(fbo_entry, tmp, cache, list) {
-					xorg_list_del(&fbo_entry->list);
-					glamor_purge_fbo(fbo_entry);
-				}
-#endif
 			}
 }
 
@@ -380,57 +325,7 @@ glamor_destroy_fbo(glamor_pixmap_fbo *fbo)
 
 }
 
-glamor_pixmap_fbo *
-glamor_create_tex_obj(glamor_screen_private *glamor_priv,
-		      int w, int h, GLenum format, int flag)
-{
-	glamor_gl_dispatch *dispatch;
-	glamor_pixmap_fbo *fbo;
-	int cache_flag = GLAMOR_CACHE_TEXTURE;
-	GLuint tex;
-
-	if (flag == GLAMOR_CREATE_TEXTURE_EXACT_SIZE)
-		cache_flag |= GLAMOR_CACHE_EXACT_SIZE;
-
-	fbo = glamor_pixmap_fbo_cache_get(glamor_priv, w, h,
-					  format, cache_flag);
-	if (fbo)
-		return fbo;
-	fbo = calloc(1, sizeof(*fbo));
-	if (fbo == NULL)
-		return NULL;
-
-	xorg_list_init(&fbo->list);
-
-	dispatch = glamor_get_dispatch(glamor_priv);
-	dispatch->glGenTextures(1, &tex);
-	dispatch->glBindTexture(GL_TEXTURE_2D, tex);
-	dispatch->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
-				  GL_NEAREST);
-	dispatch->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
-				  GL_NEAREST);
-	dispatch->glTexImage2D(GL_TEXTURE_2D, 0, format, w, h, 0, format,
-			       GL_UNSIGNED_BYTE, NULL);
-	glamor_put_dispatch(glamor_priv);
-
-	fbo->tex = tex;
-	fbo->width = w;
-	fbo->height = h;
-	fbo->format = format;
-	fbo->glamor_priv = glamor_priv;
-
-	return fbo;
-}
-
-void
-glamor_destroy_tex_obj(glamor_pixmap_fbo * tex_obj)
-{
-	assert(tex_obj->fb == 0);
-	xorg_list_del(&tex_obj->list);
-	glamor_pixmap_fbo_cache_put(tex_obj);
-}
-
-int
+static int
 _glamor_create_tex(glamor_screen_private *glamor_priv,
 		   int w, int h, GLenum format)
 {
@@ -486,6 +381,92 @@ no_tex:
 	return fbo;
 }
 
+static glamor_pixmap_fbo *
+_glamor_create_fbo_array(glamor_screen_private *glamor_priv,
+			 int w, int h, GLenum format, int flag,
+			 int block_w, int block_h,
+			 glamor_pixmap_private *pixmap_priv,
+			 int has_fbo)
+{
+	int block_wcnt;
+	int block_hcnt;
+	glamor_pixmap_fbo **fbo_array;
+	BoxPtr box_array;
+	int i,j;
+	glamor_pixmap_private_large_t *priv;
+
+	priv = &pixmap_priv->large;
+
+	block_wcnt = (w + block_w - 1) / block_w;
+	block_hcnt = (h + block_h - 1) / block_h;
+
+	box_array = calloc(block_wcnt * block_hcnt, sizeof(box_array[0]));
+	if (box_array == NULL)
+		return NULL;
+
+	fbo_array = calloc(block_wcnt * block_hcnt, sizeof(glamor_pixmap_fbo*));
+	if (fbo_array == NULL) {
+		free(box_array);
+		return FALSE;
+	}
+	for(i = 0; i < block_hcnt; i++)
+	{
+		int block_y1, block_y2;
+		int fbo_w, fbo_h;
+
+		block_y1 = i * block_h;
+		block_y2 = (block_y1 + block_h) > h ? h : (block_y1 + block_h);
+		fbo_h = block_y2 - block_y1;
+
+		for (j = 0; j < block_wcnt; j++)
+		{
+			box_array[i * block_wcnt + j].x1 = j * block_w;
+			box_array[i * block_wcnt + j].y1 = block_y1;
+			box_array[i * block_wcnt + j].x2 = (j + 1) * block_w > w ? w : (j + 1) * block_w;
+			box_array[i * block_wcnt + j].y2 = block_y2;
+			fbo_w = box_array[i * block_wcnt + j].x2 - box_array[i * block_wcnt + j].x1;
+			if (!has_fbo)
+				fbo_array[i * block_wcnt + j] = glamor_create_fbo(glamor_priv,
+										  fbo_w, fbo_h, format,
+										  GLAMOR_CREATE_PIXMAP_FIXUP);
+			else
+				fbo_array[i * block_wcnt + j] = priv->base.fbo;
+			if (fbo_array[i * block_wcnt + j] == NULL)
+				goto cleanup;
+		}
+	}
+
+	priv->box = box_array[0];
+	priv->box_array = box_array;
+	priv->fbo_array = fbo_array;
+	priv->block_wcnt = block_wcnt;
+	priv->block_hcnt = block_hcnt;
+	return fbo_array[0];
+
+cleanup:
+	for(i = 0; i < block_wcnt * block_hcnt; i++)
+		if ((fbo_array)[i])
+			glamor_destroy_fbo((fbo_array)[i]);
+	free(box_array);
+	free(fbo_array);
+	return NULL;
+}
+
+
+/* Create a fbo array to cover the w*h region, by using block_w*block_h
+ * block.*/
+glamor_pixmap_fbo *
+glamor_create_fbo_array(glamor_screen_private *glamor_priv,
+			int w, int h, GLenum format, int flag,
+			int block_w, int block_h,
+			glamor_pixmap_private *pixmap_priv)
+{
+	pixmap_priv->large.block_w = block_w;
+	pixmap_priv->large.block_h = block_h;
+	return _glamor_create_fbo_array(glamor_priv, w, h, format, flag,
+					block_w, block_h, pixmap_priv, 0);
+}
+
 glamor_pixmap_fbo *
 glamor_pixmap_detach_fbo(glamor_pixmap_private *pixmap_priv)
 {
@@ -494,11 +475,11 @@ glamor_pixmap_detach_fbo(glamor_pixmap_private *pixmap_priv)
 	if (pixmap_priv == NULL)
 		return NULL;
 
-	fbo = pixmap_priv->fbo;
+	fbo = pixmap_priv->base.fbo;
 	if (fbo == NULL)
 		return NULL;
 
-	pixmap_priv->fbo = NULL;
+	pixmap_priv->base.fbo = NULL;
 	return fbo;
 }
 
@@ -510,31 +491,21 @@ glamor_pixmap_attach_fbo(PixmapPtr pixmap, glamor_pixmap_fbo *fbo)
 
 	pixmap_priv = glamor_get_pixmap_private(pixmap);
 
-	if (pixmap_priv == NULL) {
-		glamor_screen_private *glamor_priv;
-		glamor_priv = glamor_get_screen_private(pixmap->drawable.pScreen);
-		pixmap_priv = calloc(1, sizeof(*pixmap_priv));
-		dixSetPrivate(&pixmap->devPrivates,
-			      glamor_pixmap_private_key, pixmap_priv);
-		pixmap_priv->container = pixmap;
-		pixmap_priv->glamor_priv = glamor_priv;
-		pixmap_priv->type = GLAMOR_MEMORY;
-	}
-
-	if (pixmap_priv->fbo)
+	if (pixmap_priv->base.fbo)
 		return;
 
-	pixmap_priv->fbo = fbo;
+	pixmap_priv->base.fbo = fbo;
 
 	switch (pixmap_priv->type) {
+	case GLAMOR_TEXTURE_LARGE:
 	case GLAMOR_TEXTURE_ONLY:
 	case GLAMOR_TEXTURE_DRM:
-		pixmap_priv->gl_fbo = 1;
+		pixmap_priv->base.gl_fbo = 1;
 		if (fbo->tex != 0)
-			pixmap_priv->gl_tex = 1;
+			pixmap_priv->base.gl_tex = 1;
 		else {
 			/* XXX For the Xephyr only, may be broken now.*/
-			pixmap_priv->gl_tex = 0;
+			pixmap_priv->base.gl_tex = 0;
 		}
 	case GLAMOR_MEMORY_MAP:
 		pixmap->devPrivate.ptr = NULL;
@@ -544,6 +515,24 @@ glamor_pixmap_attach_fbo(PixmapPtr pixmap, glamor_pixmap_fbo *fbo)
 	}
 }
 
+void
+glamor_pixmap_destroy_fbo(glamor_pixmap_private *priv)
+{
+	glamor_pixmap_fbo *fbo;
+	if (priv->type == GLAMOR_TEXTURE_LARGE) {
+		int i;
+		glamor_pixmap_private_large_t *large = &priv->large;
+		for(i = 0; i < large->block_wcnt * large->block_hcnt; i++)
+			glamor_destroy_fbo(large->fbo_array[i]);
+		free(large->fbo_array);
+	} else {
+		fbo = glamor_pixmap_detach_fbo(priv);
+		if (fbo)
+			glamor_destroy_fbo(fbo);
+	}
+
+	free(priv);
+}
 
 Bool
 glamor_pixmap_ensure_fbo(PixmapPtr pixmap, GLenum format, int flag)
@@ -554,7 +543,7 @@ glamor_pixmap_ensure_fbo(PixmapPtr pixmap, GLenum format, int flag)
 
 	glamor_priv = glamor_get_screen_private(pixmap->drawable.pScreen);
 	pixmap_priv = glamor_get_pixmap_private(pixmap);
-	if (pixmap_priv == NULL || pixmap_priv->fbo == NULL) {
+	if (pixmap_priv->base.fbo == NULL) {
 
 		fbo = glamor_create_fbo(glamor_priv, pixmap->drawable.width,
 					pixmap->drawable.height,
@@ -566,15 +555,14 @@ glamor_pixmap_ensure_fbo(PixmapPtr pixmap, GLenum format, int flag)
 		glamor_pixmap_attach_fbo(pixmap, fbo);
 	} else {
 		/* We do have a fbo, but it may lack of fb or tex. */
-		if (!pixmap_priv->fbo->tex)
-			pixmap_priv->fbo->tex = _glamor_create_tex(glamor_priv, pixmap->drawable.width,
+		if (!pixmap_priv->base.fbo->tex)
+			pixmap_priv->base.fbo->tex = _glamor_create_tex(glamor_priv, pixmap->drawable.width,
 								   pixmap->drawable.height, format);
 
-		if (flag != GLAMOR_CREATE_FBO_NO_FBO && pixmap_priv->fbo->fb == 0)
-			glamor_pixmap_ensure_fb(pixmap_priv->fbo);
+		if (flag != GLAMOR_CREATE_FBO_NO_FBO && pixmap_priv->base.fbo->fb == 0)
+			glamor_pixmap_ensure_fb(pixmap_priv->base.fbo);
 	}
 
-	pixmap_priv = glamor_get_pixmap_private(pixmap);
 	return TRUE;
 }
 
@@ -586,7 +574,7 @@ glamor_pixmap_exchange_fbos(PixmapPtr front, PixmapPtr back)
 
 	front_priv = glamor_get_pixmap_private(front);
 	back_priv = glamor_get_pixmap_private(back);
-	temp_fbo = front_priv->fbo;
-	front_priv->fbo = back_priv->fbo;
-	back_priv->fbo = temp_fbo;
+	temp_fbo = front_priv->base.fbo;
+	front_priv->base.fbo = back_priv->base.fbo;
+	back_priv->base.fbo = temp_fbo;
 }
diff --git a/glamor_fill.c b/glamor_fill.c
index 072408e..1d81aea 100644
--- a/glamor_fill.c
+++ b/glamor_fill.c
@@ -180,10 +180,8 @@ glamor_fini_solid_shader(ScreenPtr screen)
 	glamor_put_dispatch(glamor_priv);
 }
 
-Bool
-glamor_solid(PixmapPtr pixmap, int x, int y, int width, int height,
-	     unsigned char alu, unsigned long planemask,
-	     unsigned long fg_pixel)
+static void
+_glamor_solid_boxes(PixmapPtr pixmap, BoxPtr box, int nbox, float *color)
 {
 	ScreenPtr screen = pixmap->drawable.pScreen;
 	glamor_screen_private *glamor_priv =
@@ -191,60 +189,168 @@ glamor_solid(PixmapPtr pixmap, int x, int y, int width, int height,
 	glamor_pixmap_private *pixmap_priv =
 	    glamor_get_pixmap_private(pixmap);
 	glamor_gl_dispatch *dispatch;
-	int x1 = x;
-	int x2 = x + width;
-	int y1 = y;
-	int y2 = y + height;
-	GLfloat color[4];
-	float vertices[8];
 	GLfloat xscale, yscale;
+	float vertices[32];
+	float *pvertices = vertices;
+	int valid_nbox = ARRAY_SIZE(vertices);
 
-	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv)) {
-		glamor_fallback("dest %p has no fbo.\n", pixmap);
-		return FALSE;
+	glamor_set_destination_pixmap_priv_nc(pixmap_priv);
+
+	dispatch = glamor_get_dispatch(glamor_priv);
+	dispatch->glUseProgram(glamor_priv->solid_prog);
+
+	dispatch->glUniform4fv(glamor_priv->solid_color_uniform_location,
+			       1, color);
+
+	pixmap_priv_get_dest_scale(pixmap_priv, &xscale, &yscale);
+
+	if (unlikely(nbox*4*2 > ARRAY_SIZE(vertices))) {
+		int allocated_box;
+
+		if (nbox * 6 > GLAMOR_COMPOSITE_VBO_VERT_CNT) {
+			allocated_box = GLAMOR_COMPOSITE_VBO_VERT_CNT / 6;
+		} else
+			allocated_box = nbox;
+		pvertices = malloc(allocated_box * 4 * 2 * sizeof(float));
+		if (pvertices)
+			valid_nbox = allocated_box;
+		else {
+			pvertices = vertices;
+			valid_nbox = ARRAY_SIZE(vertices) / (4*2);
+		}
 	}
 
-	if (!glamor_set_planemask(pixmap, planemask)) {
-		glamor_fallback
-		    ("Failedto set planemask  in glamor_solid.\n");
-		return FALSE;
+#define GLAMOR_COMPOSITE_VBO_VERT_CNT 1024
+	if (unlikely(nbox > 1))
+		dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, glamor_priv->ebo);
+
+	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_POS, 2, GL_FLOAT,
+					GL_FALSE, 2 * sizeof(float),
+					pvertices);
+	dispatch->glEnableVertexAttribArray(GLAMOR_VERTEX_POS);
+
+	while(nbox) {
+		int box_cnt, i;
+		float *valid_vertices;
+		valid_vertices = pvertices;
+		box_cnt = nbox > valid_nbox ? valid_nbox : nbox;
+		for (i = 0; i < box_cnt; i++) {
+			glamor_set_normalize_vcoords(pixmap_priv, xscale, yscale,
+						     box[i].x1, box[i].y1,
+						     box[i].x2, box[i].y2,
+						     glamor_priv->yInverted,
+						     valid_vertices);
+			valid_vertices += 4*2;
+		}
+		if (box_cnt == 1)
+			dispatch->glDrawArrays(GL_TRIANGLE_FAN, 0, box_cnt * 4);
+		else
+			dispatch->glDrawElements(GL_TRIANGLES,
+						 box_cnt * 6,
+						 GL_UNSIGNED_SHORT,
+						 NULL);
+		nbox -= box_cnt;
+		box += box_cnt;
 	}
 
+	if (pvertices != vertices)
+		free(pvertices);
+
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
+	dispatch->glUseProgram(0);
+	glamor_put_dispatch(glamor_priv);
+	glamor_priv->state = RENDER_STATE;
+	glamor_priv->render_idle_cnt = 0;
+}
+
+Bool
+glamor_solid_boxes(PixmapPtr pixmap,
+		   BoxPtr box, int nbox,
+		   unsigned long fg_pixel)
+{
+	glamor_pixmap_private *pixmap_priv;
+	GLfloat color[4];
+
+	pixmap_priv = glamor_get_pixmap_private(pixmap);
+
+	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv))
+		return FALSE;
+
 	glamor_get_rgba_from_pixel(fg_pixel,
 				   &color[0],
 				   &color[1],
 				   &color[2],
 				   &color[3], format_for_pixmap(pixmap));
 
-	glamor_set_destination_pixmap_priv_nc(pixmap_priv);
+	if (pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
+		RegionRec region;
+		int n_region;
+		glamor_pixmap_clipped_regions *clipped_regions;
+		int i;
+
+		RegionInitBoxes(&region, box, nbox);
+		clipped_regions = glamor_compute_clipped_regions(pixmap_priv, &region, &n_region, 0, 0, 0);
+		for(i = 0; i < n_region; i++)
+		{
+			BoxPtr inner_box;
+			int inner_nbox;
+			SET_PIXMAP_FBO_CURRENT(pixmap_priv, clipped_regions[i].block_idx);
+
+			inner_box = RegionRects(clipped_regions[i].region);
+			inner_nbox = RegionNumRects(clipped_regions[i].region);
+			_glamor_solid_boxes(pixmap, inner_box, inner_nbox, color);
+			RegionDestroy(clipped_regions[i].region);
+		}
+		free(clipped_regions);
+		RegionUninit(&region);
+	} else
+		_glamor_solid_boxes(pixmap, box, nbox, color);
+
+	return TRUE;
+}
+
+Bool
+glamor_solid(PixmapPtr pixmap, int x, int y, int width, int height,
+	     unsigned char alu, unsigned long planemask,
+	     unsigned long fg_pixel)
+{
+	ScreenPtr screen = pixmap->drawable.pScreen;
+	glamor_screen_private *glamor_priv =
+	    glamor_get_screen_private(screen);
+	glamor_pixmap_private *pixmap_priv;
+	glamor_gl_dispatch *dispatch;
+	BoxRec box;
+
+	pixmap_priv = glamor_get_pixmap_private(pixmap);
+
+	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv))
+		return FALSE;
+
+	if (!glamor_set_planemask(pixmap, planemask)) {
+		glamor_fallback
+		    ("Failedto set planemask  in glamor_solid.\n");
+		return FALSE;
+	}
 
 	dispatch = glamor_get_dispatch(glamor_priv);
 	if (!glamor_set_alu(dispatch, alu)) {
 		if (alu == GXclear)
-			color[0] = color[1] = color[2] = color[3] = 0.0;
+			fg_pixel = 0;
 		else {
 			glamor_fallback("unsupported alu %x\n", alu);
 			glamor_put_dispatch(glamor_priv);
 			return FALSE;
 		}
 	}
-	dispatch->glUseProgram(glamor_priv->solid_prog);
+	box.x1 = x;
+	box.y1 = y;
+	box.x2 = x + width;
+	box.y2 = y + height;
+	glamor_solid_boxes(pixmap, &box, 1, fg_pixel);
 
-	dispatch->glUniform4fv(glamor_priv->solid_color_uniform_location,
-			       1, color);
-
-	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_POS, 2, GL_FLOAT,
-					GL_FALSE, 2 * sizeof(float),
-					vertices);
-	dispatch->glEnableVertexAttribArray(GLAMOR_VERTEX_POS);
-	pixmap_priv_get_scale(pixmap_priv, &xscale, &yscale);
-
-	glamor_set_normalize_vcoords(xscale, yscale, x1, y1, x2, y2,
-				     glamor_priv->yInverted, vertices);
-	dispatch->glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
-	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
-	dispatch->glUseProgram(0);
 	glamor_set_alu(dispatch, GXcopy);
 	glamor_put_dispatch(glamor_priv);
+
 	return TRUE;
 }
+
diff --git a/glamor_getimage.c b/glamor_getimage.c
index 655ed94..f446c83 100644
--- a/glamor_getimage.c
+++ b/glamor_getimage.c
@@ -45,6 +45,8 @@ _glamor_get_image(DrawablePtr drawable, int x, int y, int w, int h,
 
 	if (format != ZPixmap)
 		goto fall_back;
+	pixmap = glamor_get_drawable_pixmap(drawable);
+	glamor_get_drawable_deltas(drawable, pixmap, &x_off, &y_off);
 
 	if (!glamor_set_planemask(pixmap, planeMask)) {
 		glamor_fallback
@@ -78,7 +80,7 @@ fall_back:
 				      y + y_off + drawable->y,
 				      w, h, GLAMOR_ACCESS_RO);
 	} else
-		fbGetImage(drawable, x, y, w, h, format, planeMask, d);
+		miGetImage(drawable, x, y, w, h, format, planeMask, d);
 
 	return TRUE;
 }
diff --git a/glamor_glext.h b/glamor_glext.h
index d60c696..1f7206b 100644
--- a/glamor_glext.h
+++ b/glamor_glext.h
@@ -57,5 +57,8 @@
 #define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
 
 #define GL_PACK_INVERT_MESA               0x8758
+#define GL_MAP_UNSYNCHRONIZED_BIT         0x0020
+#define GL_MAP_READ_BIT                   0x0001
+#define GL_MAP_WRITE_BIT                  0x0002
 
 #endif
diff --git a/glamor_glyphs.c b/glamor_glyphs.c
index fe7d9de..bab2c24 100644
--- a/glamor_glyphs.c
+++ b/glamor_glyphs.c
@@ -16,7 +16,7 @@
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL Red Hat
  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
@@ -33,7 +33,7 @@
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  *
  * Author: Owen Taylor <otaylor@fishsoup.net>
@@ -62,14 +62,17 @@
  */
 #define GLYPH_BUFFER_SIZE 1024
 
-#define CACHE_PICTURE_SIZE  1024
+#define CACHE_PICTURE_SIZE 1024
 #define GLYPH_MIN_SIZE 8
-#define GLYPH_MAX_SIZE 64
-#define GLYPH_CACHE_SIZE (CACHE_PICTURE_SIZE * CACHE_PICTURE_SIZE / (GLYPH_MIN_SIZE * GLYPH_MIN_SIZE))
+#define GLYPH_MAX_SIZE	64
+#define GLYPH_CACHE_SIZE ((CACHE_PICTURE_SIZE) * CACHE_PICTURE_SIZE / (GLYPH_MIN_SIZE * GLYPH_MIN_SIZE))
+#define MASK_CACHE_MAX_SIZE 32
+#define MASK_CACHE_WIDTH (CACHE_PICTURE_SIZE / MASK_CACHE_MAX_SIZE)
+#define MASK_CACHE_MASK ((1LL << (MASK_CACHE_WIDTH)) - 1)
 
 typedef struct {
 	PicturePtr source;
-	glamor_composite_rect_t rects[GLYPH_BUFFER_SIZE];
+	glamor_composite_rect_t rects[GLYPH_BUFFER_SIZE + 4];
 	int count;
 } glamor_glyph_buffer_t;
 
@@ -77,6 +80,10 @@ struct glamor_glyph {
 	glamor_glyph_cache_t *cache;
 	uint16_t x, y;
 	uint16_t size, pos;
+	unsigned long long left_x1_map, left_x2_map;
+	unsigned long long right_x1_map, right_x2_map;  /* Use to check real intersect or not. */
+	Bool has_edge_map;
+	Bool cached;
 };
 
 typedef enum {
@@ -85,23 +92,171 @@ typedef enum {
 	GLAMOR_GLYPH_NEED_FLUSH,	/* would evict a glyph already in the buffer */
 } glamor_glyph_cache_result_t;
 
-
-
 #define NeedsComponent(f) (PICT_FORMAT_A(f) != 0 && PICT_FORMAT_RGB(f) != 0)
 static DevPrivateKeyRec glamor_glyph_key;
 
 static inline struct glamor_glyph *
 glamor_glyph_get_private(GlyphPtr glyph)
 {
-	return dixGetPrivate(&glyph->devPrivates, &glamor_glyph_key);
+	return (struct glamor_glyph*)glyph->devPrivates;
+}
+
+/*
+ * Mask cache is located at the corresponding cache picture's last row.
+ * and is deadicated for the mask picture when do the glyphs_via_mask.
+ *
+ * As we split the glyphs list according to its overlapped or non-overlapped,
+ * we can reduce the length of glyphs to do the glyphs_via_mask to 2 or 3
+ * glyphs one time for most cases. Thus it give us a case to allocate a
+ * small portion of the corresponding cache directly as the mask picture.
+ * Then we can rendering the glyphs to this mask picture, and latter we
+ * can accumulate the second steps, composite the mask to the dest with
+ * the other non-overlapped glyphs's rendering process.
+ * Another major benefit is we now only need to clear a relatively small mask
+ * region then before. It also make us implement a bunch mask picture clearing
+ * algorithm to avoid too frequently small region clearing.
+ *
+ * If there is no any overlapping, this method will not get performance gain.
+ * If there is some overlapping, then this algorithm can get about 15% performance
+ * gain.
+ */
+
+struct glamor_glyph_mask_cache_entry {
+	int idx;
+	int width;
+	int height;
+	int x;
+	int y;
+};
+
+static struct glamor_glyph_mask_cache {
+	PixmapPtr pixmap;
+	struct glamor_glyph_mask_cache_entry mcache[MASK_CACHE_WIDTH];
+	unsigned int free_bitmap;
+	unsigned int cleared_bitmap;
+}*mask_cache[GLAMOR_NUM_GLYPH_CACHE_FORMATS] = {NULL};
+
+static void
+clear_mask_cache_bitmap(struct glamor_glyph_mask_cache *maskcache,
+		     unsigned int clear_mask_bits)
+{
+	unsigned int i = 0;
+	BoxRec box[MASK_CACHE_WIDTH];
+	int box_cnt = 0;
+
+	assert((clear_mask_bits & ~MASK_CACHE_MASK) == 0);
+	for(i = 0; i < MASK_CACHE_WIDTH;i++)
+	{
+		if (clear_mask_bits & (1 << i)) {
+			box[box_cnt].x1 = maskcache->mcache[i].x;
+			box[box_cnt].x2 = maskcache->mcache[i].x + MASK_CACHE_MAX_SIZE;
+			box[box_cnt].y1 = maskcache->mcache[i].y;
+			box[box_cnt].y2 = maskcache->mcache[i].y + MASK_CACHE_MAX_SIZE;
+			box_cnt++;
+		}
+	}
+	glamor_solid_boxes(maskcache->pixmap, box, box_cnt, 0);
+	maskcache->cleared_bitmap |= clear_mask_bits;
+}
+
+static void
+clear_mask_cache(struct glamor_glyph_mask_cache *maskcache)
+{
+	int x = 0;
+	int cnt = MASK_CACHE_WIDTH;
+	unsigned int i = 0;
+	struct glamor_glyph_mask_cache_entry *mce;
+	glamor_solid(maskcache->pixmap, 0, CACHE_PICTURE_SIZE, CACHE_PICTURE_SIZE,
+		     MASK_CACHE_MAX_SIZE, GXcopy, 0xFFFFFFFF, 0);
+	mce = &maskcache->mcache[0];
+	while(cnt--) {
+		mce->width = 0;
+		mce->height = 0;
+		mce->x = x;
+		mce->y = CACHE_PICTURE_SIZE;
+		mce->idx = i++;
+		x += MASK_CACHE_MAX_SIZE;
+		mce++;
+	}
+	maskcache->free_bitmap = MASK_CACHE_MASK;
+	maskcache->cleared_bitmap = MASK_CACHE_MASK;
 }
 
-static inline void
-glamor_glyph_set_private(GlyphPtr glyph, struct glamor_glyph *priv)
+static int
+find_continuous_bits(unsigned int bits, int bits_cnt, unsigned int *pbits_mask)
 {
-	dixSetPrivate(&glyph->devPrivates, &glamor_glyph_key, priv);
+	int idx = 0;
+	unsigned int bits_mask;
+	bits_mask = ((1LL << bits_cnt) - 1);
+
+	if (unlikely(bits_cnt > 56)) {
+		while(bits) {
+			if ((bits & bits_mask) == bits_mask) {
+				*pbits_mask = bits_mask << idx;
+				return idx;
+			}
+			bits >>= 1;
+			idx++;
+		}
+	} else {
+		idx = __fls(bits);
+		while(bits) {
+			unsigned int temp_bits;
+			temp_bits = bits_mask << (idx - bits_cnt + 1);
+			if ((bits & temp_bits) == temp_bits) {
+				*pbits_mask = temp_bits;
+				return (idx - bits_cnt + 1);
+			}
+			/* Find first zero. And clear the tested bit.*/
+			bits &= ~(1LL<<idx);
+			idx = __fls(~bits);
+			bits &= ~((1LL << idx) - 1);
+			idx--;
+		}
+	}
+	return -1;
 }
 
+static struct glamor_glyph_mask_cache_entry *
+get_mask_cache(struct glamor_glyph_mask_cache *maskcache, int blocks)
+{
+	int free_cleared_bit, idx = -1;
+	int retry_cnt = 0;
+	unsigned int bits_mask;
+
+	if (maskcache->free_bitmap == 0)
+		return NULL;
+retry:
+	free_cleared_bit = maskcache->free_bitmap & maskcache->cleared_bitmap;
+	if (free_cleared_bit && blocks == 1) {
+		idx = __fls(free_cleared_bit);
+		bits_mask = 1 << idx;
+	} else if (free_cleared_bit && blocks > 1) {
+		idx = find_continuous_bits(free_cleared_bit, blocks, &bits_mask);
+	}
+
+	if (idx < 0) {
+		clear_mask_cache_bitmap(maskcache, maskcache->free_bitmap);
+		if (retry_cnt++ > 2)
+			return NULL;
+		goto retry;
+	}
+
+	maskcache->cleared_bitmap &= ~bits_mask;
+	maskcache->free_bitmap &= ~bits_mask;
+	DEBUGF("get idx %d free %x clear %x \n",
+		idx, maskcache->free_bitmap, maskcache->cleared_bitmap);
+	return &maskcache->mcache[idx];
+}
+
+static void
+put_mask_cache_bitmap(struct glamor_glyph_mask_cache *maskcache,
+		       unsigned int bitmap)
+{
+	maskcache->free_bitmap |= bitmap;
+	DEBUGF("put bitmap %x free %x clear %x \n",
+		bitmap, maskcache->free_bitmap, maskcache->cleared_bitmap);
+}
 
 static void
 glamor_unrealize_glyph_caches(ScreenPtr pScreen)
@@ -120,6 +275,9 @@ glamor_unrealize_glyph_caches(ScreenPtr pScreen)
 
 		if (cache->glyphs)
 			free(cache->glyphs);
+
+		if (mask_cache[i])
+			free(mask_cache[i]);
 	}
 	glamor->glyph_cache_initialized = FALSE;
 }
@@ -139,6 +297,7 @@ glamor_glyphs_fini(ScreenPtr pScreen)
  * This function allocates the storage pixmap, and then fills in the
  * rest of the allocated structures for all caches with the given format.
  */
+
 static Bool
 glamor_realize_glyph_caches(ScreenPtr pScreen)
 {
@@ -170,7 +329,7 @@ glamor_realize_glyph_caches(ScreenPtr pScreen)
 		/* Now allocate the pixmap and picture */
 		pixmap = pScreen->CreatePixmap(pScreen,
 					      CACHE_PICTURE_SIZE,
-					      CACHE_PICTURE_SIZE, depth,
+					      CACHE_PICTURE_SIZE + MASK_CACHE_MAX_SIZE, depth,
 					      0);
 		if (!pixmap)
 			goto bail;
@@ -192,6 +351,9 @@ glamor_realize_glyph_caches(ScreenPtr pScreen)
 			goto bail;
 
 		cache->evict = rand() % GLYPH_CACHE_SIZE;
+		mask_cache[i] = calloc(1, sizeof(*mask_cache[i]));
+		mask_cache[i]->pixmap = pixmap;
+		clear_mask_cache(mask_cache[i]);
 	}
 	assert(i == GLAMOR_NUM_GLYPH_CACHE_FORMATS);
 
@@ -206,7 +368,8 @@ glamor_realize_glyph_caches(ScreenPtr pScreen)
 Bool
 glamor_glyphs_init(ScreenPtr pScreen)
 {
-	if (!dixRegisterPrivateKey(&glamor_glyph_key, PRIVATE_GLYPH, 0))
+	if (!dixRegisterPrivateKey(&glamor_glyph_key,
+		PRIVATE_GLYPH, sizeof(struct glamor_glyph)))
 		return FALSE;
 
 	/* Skip pixmap creation if we don't intend to use it. */
@@ -226,6 +389,7 @@ glamor_glyph_cache_upload_glyph(ScreenPtr screen,
 	PixmapPtr pGlyphPixmap = (PixmapPtr) pGlyphPicture->pDrawable;
 	PixmapPtr pCachePixmap = (PixmapPtr) cache->picture->pDrawable;
 	PixmapPtr scratch;
+	BoxRec box;
 	GCPtr gc;
 
 	gc = GetScratchGC(pCachePixmap->drawable.depth, screen);
@@ -236,54 +400,51 @@ glamor_glyph_cache_upload_glyph(ScreenPtr screen,
 
 	scratch = pGlyphPixmap;
 	if (pGlyphPixmap->drawable.depth != pCachePixmap->drawable.depth) {
+
 		scratch = glamor_create_pixmap(screen,
 					       glyph->info.width,
 					       glyph->info.height,
 					       pCachePixmap->
 					       drawable.depth, 0);
 		if (scratch) {
-			if (pGlyphPixmap->drawable.depth !=
-			    pCachePixmap->drawable.depth) {
-				PicturePtr picture;
-				int error;
-
-				picture =
-				    CreatePicture(0,
-						  &scratch->drawable,
-						  PictureMatchFormat
-						  (screen,
-						   pCachePixmap->
-						   drawable.depth,
-						   cache->picture->format),
-						  0, NULL, serverClient,
-						  &error);
-				if (picture) {
-					ValidatePicture(picture);
-					glamor_composite(PictOpSrc,
-						      pGlyphPicture,
-						      NULL, picture,
-						      0, 0, 0, 0, 0,
-						      0,
-						      glyph->info.width,
-						      glyph->info.height);
-					FreePicture(picture, 0);
-				}
-			} else {
-				glamor_copy_area(&pGlyphPixmap->drawable,
-						 &scratch->drawable,
-						 gc, 0, 0,
-						 glyph->info.width,
-						 glyph->info.height, 0, 0);
+			PicturePtr picture;
+			int error;
+
+			picture =
+			    CreatePicture(0,
+					  &scratch->drawable,
+					  PictureMatchFormat
+					  (screen,
+					   pCachePixmap->
+					   drawable.depth,
+					   cache->picture->format),
+					  0, NULL, serverClient,
+				  &error);
+			if (picture) {
+				ValidatePicture(picture);
+				glamor_composite(PictOpSrc,
+					      pGlyphPicture,
+					      NULL, picture,
+					      0, 0, 0, 0, 0,
+					      0,
+					      glyph->info.width,
+					      glyph->info.height);
+				FreePicture(picture, 0);
 			}
 		} else {
 			scratch = pGlyphPixmap;
 		}
 	}
 
-	(*gc->ops->CopyArea)(&scratch->drawable, &pCachePixmap->drawable, gc,
-			     0, 0, glyph->info.width, glyph->info.height, x,
-			     y);
-
+	box.x1 = x;
+	box.y1 = y;
+	box.x2 = x + glyph->info.width;
+	box.y2 = y + glyph->info.height;
+	glamor_copy_n_to_n_nf(&scratch->drawable,
+			    &pCachePixmap->drawable, NULL,
+			    &box, 1,
+			    -x, -y,
+			    FALSE, FALSE, 0, NULL);
 	if (scratch != pGlyphPixmap)
 		screen->DestroyPixmap(scratch);
 
@@ -297,14 +458,10 @@ glamor_glyph_unrealize(ScreenPtr screen, GlyphPtr glyph)
 	struct glamor_glyph *priv;
 
 	/* Use Lookup in case we have not attached to this glyph. */
-	priv = dixLookupPrivate(&glyph->devPrivates, &glamor_glyph_key);
-	if (priv == NULL)
-		return;
-
-	priv->cache->glyphs[priv->pos] = NULL;
+	priv = glamor_glyph_get_private(glyph);
 
-	glamor_glyph_set_private(glyph, NULL);
-	free(priv);
+	if (priv->cached)
+		priv->cache->glyphs[priv->pos] = NULL;
 }
 
 /* Cut and paste from render/glyph.c - probably should export it instead */
@@ -352,39 +509,279 @@ glamor_glyph_extents(int nlist,
 	extents->y2 = y2 > MAXSHORT ? MAXSHORT : y2;
 }
 
+static void
+glamor_glyph_priv_get_edge_map(GlyphPtr glyph, struct glamor_glyph *priv,
+			     PicturePtr glyph_picture)
+{
+	PixmapPtr glyph_pixmap = (PixmapPtr) glyph_picture->pDrawable;
+	struct glamor_pixmap_private *pixmap_priv;
+	int j;
+	unsigned long long left_x1_map, left_x2_map, right_x1_map, right_x2_map;
+	int bitsPerPixel;
+	int stride;
+	void *bits;
+	int width;
+	unsigned int left_x1_data, left_x2_data, right_x1_data, right_x2_data;
+
+	bitsPerPixel = glyph_pixmap->drawable.bitsPerPixel;
+	stride = glyph_pixmap->devKind;
+	bits = glyph_pixmap->devPrivate.ptr;
+	width = glyph->info.width;
+	pixmap_priv = glamor_get_pixmap_private(glyph_pixmap);
+
+	if (glyph_pixmap->drawable.width < 2
+	    || !(glyph_pixmap->drawable.depth == 8
+		|| glyph_pixmap->drawable.depth == 1
+		|| glyph_pixmap->drawable.depth == 32)) {
+		priv->has_edge_map = FALSE;
+		return;
+	}
+
+	left_x1_map = left_x2_map = 0;
+	right_x1_map = right_x2_map = 0;
+
+	for(j = 0; j < glyph_pixmap->drawable.height; j++)
+	{
+		if (bitsPerPixel == 8) {
+			unsigned char *data;
+			data =	(unsigned char*)((unsigned char*)bits + stride * j);
+			left_x1_data = *data++;
+			left_x2_data = *data;
+			data =	(unsigned char*)((unsigned char*)bits + stride * j + width - 2);
+			right_x1_data = *data++;
+			right_x2_data = *data;
+		} else if (bitsPerPixel == 32) {
+			left_x1_data = *((unsigned int*)bits + stride/4 * j);
+			left_x2_data = *((unsigned int*)bits + stride/4 * j + 1);
+			right_x1_data = *((unsigned int*)bits + stride/4 * j + width - 2);
+			right_x2_data = *((unsigned int*)bits + stride/4 * j + width - 1);
+		} else if (bitsPerPixel == 1) {
+			unsigned char temp;
+			temp = *((unsigned char*)glyph_pixmap->devPrivate.ptr
+				+ glyph_pixmap->devKind * j) & 0x3;
+			left_x1_data = temp & 0x1;
+			left_x2_data = temp & 0x2;
+
+			temp = *((unsigned char*)glyph_pixmap->devPrivate.ptr
+				+ glyph_pixmap->devKind * j
+				+ (glyph_pixmap->drawable.width - 2)/8);
+			right_x1_data = temp
+				    & (1 << ((glyph_pixmap->drawable.width - 2) % 8));
+			temp = *((unsigned char*)glyph_pixmap->devPrivate.ptr
+				+ glyph_pixmap->devKind * j
+				+ (glyph_pixmap->drawable.width - 1)/8);
+			right_x2_data = temp
+				   & (1 << ((glyph_pixmap->drawable.width - 1) % 8));
+		}
+		left_x1_map |= (left_x1_data !=0) << j;
+		left_x2_map |= (left_x2_data !=0) << j;
+		right_x1_map |= (right_x1_data !=0) << j;
+		right_x2_map |= (right_x2_data !=0) << j;
+	}
+
+	priv->left_x1_map = left_x1_map;
+	priv->left_x2_map = left_x2_map;
+	priv->right_x1_map = right_x1_map;
+	priv->right_x2_map = right_x2_map;
+	priv->has_edge_map = TRUE;
+	return;
+}
+
 /**
  * Returns TRUE if the glyphs in the lists intersect.  Only checks based on
  * bounding box, which appears to be good enough to catch most cases at least.
  */
+
+#define INTERSECTED_TYPE_MASK 1
+#define NON_INTERSECTED 0
+#define INTERSECTED 1
+
+struct glamor_glyph_list {
+	int nlist;
+	GlyphListPtr list;
+	GlyphPtr *glyphs;
+	int type;
+};
+
 static Bool
-glamor_glyphs_intersect(int nlist, GlyphListPtr list, GlyphPtr * glyphs)
+glyph_new_fixed_list(struct glamor_glyph_list *fixed_list,
+		     GlyphPtr *cur_glyphs,
+		     GlyphPtr **head_glyphs,
+		     GlyphListPtr cur_list,
+		     int cur_pos, int cur_x, int cur_y,
+		     int x1, int y1, int x2, int y2,
+		     GlyphListPtr *head_list,
+		     int *head_pos,
+		     int *head_x,
+		     int *head_y,
+		     int *fixed_cnt,
+		     int type,
+		     BoxPtr prev_extents
+		     )
+{
+	int x_off = 0;
+	int y_off = 0;
+	int n_off = 0;
+	int list_cnt;
+	if (type == NON_INTERSECTED) {
+		if (x1 < prev_extents->x2 && x2 > prev_extents->x1
+		    && y1 < prev_extents->y2 && y2 > prev_extents->y1)
+			return FALSE;
+		x_off = (*(cur_glyphs-1))->info.xOff;
+		y_off = (*(cur_glyphs-1))->info.yOff;
+		n_off = 1;
+	}
+
+	list_cnt = cur_list - *head_list + 1;
+	if (cur_pos <= n_off) {
+		DEBUGF("break at %d n_off %d\n", cur_pos, n_off);
+		list_cnt--;
+		if (cur_pos < n_off) {
+		/* we overlap with previous list's last glyph. */
+			x_off += cur_list->xOff;
+			y_off += cur_list->yOff;
+			cur_list--;
+			cur_pos = cur_list->len;
+			if (cur_pos <= n_off) {
+				list_cnt--;
+			}
+		}
+	}
+	DEBUGF("got %d lists\n", list_cnt);
+	if (list_cnt != 0) {
+		fixed_list->list = malloc(list_cnt * sizeof(*cur_list));
+		memcpy(fixed_list->list, *head_list, list_cnt * sizeof(*cur_list));
+		fixed_list->list[0].xOff = *head_x;
+		fixed_list->list[0].yOff = *head_y;
+		fixed_list->glyphs = *head_glyphs;
+		fixed_list->type = type & INTERSECTED_TYPE_MASK;
+		fixed_list->nlist = list_cnt;
+		if (cur_list != *head_list) {
+			fixed_list->list[0].len = (*head_list)->len - *head_pos;
+			if (cur_pos != n_off)
+			fixed_list->list[list_cnt - 1].len = cur_pos - n_off;
+		} else
+			fixed_list->list[0].len = cur_pos - *head_pos - n_off;
+		while(list_cnt--) {
+			DEBUGF("new fixed list type %d entry len %d x %d y %d"
+				"head_pos %d pos %d list %d has %d glyphs.\n",
+				fixed_list->type, fixed_list->nlist,
+				cur_x, cur_y, *head_pos, cur_pos, i, fixed_list->list[i++].len);
+		}
+		(*fixed_cnt)++;
+	}
+
+	if (type <= INTERSECTED) {
+		*head_list = cur_list;
+		*head_pos = cur_pos - n_off;
+		*head_x = cur_x - x_off;
+		*head_y = cur_y - y_off;
+		*head_glyphs = cur_glyphs - n_off;
+	}
+	return TRUE;
+}
+
+/*
+ * This function detects glyph lists's overlapping.
+ *
+ * If check_fake_overlap is set, then it will check the glyph's left
+ * and right small boxes's real overlapping pixels. And if there is
+ * no real pixel overlapping, then it will not be treated as overlapped
+ * case. And we also can configured it to ignore less than 2 pixels
+ * overlappig.
+ *
+ * This function analyzes all the lists and split the list to multiple
+ * lists which are pure overlapped glyph lists or pure non-overlapped
+ * list if the overlapping only ocurr on the two adjacent glyphs.
+ * Otherwise, it return -1.
+ *
+ **/
+
+static int
+glamor_glyphs_intersect(int nlist, GlyphListPtr list, GlyphPtr * glyphs,
+			PictFormatShort mask_format,
+			ScreenPtr screen, Bool check_fake_overlap,
+			struct glamor_glyph_list * fixed_list,
+			int fixed_size)
 {
 	int x1, x2, y1, y2;
 	int n;
 	int x, y;
-	BoxRec extents;
-	Bool first = TRUE;
+	BoxPtr extents;
+	BoxRec prev_extents;
+	Bool first = TRUE, first_list = TRUE;
+	Bool need_free_list_region = FALSE;
+	Bool need_free_fixed_list = FALSE;
+	struct glamor_glyph *priv;
+	Bool in_non_intersected_list = -1;
+	GlyphListPtr head_list, saved_list;
+	int head_x, head_y, head_pos;
+	int fixed_cnt = 0;
+	GlyphPtr *head_glyphs;
+	GlyphListPtr cur_list = list;
+	RegionRec list_region;
+	RegionRec current_region;
+	BoxRec current_box;
+
+	if (nlist > 1) {
+		pixman_region_init(&list_region);
+		need_free_list_region = TRUE;
+	}
 
+	pixman_region_init(&current_region);
+
+	extents = pixman_region_extents(&current_region);
+
+	saved_list = list;
 	x = 0;
 	y = 0;
-	extents.x1 = 0;
-	extents.y1 = 0;
-	extents.x2 = 0;
-	extents.y2 = 0;
+	extents->x1 = 0;
+	extents->y1 = 0;
+	extents->x2 = 0;
+	extents->y2 = 0;
+
+	head_list = list;
+	DEBUGF("has %d lists.\n", nlist);
 	while (nlist--) {
+		BoxRec left_box, right_box;
+		Bool has_left_edge_box = FALSE, has_right_edge_box = FALSE;
+		Bool left_to_right;
+		struct glamor_glyph *left_priv, *right_priv;
+
 		x += list->xOff;
 		y += list->yOff;
 		n = list->len;
-		list++;
+		left_to_right = TRUE;
+		cur_list = list++;
+
+		if (unlikely(!first_list)) {
+			pixman_region_init_with_extents(&current_region, extents);
+			pixman_region_union(&list_region, &list_region, &current_region);
+			first = TRUE;
+		} else {
+			head_list = cur_list;
+			head_pos = cur_list->len - n;
+			head_x = x;
+			head_y = y;
+			head_glyphs = glyphs;
+		}
+
+		DEBUGF("current list %p has %d glyphs\n", cur_list, n);
 		while (n--) {
 			GlyphPtr glyph = *glyphs++;
 
+			DEBUGF("the %dth glyph\n", cur_list->len - n - 1);
 			if (glyph->info.width == 0
 			    || glyph->info.height == 0) {
 				x += glyph->info.xOff;
 				y += glyph->info.yOff;
 				continue;
 			}
+			if (mask_format
+			    && mask_format != GlyphPicture(glyph)[screen->myNum]->format) {
+				need_free_fixed_list = TRUE;
+				goto done;
+			}
 
 			x1 = x - glyph->info.x;
 			if (x1 < MINSHORT)
@@ -392,43 +789,240 @@ glamor_glyphs_intersect(int nlist, GlyphListPtr list, GlyphPtr * glyphs)
 			y1 = y - glyph->info.y;
 			if (y1 < MINSHORT)
 				y1 = MINSHORT;
+			if (check_fake_overlap)
+				priv = glamor_glyph_get_private(glyph);
+
 			x2 = x1 + glyph->info.width;
+			y2 = y1 + glyph->info.height;
+
 			if (x2 > MAXSHORT)
 				x2 = MAXSHORT;
-			y2 = y1 + glyph->info.height;
 			if (y2 > MAXSHORT)
 				y2 = MAXSHORT;
 
 			if (first) {
-				extents.x1 = x1;
-				extents.y1 = y1;
-				extents.x2 = x2;
-				extents.y2 = y2;
+				extents->x1 = x1;
+				extents->y1 = y1;
+				extents->x2 = x2;
+				extents->y2 = y2;
+
+				prev_extents = *extents;
+
 				first = FALSE;
+				if (check_fake_overlap && priv
+				    && priv->has_edge_map && glyph->info.yOff == 0) {
+					left_box.x1 = x1;
+					left_box.x2 = x1 + 1;
+					left_box.y1 = y1;
+
+					right_box.x1 = x2 - 2;
+					right_box.x2 = x2 - 1;
+					right_box.y1 = y1;
+					left_priv = right_priv = priv;
+					has_left_edge_box = TRUE;
+					has_right_edge_box = TRUE;
+				}
 			} else {
-				if (x1 < extents.x2 && x2 > extents.x1
-				    && y1 < extents.y2
-				    && y2 > extents.y1) {
-					return TRUE;
+				if (unlikely(!first_list)) {
+					current_box.x1 = x1;
+					current_box.y1 = y1;
+					current_box.x2 = x2;
+					current_box.y2 = y2;
+					if (pixman_region_contains_rectangle(&list_region, &current_box) != PIXMAN_REGION_OUT) {
+						need_free_fixed_list = TRUE;
+						goto done;
+					}
 				}
 
-				if (x1 < extents.x1)
-					extents.x1 = x1;
-				if (x2 > extents.x2)
-					extents.x2 = x2;
-				if (y1 < extents.y1)
-					extents.y1 = y1;
-				if (y2 > extents.y2)
-					extents.y2 = y2;
+				if (x1 < extents->x2 && x2 > extents->x1
+				    && y1 < extents->y2
+				    && y2 > extents->y1) {
+
+					if (check_fake_overlap && (has_left_edge_box || has_right_edge_box)
+					    && priv->has_edge_map && glyph->info.yOff == 0) {
+						int left_dx, right_dx;
+						unsigned long long intersected;
+
+						left_dx = has_left_edge_box ? 1 : 0;
+						right_dx = has_right_edge_box ? 1 : 0;
+						if (x1 + 1 < extents->x2 - right_dx && x2 - 1 > extents->x1 + left_dx)
+							goto real_intersected;
+
+						if (left_to_right && has_right_edge_box) {
+							if (x1 == right_box.x1) {
+								intersected = ((priv->left_x1_map & right_priv->right_x1_map)
+										| (priv->left_x2_map & right_priv->right_x2_map));
+								if (intersected)
+									goto real_intersected;
+							} else if (x1 == right_box.x2) {
+								intersected = (priv->left_x1_map & right_priv->right_x2_map);
+								if (intersected) {
+								#ifdef  GLYPHS_EDEGE_OVERLAP_LOOSE_CHECK
+								/* tolerate with two pixels overlap. */
+									intersected &= ~(1<<__fls(intersected));
+									if ((intersected & (intersected - 1)))
+								#endif
+										goto real_intersected;
+								}
+							}
+						} else if (!left_to_right && has_left_edge_box) {
+							if (x2 - 1 == left_box.x1) {
+								intersected = (priv->right_x2_map & left_priv->left_x1_map);
+								if (intersected) {
+								#ifdef  GLYPHS_EDEGE_OVERLAP_LOOSE_CHECK
+								/* tolerate with two pixels overlap. */
+									intersected &= ~(1<<__fls(intersected));
+									if ((intersected & (intersected - 1)))
+								#endif
+										goto real_intersected;
+								}
+							} else if (x2 - 1 == right_box.x2) {
+								if ((priv->right_x1_map & left_priv->left_x1_map)
+								   || (priv->right_x2_map & left_priv->left_x2_map))
+									goto real_intersected;
+							}
+						} else {
+							if (x1 < extents->x2 && x1 + 2 > extents->x1)
+								goto real_intersected;
+						}
+						goto non_intersected;
+					} else {
+real_intersected:
+						DEBUGF("overlap with previous glyph.\n");
+						if (in_non_intersected_list == 1) {
+							if (fixed_cnt >= fixed_size) {
+								need_free_fixed_list = TRUE;
+								goto done;
+							}
+							if (!glyph_new_fixed_list(&fixed_list[fixed_cnt],
+									     glyphs - 1,
+									     &head_glyphs,
+									     cur_list,
+									     cur_list->len - (n + 1), x, y,
+									     x1, y1, x2, y2,
+									     &head_list,
+									     &head_pos,
+									     &head_x,
+									     &head_y, &fixed_cnt,
+									     NON_INTERSECTED,
+									     &prev_extents
+									     )){
+								need_free_fixed_list = TRUE;
+								goto done;
+							}
+						}
+
+						in_non_intersected_list = 0;
+
+					}
+				} else {
+non_intersected:
+					DEBUGF("doesn't overlap with previous glyph.\n");
+					if (in_non_intersected_list == 0) {
+						if (fixed_cnt >= fixed_size) {
+							need_free_fixed_list = TRUE;
+							goto done;
+						}
+						if (!glyph_new_fixed_list(&fixed_list[fixed_cnt],
+								     glyphs - 1,
+								     &head_glyphs,
+								     cur_list,
+								     cur_list->len - (n + 1), x, y,
+								     x1, y1, x2, y2,
+								     &head_list,
+								     &head_pos,
+								     &head_x,
+								     &head_y, &fixed_cnt,
+								     INTERSECTED,
+								     &prev_extents
+								     )) {
+							need_free_fixed_list = TRUE;
+							goto done;
+						}
+					}
+					in_non_intersected_list = 1;
+				}
+				prev_extents = *extents;
 			}
+
+			if (check_fake_overlap && priv
+			    && priv->has_edge_map && glyph->info.yOff == 0) {
+				if (!has_left_edge_box || x1 < extents->x1) {
+					left_box.x1 = x1;
+					left_box.x2 = x1 + 1;
+					left_box.y1 = y1;
+					has_left_edge_box = TRUE;
+					left_priv = priv;
+				}
+
+				if (!has_right_edge_box || x2 > extents->x2) {
+					right_box.x1 = x2 - 2;
+					right_box.x2 = x2 - 1;
+					right_box.y1 = y1;
+					has_right_edge_box = TRUE;
+					right_priv = priv;
+				}
+			}
+
+			if (x1 < extents->x1)
+				extents->x1 = x1;
+			if (x2 > extents->x2)
+				extents->x2 = x2;
+
+			if (y1 < extents->y1)
+				extents->y1 = y1;
+			if (y2 > extents->y2)
+				extents->y2 = y2;
+
 			x += glyph->info.xOff;
 			y += glyph->info.yOff;
 		}
+		first_list = FALSE;
 	}
 
-	return FALSE;
-}
+	if (in_non_intersected_list == 0 && fixed_cnt == 0) {
+		fixed_cnt = -1;
+		goto done;
+	}
+
+	if ((in_non_intersected_list != -1
+		|| head_pos != n) && (fixed_cnt > 0)) {
+		if (fixed_cnt >= fixed_size) {
+			need_free_fixed_list = TRUE;
+			goto done;
+		}
+		if (!glyph_new_fixed_list(&fixed_list[fixed_cnt],
+				     glyphs - 1,
+				     &head_glyphs,
+				     cur_list,
+				     cur_list->len - (n + 1), x, y,
+				     x1, y1, x2, y2,
+				     &head_list,
+				     &head_pos,
+				     &head_x,
+				     &head_y, &fixed_cnt,
+				     (!in_non_intersected_list) | 0x80,
+				     &prev_extents
+				     )) {
+			need_free_fixed_list = TRUE;
+			goto done;
+		}
+	}
+
+done:
+	if (need_free_list_region)
+		pixman_region_fini(&list_region);
+	pixman_region_fini(&current_region);
+
+	if (need_free_fixed_list && fixed_cnt >= 0) {
+		while(fixed_cnt--) {
+			free(fixed_list[fixed_cnt].list);
+		}
+	}
 
+	DEBUGF("Got %d fixed list \n", fixed_cnt);
+	return fixed_cnt;
+}
 
 static inline unsigned int
 glamor_glyph_size_to_count(int size)
@@ -451,15 +1045,15 @@ glamor_glyph_size_to_mask(int size)
 }
 
 static PicturePtr
-glamor_glyph_cache(ScreenPtr screen, GlyphPtr glyph, int *out_x,
+glamor_glyph_cache(glamor_screen_private *glamor, GlyphPtr glyph, int *out_x,
 		   int *out_y)
 {
-	glamor_screen_private *glamor = glamor_get_screen_private(screen);
+	ScreenPtr screen = glamor->screen;
 	PicturePtr glyph_picture = GlyphPicture(glyph)[screen->myNum];
 	glamor_glyph_cache_t *cache =
 	    &glamor->glyphCaches[PICT_FORMAT_RGB(glyph_picture->format) !=
 				 0];
-	struct glamor_glyph *priv = NULL;
+	struct glamor_glyph *priv = NULL, *evicted_priv = NULL;
 	int size, mask, pos, s;
 
 	if (glyph->info.width > GLYPH_MAX_SIZE
@@ -474,6 +1068,8 @@ glamor_glyph_cache(ScreenPtr screen, GlyphPtr glyph, int *out_x,
 	s = glamor_glyph_size_to_count(size);
 	mask = glamor_glyph_count_to_mask(s);
 	pos = (cache->count + s - 1) & mask;
+
+	priv = glamor_glyph_get_private(glyph);
 	if (pos < GLYPH_CACHE_SIZE) {
 		cache->count = pos + s;
 	} else {
@@ -484,46 +1080,41 @@ glamor_glyph_cache(ScreenPtr screen, GlyphPtr glyph, int *out_x,
 			if (evicted == NULL)
 				continue;
 
-			priv = glamor_glyph_get_private(evicted);
-			if (priv->size >= s) {
+			evicted_priv = glamor_glyph_get_private(evicted);
+			assert(evicted_priv->pos == i);
+			if (evicted_priv->size >= s) {
 				cache->glyphs[i] = NULL;
-				glamor_glyph_set_private(evicted, NULL);
+				evicted_priv->cached = FALSE;
 				pos = cache->evict &
 				    glamor_glyph_size_to_mask(size);
 			} else
-				priv = NULL;
+				evicted_priv = NULL;
 			break;
 		}
-		if (priv == NULL) {
+		if (evicted_priv == NULL) {
 			int count = glamor_glyph_size_to_count(size);
 			mask = glamor_glyph_count_to_mask(count);
 			pos = cache->evict & mask;
 			for (s = 0; s < count; s++) {
 				GlyphPtr evicted = cache->glyphs[pos + s];
 				if (evicted != NULL) {
-					if (priv != NULL)
-						free(priv);
 
-					priv =
+					evicted_priv =
 					    glamor_glyph_get_private
 					    (evicted);
-					glamor_glyph_set_private(evicted,
-								 NULL);
+
+					assert(evicted_priv->pos == pos + s);
+					evicted_priv->cached = FALSE;
 					cache->glyphs[pos + s] = NULL;
 				}
 			}
+
 		}
 		/* And pick a new eviction position */
 		cache->evict = rand() % GLYPH_CACHE_SIZE;
 	}
 
-	if (priv == NULL) {
-		priv = malloc(sizeof(struct glamor_glyph));
-		if (priv == NULL)
-			return NULL;
-	}
 
-	glamor_glyph_set_private(glyph, priv);
 	cache->glyphs[pos] = glyph;
 
 	priv->cache = cache;
@@ -545,90 +1136,238 @@ glamor_glyph_cache(ScreenPtr screen, GlyphPtr glyph, int *out_x,
 
 	glamor_glyph_cache_upload_glyph(screen, cache, glyph, priv->x,
 					priv->y);
+#ifndef GLYPHS_NO_EDEGEMAP_OVERLAP_CHECK
+	if (priv->has_edge_map == FALSE && glyph->info.width >= 2)
+		glamor_glyph_priv_get_edge_map(glyph, priv, glyph_picture);
+#endif
+	priv->cached = TRUE;
 
 	*out_x = priv->x;
 	*out_y = priv->y;
 	return cache->picture;
 }
+typedef void (*glyphs_flush)(void * arg);
+struct glyphs_flush_dst_arg {
+	CARD8 op;
+	PicturePtr src;
+	PicturePtr dst;
+	glamor_glyph_buffer_t * buffer;
+	int x_src,y_src;
+	int x_dst, y_dst;
+};
+
+static struct glyphs_flush_dst_arg dst_arg;
+static struct glyphs_flush_mask_arg mask_arg;
+static glamor_glyph_buffer_t dst_buffer;
+static glamor_glyph_buffer_t mask_buffer;
+unsigned long long mask_glyphs_cnt = 0;
+unsigned long long dst_glyphs_cnt = 0;
+#define GLYPHS_DST_MODE_VIA_MASK		0
+#define GLYPHS_DST_MODE_VIA_MASK_CACHE		1
+#define GLYPHS_DST_MODE_TO_DST			2
+#define GLYPHS_DST_MODE_MASK_TO_DST		3
+
+struct glyphs_flush_mask_arg {
+	PicturePtr mask;
+	glamor_glyph_buffer_t *buffer;
+	struct glamor_glyph_mask_cache *maskcache;
+	unsigned int used_bitmap;
+};
+
+static void
+glamor_glyphs_flush_mask(struct glyphs_flush_mask_arg *arg)
+{
+	if (arg->buffer->count>0) {
+#ifdef RENDER
+	glamor_composite_glyph_rects(PictOpAdd, arg->buffer->source,
+				     NULL, arg->mask,
+				     arg->buffer->count,
+				     arg->buffer->rects);
+#endif
+	}
+	arg->buffer->count = 0;
+	arg->buffer->source = NULL;
+
+}
+
+static void
+glamor_glyphs_flush_dst(struct glyphs_flush_dst_arg * arg)
+{
+	if (mask_buffer.count > 0) {
+		glamor_glyphs_flush_mask(&mask_arg);
+	}
+	if (mask_arg.used_bitmap) {
+		put_mask_cache_bitmap(mask_arg.maskcache, mask_arg.used_bitmap);
+		mask_arg.used_bitmap = 0;
+	}
+
+	if (arg->buffer->count > 0) {
+		glamor_composite_glyph_rects(arg->op, arg->src,
+					arg->buffer->source, arg->dst,
+					arg->buffer->count,
+					&arg->buffer->rects[0]);
+		arg->buffer->count = 0;
+		arg->buffer->source = NULL;
+	}
+}
+
 
 static glamor_glyph_cache_result_t
-glamor_buffer_glyph(ScreenPtr screen,
+glamor_buffer_glyph(glamor_screen_private *glamor_priv,
 		    glamor_glyph_buffer_t * buffer,
-		    GlyphPtr glyph, int x_glyph, int y_glyph)
+		    PictFormatShort format,
+		    GlyphPtr glyph, struct glamor_glyph *priv,
+		    int x_glyph, int y_glyph,
+		    int dx, int dy, int w, int h,
+		    int glyphs_dst_mode,
+		    glyphs_flush glyphs_flush, void *flush_arg)
 {
-	glamor_screen_private *glamor_screen =
-	    glamor_get_screen_private(screen);
-	unsigned int format = (GlyphPicture(glyph)[screen->myNum])->format;
+	ScreenPtr screen = glamor_priv->screen;
 	glamor_composite_rect_t *rect;
 	PicturePtr source;
-	struct glamor_glyph *priv;
 	int x, y;
-	PicturePtr glyph_picture = GlyphPicture(glyph)[screen->myNum];
 	glamor_glyph_cache_t *cache;
 
+	if (glyphs_dst_mode != GLYPHS_DST_MODE_MASK_TO_DST)
+		priv = glamor_glyph_get_private(glyph);
+
 	if (PICT_FORMAT_BPP(format) == 1)
 		format = PICT_a8;
 
 	cache =
-	    &glamor_screen->glyphCaches[PICT_FORMAT_RGB
-					(glyph_picture->format) != 0];
-
-	if (buffer->source && buffer->source != cache->picture)
-		return GLAMOR_GLYPH_NEED_FLUSH;
+	    &glamor_priv->glyphCaches[PICT_FORMAT_RGB(format) != 0];
 
-	if (buffer->count == GLYPH_BUFFER_SIZE)
-		return GLAMOR_GLYPH_NEED_FLUSH;
+	if (buffer->source
+	    && buffer->source != cache->picture
+	    && glyphs_flush) {
+		(*glyphs_flush)(flush_arg);
+		glyphs_flush = NULL;
+	}
 
-	priv = glamor_glyph_get_private(glyph);
+	if (buffer->count == GLYPH_BUFFER_SIZE
+	    && glyphs_flush) {
+		(*glyphs_flush)(flush_arg);
+		glyphs_flush = NULL;
+	}
 
-	if (priv) {
+	if (priv && priv->cached) {
 		rect = &buffer->rects[buffer->count++];
-		rect->x_src = priv->x;
-		rect->y_src = priv->y;
+		rect->x_src = priv->x + dx;
+		rect->y_src = priv->y + dy;
 		if (buffer->source == NULL)
 			buffer->source = priv->cache->picture;
+		if (glyphs_dst_mode <= GLYPHS_DST_MODE_VIA_MASK_CACHE)
+			assert(priv->cache->glyphs[priv->pos] == glyph);
 	} else {
-		source = glamor_glyph_cache(screen, glyph, &x, &y);
+		assert(glyphs_dst_mode != GLYPHS_DST_MODE_MASK_TO_DST);
+		if (glyphs_flush)
+			(*glyphs_flush)(flush_arg);
+		source = glamor_glyph_cache(glamor_priv, glyph, &x, &y);
+
 		if (source != NULL) {
 			rect = &buffer->rects[buffer->count++];
-			rect->x_src = x;
-			rect->y_src = y;
+			rect->x_src = x + dx;
+			rect->y_src = y + dy;
 			if (buffer->source == NULL)
 				buffer->source = source;
+			if (glyphs_dst_mode == GLYPHS_DST_MODE_VIA_MASK_CACHE) {
+				glamor_gl_dispatch *dispatch;
+				/* mode 1 means we are using global mask cache,
+				 * thus we have to composite from the cache picture
+				 * to the cache picture, we need a flush here to make
+				 * sure latter we get the corret glyphs data.*/
+				dispatch = glamor_get_dispatch(glamor_priv);
+				dispatch->glFlush();
+				glamor_put_dispatch(glamor_priv);
+			}
 		} else {
+	/* Couldn't find the glyph in the cache, use the glyph picture directly */
 			source = GlyphPicture(glyph)[screen->myNum];
-			if (buffer->source && buffer->source != source)
-				return GLAMOR_GLYPH_NEED_FLUSH;
+			if (buffer->source
+			    && buffer->source != source
+			    && glyphs_flush)
+				(*glyphs_flush)(flush_arg);
 			buffer->source = source;
 
 			rect = &buffer->rects[buffer->count++];
-			rect->x_src = 0;
-			rect->y_src = 0;
+			rect->x_src = 0 + dx;
+			rect->y_src = 0 + dy;
 		}
+		priv = glamor_glyph_get_private(glyph);
 	}
 
-	rect->x_dst = x_glyph - glyph->info.x;
-	rect->y_dst = y_glyph - glyph->info.y;
-	rect->width = glyph->info.width;
-	rect->height = glyph->info.height;
-
-	/* Couldn't find the glyph in the cache, use the glyph picture directly */
+	rect->x_dst = x_glyph;
+	rect->y_dst = y_glyph;
+	if (glyphs_dst_mode != GLYPHS_DST_MODE_MASK_TO_DST) {
+		rect->x_dst -= glyph->info.x;
+		rect->y_dst -= glyph->info.y;
+	}
+	rect->width = w;
+	rect->height = h;
+	if (glyphs_dst_mode > GLYPHS_DST_MODE_VIA_MASK_CACHE) {
+		rect->x_mask = rect->x_src;
+		rect->y_mask = rect->y_src;
+		rect->x_src = dst_arg.x_src + rect->x_dst - dst_arg.x_dst;
+		rect->y_src = dst_arg.y_src + rect->y_dst - dst_arg.y_dst;
+	}
 
 	return GLAMOR_GLYPH_SUCCESS;
 }
 
 
 static void
-glamor_glyphs_flush_mask(PicturePtr mask, glamor_glyph_buffer_t * buffer)
+glamor_buffer_glyph_clip(glamor_screen_private *glamor_priv,
+			 BoxPtr rects,
+			 int nrect, PictFormatShort format,
+			 GlyphPtr glyph, struct glamor_glyph *priv,
+			 int glyph_x, int glyph_y,
+			 int glyph_dx, int glyph_dy,
+			 int width, int height,
+			 int glyphs_mode,
+			 glyphs_flush flush_func,
+			 void *arg
+			 )
 {
-#ifdef RENDER
-	glamor_composite_glyph_rects(PictOpAdd, buffer->source, NULL, mask,
-				     buffer->count, buffer->rects);
-#endif
-	buffer->count = 0;
-	buffer->source = NULL;
+	int i;
+	for (i = 0; i < nrect; i++) {
+		int dst_x, dst_y;
+		int dx, dy;
+		int x2, y2;
+
+		dst_x = glyph_x - glyph_dx;
+		dst_y = glyph_y - glyph_dy;
+		x2 = dst_x + width;
+		y2 = dst_y + height;
+		dx = dy = 0;
+		if (rects[i].y1 >= y2)
+			break;
+
+		if (dst_x < rects[i].x1)
+			dx = rects[i].x1 - dst_x, dst_x = rects[i].x1;
+		if (x2 > rects[i].x2)
+			x2 = rects[i].x2;
+		if (dst_y < rects[i].y1)
+			dy = rects[i].y1 - dst_y, dst_y = rects[i].y1;
+		if (y2 > rects[i].y2)
+			y2 = rects[i].y2;
+		if (dst_x < x2 && dst_y < y2) {
+
+			glamor_buffer_glyph(glamor_priv,
+					    &dst_buffer,
+					    format,
+					    glyph, priv,
+					    dst_x + glyph_dx,
+					    dst_y + glyph_dy,
+					    dx, dy,
+					    x2 - dst_x, y2 - dst_y,
+			    		    glyphs_mode,
+					    flush_func,
+					    arg);
+		}
+	}
 }
 
+
 static void
 glamor_glyphs_via_mask(CARD8 op,
 		       PicturePtr src,
@@ -636,7 +1375,8 @@ glamor_glyphs_via_mask(CARD8 op,
 		       PictFormatPtr mask_format,
 		       INT16 x_src,
 		       INT16 y_src,
-		       int nlist, GlyphListPtr list, GlyphPtr * glyphs)
+		       int nlist, GlyphListPtr list, GlyphPtr * glyphs,
+		       Bool use_mask_cache)
 {
 	PixmapPtr mask_pixmap = 0;
 	PicturePtr mask;
@@ -649,15 +1389,22 @@ glamor_glyphs_via_mask(CARD8 op,
 	int error;
 	BoxRec extents = { 0, 0, 0, 0 };
 	XID component_alpha;
+	glamor_screen_private *glamor_priv;
+	int need_free_mask = FALSE;
 	glamor_glyph_buffer_t buffer;
-	xRectangle fill_rect;
-
-	GCPtr gc;
+	struct glyphs_flush_mask_arg arg;
+	glamor_glyph_buffer_t *pmask_buffer;
+	struct glyphs_flush_mask_arg *pmask_arg;
+	struct glamor_glyph_mask_cache_entry *mce = NULL;
+	struct glamor_glyph_mask_cache *maskcache;
+	glamor_glyph_cache_t *cache;
+	int glyphs_dst_mode;
 
 	glamor_glyph_extents(nlist, list, glyphs, &extents);
 
 	if (extents.x2 <= extents.x1 || extents.y2 <= extents.y1)
 		return;
+	glamor_priv = glamor_get_screen_private(screen);
 	width = extents.x2 - extents.x1;
 	height = extents.y2 - extents.y1;
 
@@ -669,97 +1416,173 @@ glamor_glyphs_via_mask(CARD8 op,
 			mask_format = a8Format;
 	}
 
-	mask_pixmap = screen->CreatePixmap(screen, width, height,
-					   mask_format->depth,
-					   CREATE_PIXMAP_USAGE_SCRATCH);
-	if (!mask_pixmap)
-		return;
-	component_alpha = NeedsComponent(mask_format->format);
-	mask = CreatePicture(0, &mask_pixmap->drawable,
-			     mask_format, CPComponentAlpha,
-			     &component_alpha, serverClient, &error);
-	if (!mask) {
-		screen->DestroyPixmap(mask_pixmap);
-		return;
-	}
-	gc = GetScratchGC(mask_pixmap->drawable.depth, screen);
-	ValidateGC(&mask_pixmap->drawable, gc);
-	gc->fillStyle = FillSolid;
-	//glamor_fill(&mask_pixmap->drawable, gc, 0, 0, width, height, TRUE);
-	fill_rect.x = 0;
-	fill_rect.y = 0;
-	fill_rect.width = width;
-	fill_rect.height = height;
-	gc->ops->PolyFillRect(&mask_pixmap->drawable, gc, 1, &fill_rect);
-	
-	FreeScratchGC(gc);
+	cache = &glamor_priv->glyphCaches
+			[PICT_FORMAT_RGB(mask_format->format) != 0];
+	maskcache = mask_cache[PICT_FORMAT_RGB(mask_format->format) != 0];
+
 	x = -extents.x1;
 	y = -extents.y1;
+	if (!use_mask_cache
+	    || width > (CACHE_PICTURE_SIZE/4)
+	    || height > MASK_CACHE_MAX_SIZE) {
+new_mask_pixmap:
+		mask_pixmap = glamor_create_pixmap(screen, width, height,
+						   mask_format->depth,
+						   CREATE_PIXMAP_USAGE_SCRATCH);
+		if (!mask_pixmap) {
+			glamor_destroy_pixmap(mask_pixmap);
+			return;
+		}
+		glamor_solid(mask_pixmap, 0, 0, width, height, GXcopy, 0xFFFFFFFF, 0);
+		component_alpha = NeedsComponent(mask_format->format);
+		mask = CreatePicture(0, &mask_pixmap->drawable,
+				     mask_format, CPComponentAlpha,
+				     &component_alpha, serverClient, &error);
+		if (!mask)
+			return;
+		need_free_mask = TRUE;
+		pmask_arg = &arg;
+		pmask_buffer = &buffer;
+		pmask_buffer->count = 0;
+		pmask_buffer->source = NULL;
+		pmask_arg->used_bitmap = 0;
+		glyphs_dst_mode = GLYPHS_DST_MODE_VIA_MASK;
+	} else {
+		int retry_cnt = 0;
+retry:
+	   	mce = get_mask_cache(maskcache,
+				     (width + MASK_CACHE_MAX_SIZE - 1) / MASK_CACHE_MAX_SIZE);
+
+		if (mce == NULL) {
+			glamor_glyphs_flush_dst(&dst_arg);
+			retry_cnt++;
+			if (retry_cnt > 2) {
+				assert(0);
+				goto new_mask_pixmap;
+			}
+			goto retry;
+		}
 
-	buffer.count = 0;
-	buffer.source = NULL;
+		mask = cache->picture;
+		x += mce->x;
+		y += mce->y;
+		mce->width = (width + MASK_CACHE_MAX_SIZE - 1) / MASK_CACHE_MAX_SIZE;
+		mce->height = 1;
+		if (mask_arg.mask && mask_arg.mask != mask
+			&& mask_buffer.count != 0)
+			glamor_glyphs_flush_dst(&dst_arg);
+		pmask_arg = &mask_arg;
+		pmask_buffer = &mask_buffer;
+		pmask_arg->maskcache = maskcache;
+		glyphs_dst_mode = GLYPHS_DST_MODE_VIA_MASK_CACHE;
+	}
+	pmask_arg->mask = mask;
+	pmask_arg->buffer = pmask_buffer;
 	while (nlist--) {
 		x += list->xOff;
 		y += list->yOff;
 		n = list->len;
+		mask_glyphs_cnt += n;
 		while (n--) {
 			glyph = *glyphs++;
-
 			if (glyph->info.width > 0
-			    && glyph->info.height > 0
-			    && glamor_buffer_glyph(screen, &buffer,
-						   glyph, x,
-						   y) ==
-			    GLAMOR_GLYPH_NEED_FLUSH) {
-
-				glamor_glyphs_flush_mask(mask, &buffer);
-
-				glamor_buffer_glyph(screen, &buffer,
-						    glyph, x, y);
+			    && glyph->info.height > 0) {
+				glyphs_flush flush_func;
+				void *arg;
+				if (need_free_mask) {
+					if (pmask_buffer->count)
+						flush_func = (glyphs_flush)glamor_glyphs_flush_mask;
+					else
+						flush_func = NULL;
+					arg = pmask_arg;
+				} else {
+					/* If we are using global mask cache, then we need to
+					 * flush dst instead of mask. As some dst depends on the
+					 * previous mask result. Just flush mask can't get all previous's
+					 * overlapped glyphs.*/
+					if (dst_buffer.count || mask_buffer.count)
+						flush_func = (glyphs_flush)glamor_glyphs_flush_dst;
+					else
+						flush_func = NULL;
+					arg = &dst_arg;
+				}
+				glamor_buffer_glyph(glamor_priv, pmask_buffer,
+						    mask_format->format,
+						    glyph, NULL, x, y,
+						    0, 0,
+						    glyph->info.width, glyph->info.height,
+						    glyphs_dst_mode,
+						    flush_func,
+						    (void*)arg);
 			}
-
 			x += glyph->info.xOff;
 			y += glyph->info.yOff;
 		}
 		list++;
 	}
 
-	if (buffer.count)
-		glamor_glyphs_flush_mask(mask, &buffer);
-
 	x = extents.x1;
 	y = extents.y1;
-	CompositePicture(op,
-			 src,
-			 mask,
-			 dst,
-			 x_src + x - x_dst,
-			 y_src + y - y_dst, 0, 0, x, y, width, height);
-	FreePicture(mask, 0);
-	screen->DestroyPixmap(mask_pixmap);
-}
+	if (need_free_mask) {
+		glamor_glyphs_flush_mask(pmask_arg);
+		CompositePicture(op,
+				 src,
+				 mask,
+				 dst,
+				 x_src + x - x_dst,
+				 y_src + y - y_dst, 0, 0, x, y, width, height);
+		FreePicture(mask, 0);
+		glamor_destroy_pixmap(mask_pixmap);
+	} else {
+		struct glamor_glyph priv;
+		glyphs_flush flush_func;
+		BoxPtr rects;
+		int nrect;
+
+		priv.cache = cache;
+		priv.x = mce->x;
+		priv.y = mce->y;
+		priv.cached = TRUE;
+		rects = REGION_RECTS(dst->pCompositeClip);
+		nrect = REGION_NUM_RECTS(dst->pCompositeClip);
+
+		pmask_arg->used_bitmap |= ((1 << mce->width) - 1) << mce->idx;
+		dst_arg.op = op;
+		dst_arg.src = src;
+		dst_arg.dst = dst;
+		dst_arg.buffer = &dst_buffer;
+		dst_arg.x_src = x_src;
+		dst_arg.y_src = y_src;
+		dst_arg.x_dst = x_dst;
+		dst_arg.y_dst = y_dst;
+
+		if (dst_buffer.source == NULL) {
+			dst_buffer.source = cache->picture;
+		} else if (dst_buffer.source != cache->picture) {
+			glamor_glyphs_flush_dst(&dst_arg);
+			dst_buffer.source = cache->picture;
+		}
 
-static void
-glamor_glyphs_flush_dst(CARD8 op,
-			PicturePtr src,
-			PicturePtr dst,
-			glamor_glyph_buffer_t * buffer,
-			INT16 x_src, INT16 y_src, INT16 x_dst, INT16 y_dst)
-{
-	int i;
-	glamor_composite_rect_t *rect = &buffer->rects[0];
-	for (i = 0; i < buffer->count; i++, rect++) {
-		rect->x_mask = rect->x_src;
-		rect->y_mask = rect->y_src;
-		rect->x_src = x_src + rect->x_dst - x_dst;
-		rect->y_src = y_src + rect->y_dst - y_dst;
+		x += dst->pDrawable->x;
+		y += dst->pDrawable->y;
+
+		if (dst_buffer.count || mask_buffer.count)
+			flush_func = (glyphs_flush)glamor_glyphs_flush_dst;
+		else
+			flush_func = NULL;
+
+		glamor_buffer_glyph_clip(glamor_priv,
+					 rects, nrect,
+					 mask_format->format,
+					 NULL, &priv,
+					 x, y,
+					 0, 0,
+					 width, height,
+					 GLYPHS_DST_MODE_MASK_TO_DST,
+					 flush_func,
+					 (void *)&dst_arg
+					 );
 	}
-
-	glamor_composite_glyph_rects(op, src, buffer->source, dst,
-			       buffer->count, &buffer->rects[0]);
-
-	buffer->count = 0;
-	buffer->source = NULL;
 }
 
 static void
@@ -768,36 +1591,62 @@ glamor_glyphs_to_dst(CARD8 op,
 		     PicturePtr dst,
 		     INT16 x_src,
 		     INT16 y_src,
-		     int nlist, GlyphListPtr list, GlyphPtr * glyphs)
+		     int nlist, GlyphListPtr list,
+		     GlyphPtr * glyphs)
 {
 	ScreenPtr screen = dst->pDrawable->pScreen;
 	int x = 0, y = 0;
 	int x_dst = list->xOff, y_dst = list->yOff;
 	int n;
 	GlyphPtr glyph;
-	glamor_glyph_buffer_t buffer;
+	BoxPtr rects;
+	int nrect;
+	glamor_screen_private *glamor_priv;
+
+	rects = REGION_RECTS(dst->pCompositeClip);
+	nrect = REGION_NUM_RECTS(dst->pCompositeClip);
+
+	glamor_priv = glamor_get_screen_private(screen);
+
+	dst_arg.op = op;
+	dst_arg.src = src;
+	dst_arg.dst = dst;
+	dst_arg.buffer = &dst_buffer;
+	dst_arg.x_src = x_src;
+	dst_arg.y_src = y_src;
+	dst_arg.x_dst = x_dst;
+	dst_arg.y_dst = y_dst;
+
+	x = dst->pDrawable->x;
+	y = dst->pDrawable->y;
 
-	buffer.count = 0;
-	buffer.source = NULL;
 	while (nlist--) {
 		x += list->xOff;
 		y += list->yOff;
 		n = list->len;
+		dst_glyphs_cnt += n;
 		while (n--) {
 			glyph = *glyphs++;
 
 			if (glyph->info.width > 0
-			    && glyph->info.height > 0
-			    && glamor_buffer_glyph(screen, &buffer,
-						   glyph, x,
-						   y) ==
-			    GLAMOR_GLYPH_NEED_FLUSH) {
-				glamor_glyphs_flush_dst(op, src, dst,
-							&buffer, x_src,
-							y_src, x_dst,
-							y_dst);
-				glamor_buffer_glyph(screen, &buffer,
-						    glyph, x, y);
+			    && glyph->info.height > 0) {
+				glyphs_flush flush_func;
+
+				if (dst_buffer.count || mask_buffer.count)
+					flush_func = (glyphs_flush)glamor_glyphs_flush_dst;
+				else
+					flush_func = NULL;
+				glamor_buffer_glyph_clip(glamor_priv,
+							 rects, nrect,
+							 (GlyphPicture(glyph)[screen->myNum])->format,
+							 glyph, NULL,
+							 x, y,
+							 glyph->info.x, glyph->info.y,
+							 glyph->info.width, glyph->info.height,
+							 GLYPHS_DST_MODE_TO_DST,
+							 flush_func,
+							 (void *)&dst_arg
+							 );
 			}
 
 			x += glyph->info.xOff;
@@ -805,10 +1654,13 @@ glamor_glyphs_to_dst(CARD8 op,
 		}
 		list++;
 	}
-
-	if (buffer.count)
-		glamor_glyphs_flush_dst(op, src, dst, &buffer,
-					x_src, y_src, x_dst, y_dst);
+}
+#define MAX_FIXED_SIZE
+static void
+glamor_glyphs_reset_buffer(glamor_glyph_buffer_t *buffer)
+{
+	buffer->count = 0;
+	buffer->source = NULL;
 }
 
 static Bool
@@ -817,39 +1669,115 @@ _glamor_glyphs(CARD8 op,
 	       PicturePtr dst,
 	       PictFormatPtr mask_format,
 	       INT16 x_src,
-	       INT16 y_src, int nlist, GlyphListPtr list, 
+	       INT16 y_src, int nlist, GlyphListPtr list,
 	       GlyphPtr * glyphs, Bool fallback)
 {
-	/* If we don't have a mask format but all the glyphs have the same format
-	 * and don't intersect, use the glyph format as mask format for the full
-	 * benefits of the glyph cache.
-	 */
-	if (!mask_format) {
-		Bool same_format = TRUE;
-		int i;
-
-		mask_format = list[0].format;
-
-		for (i = 0; i < nlist; i++) {
-			if (mask_format->format != list[i].format->format) {
-				same_format = FALSE;
-				break;
-			}
-		}
-
-		if (!same_format || (mask_format->depth != 1 &&
-				     glamor_glyphs_intersect(nlist, list,
-							     glyphs))) {
-			mask_format = NULL;
-		}
+	PictFormatShort format;
+	int fixed_size, fixed_cnt = 0;
+	struct glamor_glyph_list *fixed_list = NULL;
+	Bool need_free_list = FALSE;
+#ifndef GLYPHS_NO_EDEGEMAP_OVERLAP_CHECK
+	Bool check_fake_overlap = TRUE;
+	if (!(op == PictOpOver
+	    || op == PictOpAdd
+	    || op == PictOpXor)) {
+	/* C = (0,0,0,0) D = glyphs , SRC = A, DEST = B (faked overlapped glyphs, overlapped with (0,0,0,0)).
+	 * For those op, (A IN (C ADD D)) OP B !=  (A IN D) OP ((A IN C) OP B)
+	 *		or (A IN (D ADD C)) OP B != (A IN C) OP ((A IN D) OP B)
+	 * We need to split the faked regions to three or two, and composite the disoverlapped small
+	 * boxes one by one. For other Ops, it's safe to composite the whole box.  */
+		check_fake_overlap = FALSE;
 	}
-
+#else
+	Bool check_fake_overlap = FALSE;
+#endif
 	if (mask_format)
-		glamor_glyphs_via_mask(op, src, dst, mask_format,
-				       x_src, y_src, nlist, list, glyphs);
+		format = mask_format->depth << 24 | mask_format->format;
 	else
+		format = 0;
+
+	fixed_size = 32;
+	glamor_glyphs_reset_buffer(&dst_buffer);
+
+	if (!mask_format || (((nlist == 1 && list->len == 1) || op == PictOpAdd)
+	    && (dst->format == ((mask_format->depth << 24) | mask_format->format)))) {
 		glamor_glyphs_to_dst(op, src, dst, x_src, y_src, nlist,
 				     list, glyphs);
+		goto last_flush;
+	}
+
+	glamor_glyphs_reset_buffer(&mask_buffer);
+
+	/* We have mask_format. Need to check the real overlap or not.*/
+	format = mask_format->depth << 24 | mask_format->format;
+
+	fixed_list = calloc(fixed_size, sizeof(*fixed_list));
+	if (unlikely(fixed_list == NULL))
+		fixed_size = 0;
+	fixed_cnt = glamor_glyphs_intersect(nlist, list, glyphs,
+				format, dst->pDrawable->pScreen,
+				check_fake_overlap,
+				fixed_list, fixed_size);
+	if (fixed_cnt == 0)
+		mask_format = NULL;
+	need_free_list = TRUE;
+
+	if (fixed_cnt <= 0) {
+		if (mask_format == NULL) {
+			glamor_glyphs_to_dst(op, src, dst, x_src, y_src, nlist,
+					     list, glyphs);
+			goto last_flush;
+		} else {
+			glamor_glyphs_via_mask(op, src, dst, mask_format,
+					       x_src, y_src, nlist, list, glyphs,
+					       FALSE);
+			goto free_fixed_list;
+		}
+	} else {
+
+		/* We have splitted the original list to serval list, some are overlapped
+		 * and some are non-overlapped. For the non-overlapped, we render it to
+		 * dst directly. For the overlapped, we render it to mask picture firstly,
+		 * then render the mask to dst. If we can use mask cache which is in the
+		 * glyphs cache's last row, we can accumulate the rendering of mask to dst
+		 * with the other dst_buffer's rendering operations thus can reduce the call
+		 * of glDrawElements.
+		 *
+		 * */
+		struct glamor_glyph_list *saved_list;
+
+		saved_list = fixed_list;
+		mask_arg.used_bitmap = 0;
+		while(fixed_cnt--) {
+			if (fixed_list->type == NON_INTERSECTED) {
+				glamor_glyphs_to_dst(op, src, dst,
+						     x_src, y_src,
+						     fixed_list->nlist,
+						     fixed_list->list,
+						     fixed_list->glyphs);
+			}
+			else
+				glamor_glyphs_via_mask(op, src, dst,
+						       mask_format, x_src, y_src,
+						       fixed_list->nlist,
+						       fixed_list->list,
+						       fixed_list->glyphs, TRUE);
+
+			free(fixed_list->list);
+			fixed_list++;
+		}
+		free(saved_list);
+		need_free_list = FALSE;
+	}
+
+last_flush:
+	if (dst_buffer.count || mask_buffer.count)
+		glamor_glyphs_flush_dst(&dst_arg);
+free_fixed_list:
+	if(need_free_list) {
+		assert(fixed_cnt <= 0);
+		free(fixed_list);
+	}
 	return TRUE;
 }
 
@@ -861,7 +1789,7 @@ glamor_glyphs(CARD8 op,
 	      INT16 x_src,
 	      INT16 y_src, int nlist, GlyphListPtr list, GlyphPtr * glyphs)
 {
-	_glamor_glyphs(op, src, dst, mask_format, x_src, 
+	_glamor_glyphs(op, src, dst, mask_format, x_src,
 		       y_src, nlist, list, glyphs, TRUE);
 }
 
@@ -871,10 +1799,10 @@ glamor_glyphs_nf(CARD8 op,
 		 PicturePtr dst,
 		 PictFormatPtr mask_format,
 		 INT16 x_src,
-		 INT16 y_src, int nlist, 
+		 INT16 y_src, int nlist,
 		 GlyphListPtr list, GlyphPtr * glyphs)
 {
-	return _glamor_glyphs(op, src, dst, mask_format, x_src, 
+	return _glamor_glyphs(op, src, dst, mask_format, x_src,
 			      y_src, nlist, list, glyphs, FALSE);
 }
 
diff --git a/glamor_gradient.c b/glamor_gradient.c
new file mode 100644
index 0000000..444ba6c
--- /dev/null
+++ b/glamor_gradient.c
@@ -0,0 +1,1585 @@
+/*
+ * Copyright  2009 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Junyan He <junyan.he@linux.intel.com>
+ *
+ */
+
+/** @file glamor_gradient.c
+ *
+ * Gradient acceleration implementation
+ */
+
+#include "glamor_priv.h"
+
+#ifdef RENDER
+
+#define LINEAR_SMALL_STOPS (6 + 2)
+#define LINEAR_LARGE_STOPS (16 + 2)
+
+#define RADIAL_SMALL_STOPS (6 + 2)
+#define RADIAL_LARGE_STOPS (16 + 2)
+
+#ifdef GLAMOR_GRADIENT_SHADER
+
+static GLint
+_glamor_create_getcolor_fs_program(ScreenPtr screen, int stops_count, int use_array)
+{
+	glamor_screen_private *glamor_priv;
+	glamor_gl_dispatch *dispatch;
+
+	char *gradient_fs = NULL;
+	GLint fs_getcolor_prog;
+
+	const char *gradient_fs_getcolor =
+	    GLAMOR_DEFAULT_PRECISION
+	    "uniform int n_stop;\n"
+	    "uniform float stops[%d];\n"
+	    "uniform vec4 stop_colors[%d];\n"
+	    "vec4 get_color(float stop_len)\n"
+	    "{\n"
+	    "    int i = 0;\n"
+	    "    float new_alpha; \n"
+	    "    vec4 gradient_color;\n"
+	    "    float percentage; \n"
+	    "    for(i = 0; i < n_stop - 1; i++) {\n"
+	    "        if(stop_len < stops[i])\n"
+	    "            break; \n"
+	    "    }\n"
+	    "    \n"
+	    "    if(stops[i] - stops[i-1] > 2.0)\n"
+	    "        percentage = 0.0;\n" //For comply with pixman, walker->stepper overflow.
+	    "    else if(stops[i] - stops[i-1] < 0.000001)\n"
+	    "        percentage = 0.0;\n"
+	    "    else \n"
+	    "        percentage = (stop_len - stops[i-1])/(stops[i] - stops[i-1]);\n"
+	    "    new_alpha = percentage * stop_colors[i].a + \n"
+	    "                       (1.0-percentage) * stop_colors[i-1].a; \n"
+	    "    gradient_color = vec4((percentage * stop_colors[i].rgb \n"
+	    "                          + (1.0-percentage) * stop_colors[i-1].rgb)*new_alpha, \n"
+	    "                          new_alpha);\n"
+	    "    \n"
+	    "    return gradient_color;\n"
+	    "}\n";
+
+	/* Because the array access for shader is very slow, the performance is very low
+	   if use array. So use global uniform to replace for it if the number of n_stops is small.*/
+	const char *gradient_fs_getcolor_no_array =
+	    GLAMOR_DEFAULT_PRECISION
+	    "uniform int n_stop;\n"
+	    "uniform float stop0;\n"
+	    "uniform float stop1;\n"
+	    "uniform float stop2;\n"
+	    "uniform float stop3;\n"
+	    "uniform float stop4;\n"
+	    "uniform float stop5;\n"
+	    "uniform float stop6;\n"
+	    "uniform float stop7;\n"
+	    "uniform vec4 stop_color0;\n"
+	    "uniform vec4 stop_color1;\n"
+	    "uniform vec4 stop_color2;\n"
+	    "uniform vec4 stop_color3;\n"
+	    "uniform vec4 stop_color4;\n"
+	    "uniform vec4 stop_color5;\n"
+	    "uniform vec4 stop_color6;\n"
+	    "uniform vec4 stop_color7;\n"
+	    "\n"
+	    "vec4 get_color(float stop_len)\n"
+	    "{\n"
+	    "    float stop_after;\n"
+	    "    float stop_before;\n"
+	    "    vec4 stop_color_before;\n"
+	    "    vec4 stop_color_after;\n"
+	    "    float new_alpha; \n"
+	    "    vec4 gradient_color;\n"
+	    "    float percentage; \n"
+	    "    \n"
+	    "    if((stop_len < stop0) && (n_stop >= 1)) {\n"
+	    "        stop_color_before = stop_color0;\n"
+	    "        stop_color_after = stop_color0;\n"
+	    "        stop_after = stop0;\n"
+	    "        stop_before = stop0;\n"
+	    "    } else if((stop_len < stop1) && (n_stop >= 2)) {\n"
+	    "        stop_color_before = stop_color0;\n"
+	    "        stop_color_after = stop_color1;\n"
+	    "        stop_after = stop1;\n"
+	    "        stop_before = stop0;\n"
+	    "    } else if((stop_len < stop2) && (n_stop >= 3)) {\n"
+	    "        stop_color_before = stop_color1;\n"
+	    "        stop_color_after = stop_color2;\n"
+	    "        stop_after = stop2;\n"
+	    "        stop_before = stop1;\n"
+	    "    } else if((stop_len < stop3) && (n_stop >= 4)){\n"
+	    "        stop_color_before = stop_color2;\n"
+	    "        stop_color_after = stop_color3;\n"
+	    "        stop_after = stop3;\n"
+	    "        stop_before = stop2;\n"
+	    "    } else if((stop_len < stop4) && (n_stop >= 5)){\n"
+	    "        stop_color_before = stop_color3;\n"
+	    "        stop_color_after = stop_color4;\n"
+	    "        stop_after = stop4;\n"
+	    "        stop_before = stop3;\n"
+	    "    } else if((stop_len < stop5) && (n_stop >= 6)){\n"
+	    "        stop_color_before = stop_color4;\n"
+	    "        stop_color_after = stop_color5;\n"
+	    "        stop_after = stop5;\n"
+	    "        stop_before = stop4;\n"
+	    "    } else if((stop_len < stop6) && (n_stop >= 7)){\n"
+	    "        stop_color_before = stop_color5;\n"
+	    "        stop_color_after = stop_color6;\n"
+	    "        stop_after = stop6;\n"
+	    "        stop_before = stop5;\n"
+	    "    } else if((stop_len < stop7) && (n_stop >= 8)){\n"
+	    "        stop_color_before = stop_color6;\n"
+	    "        stop_color_after = stop_color7;\n"
+	    "        stop_after = stop7;\n"
+	    "        stop_before = stop6;\n"
+	    "    } else {\n"
+	    "        stop_color_before = stop_color7;\n"
+	    "        stop_color_after = stop_color7;\n"
+	    "        stop_after = stop7;\n"
+	    "        stop_before = stop7;\n"
+	    "    }\n"
+	    "    if(stop_after - stop_before > 2.0)\n"
+	    "        percentage = 0.0;\n"//For comply with pixman, walker->stepper overflow.
+	    "    else if(stop_after - stop_before < 0.000001)\n"
+	    "        percentage = 0.0;\n"
+	    "    else \n"
+	    "        percentage = (stop_len - stop_before)/(stop_after - stop_before);\n"
+	    "    new_alpha = percentage * stop_color_after.a + \n"
+	    "                       (1.0-percentage) * stop_color_before.a; \n"
+	    "    gradient_color = vec4((percentage * stop_color_after.rgb \n"
+	    "                          + (1.0-percentage) * stop_color_before.rgb)*new_alpha, \n"
+	    "                          new_alpha);\n"
+	    "    \n"
+	    "    return gradient_color;\n"
+	    "}\n";
+
+	glamor_priv = glamor_get_screen_private(screen);
+	dispatch = glamor_get_dispatch(glamor_priv);
+
+	if(use_array) {
+		XNFasprintf(&gradient_fs,
+		    gradient_fs_getcolor, stops_count, stops_count);
+		fs_getcolor_prog = glamor_compile_glsl_prog(dispatch, GL_FRAGMENT_SHADER,
+		                                            gradient_fs);
+		free(gradient_fs);
+	} else {
+		fs_getcolor_prog = glamor_compile_glsl_prog(dispatch, GL_FRAGMENT_SHADER,
+		                                            gradient_fs_getcolor_no_array);
+	}
+
+	return fs_getcolor_prog;
+}
+
+static void
+_glamor_create_radial_gradient_program(ScreenPtr screen, int stops_count, int dyn_gen)
+{
+	glamor_screen_private *glamor_priv;
+	glamor_gl_dispatch *dispatch;
+	int index;
+
+	GLint gradient_prog = 0;
+	char *gradient_fs = NULL;
+	GLint fs_main_prog, fs_getcolor_prog, vs_prog;
+
+	const char *gradient_vs =
+	    GLAMOR_DEFAULT_PRECISION
+	    "attribute vec4 v_position;\n"
+	    "attribute vec4 v_texcoord;\n"
+	    "varying vec2 source_texture;\n"
+	    "\n"
+	    "void main()\n"
+	    "{\n"
+	    "    gl_Position = v_position;\n"
+	    "    source_texture = v_texcoord.xy;\n"
+	    "}\n";
+
+	/*
+	 *     Refer to pixman radial gradient.
+	 *
+	 *     The problem is given the two circles of c1 and c2 with the radius of r1 and
+	 *     r1, we need to caculate the t, which is used to do interpolate with stops,
+	 *     using the fomula:
+	 *     length((1-t)*c1 + t*c2 - p) = (1-t)*r1 + t*r2
+	 *     expand the fomula with xy coond, get the following:
+	 *     sqrt(sqr((1-t)*c1.x + t*c2.x - p.x) + sqr((1-t)*c1.y + t*c2.y - p.y))
+	 *           = (1-t)r1 + t*r2
+	 *     <====> At*t- 2Bt + C = 0
+	 *     where A = sqr(c2.x - c1.x) + sqr(c2.y - c1.y) - sqr(r2 -r1)
+	 *           B = (p.x - c1.x)*(c2.x - c1.x) + (p.y - c1.y)*(c2.y - c1.y) + r1*(r2 -r1)
+	 *           C = sqr(p.x - c1.x) + sqr(p.y - c1.y) - r1*r1
+	 *
+	 *     solve the fomula and we get the result of
+	 *     t = (B + sqrt(B*B - A*C)) / A  or
+	 *     t = (B - sqrt(B*B - A*C)) / A  (quadratic equation have two solutions)
+	 *
+	 *     The solution we are going to prefer is the bigger one, unless the
+	 *     radius associated to it is negative (or it falls outside the valid t range)
+	 */
+
+	const char *gradient_fs_template =
+	    GLAMOR_DEFAULT_PRECISION
+	    "uniform mat3 transform_mat;\n"
+	    "uniform int repeat_type;\n"
+	    "uniform float A_value;\n"
+	    "uniform vec2 c1;\n"
+	    "uniform float r1;\n"
+	    "uniform vec2 c2;\n"
+	    "uniform float r2;\n"
+	    "varying vec2 source_texture;\n"
+	    "\n"
+	    "vec4 get_color(float stop_len);\n"
+	    "\n"
+	    "int t_invalid;\n"
+	    "\n"
+	    "float get_stop_len()\n"
+	    "{\n"
+	    "    float t = 0.0;\n"
+	    "    float sqrt_value;\n"
+	    "    int revserse = 0;\n"
+	    "    t_invalid = 0;\n"
+	    "    \n"
+	    "    vec3 tmp = vec3(source_texture.x, source_texture.y, 1.0);\n"
+	    "    vec3 source_texture_trans = transform_mat * tmp;\n"
+	    "    source_texture_trans.xy = source_texture_trans.xy/source_texture_trans.z;\n"
+	    "    float B_value = (source_texture_trans.x - c1.x) * (c2.x - c1.x)\n"
+	    "                     + (source_texture_trans.y - c1.y) * (c2.y - c1.y)\n"
+	    "                     + r1 * (r2 - r1);\n"
+	    "    float C_value = (source_texture_trans.x - c1.x) * (source_texture_trans.x - c1.x)\n"
+	    "                     + (source_texture_trans.y - c1.y) * (source_texture_trans.y - c1.y)\n"
+	    "                     - r1*r1;\n"
+	    "    if(abs(A_value) < 0.00001) {\n"
+	    "        if(B_value == 0.0) {\n"
+	    "            t_invalid = 1;\n"
+	    "            return t;\n"
+	    "        }\n"
+	    "        t = 0.5 * C_value / B_value;"
+	    "    } else {\n"
+	    "        sqrt_value = B_value * B_value - A_value * C_value;\n"
+	    "        if(sqrt_value < 0.0) {\n"
+	    "            t_invalid = 1;\n"
+	    "            return t;\n"
+	    "        }\n"
+	    "        sqrt_value = sqrt(sqrt_value);\n"
+	    "        t = (B_value + sqrt_value) / A_value;\n"
+	    "    }\n"
+	    "    if(repeat_type == %d) {\n" // RepeatNone case.
+	    "        if((t <= 0.0) || (t > 1.0))\n"
+	    //           try another if first one invalid
+	    "            t = (B_value - sqrt_value) / A_value;\n"
+	    "        \n"
+	    "        if((t <= 0.0) || (t > 1.0)) {\n" //still invalid, return.
+	    "            t_invalid = 1;\n"
+	    "            return t;\n"
+	    "        }\n"
+	    "    } else {\n"
+	    "        if(t * (r2 - r1) <= -1.0 * r1)\n"
+	    //           try another if first one invalid
+	    "            t = (B_value - sqrt_value) / A_value;\n"
+	    "        \n"
+	    "        if(t * (r2 -r1) <= -1.0 * r1) {\n" //still invalid, return.
+	    "            t_invalid = 1;\n"
+	    "            return t;\n"
+	    "        }\n"
+	    "    }\n"
+	    "    \n"
+	    "    if(repeat_type == %d){\n" // repeat normal
+	    "        while(t > 1.0) \n"
+	    "            t = t - 1.0; \n"
+	    "        while(t < 0.0) \n"
+	    "            t = t + 1.0; \n"
+	    "    }\n"
+	    "    \n"
+	    "    if(repeat_type == %d) {\n" // repeat reflect
+	    "        while(t > 1.0) {\n"
+	    "            t = t - 1.0; \n"
+	    "            if(revserse == 0)\n"
+	    "                revserse = 1;\n"
+	    "            else\n"
+	    "                revserse = 0;\n"
+	    "        }\n"
+	    "        while(t < 0.0) {\n"
+	    "            t = t + 1.0; \n"
+	    "            if(revserse == 0)\n"
+	    "                revserse = 1;\n"
+	    "            else\n"
+	    "                revserse = 0;\n"
+	    "        }\n"
+	    "        if(revserse == 1) {\n"
+	    "            t = 1.0 - t; \n"
+	    "        }\n"
+	    "    }\n"
+	    "    \n"
+	    "    return t;\n"
+	    "}\n"
+	    "\n"
+	    "void main()\n"
+	    "{\n"
+	    "    float stop_len = get_stop_len();\n"
+	    "    if(t_invalid == 1) {\n"
+	    "        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
+	    "    } else {\n"
+	    "        gl_FragColor = get_color(stop_len);\n"
+	    "    }\n"
+	    "}\n";
+
+	glamor_priv = glamor_get_screen_private(screen);
+
+	if ((glamor_priv->radial_max_nstops >= stops_count) && (dyn_gen)) {
+		/* Very Good, not to generate again. */
+		return;
+	}
+
+	dispatch = glamor_get_dispatch(glamor_priv);
+
+	if (dyn_gen && glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][2]) {
+		dispatch->glDeleteShader(
+		    glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_VS_PROG][2]);
+		glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_VS_PROG][2] = 0;
+
+		dispatch->glDeleteShader(
+		    glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][2]);
+		glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][2] = 0;
+
+		dispatch->glDeleteShader(
+		    glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][2]);
+		glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][2] = 0;
+
+		dispatch->glDeleteProgram(glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][2]);
+		glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][2] = 0;
+	}
+
+	gradient_prog = dispatch->glCreateProgram();
+
+	vs_prog = glamor_compile_glsl_prog(dispatch,
+	                                   GL_VERTEX_SHADER, gradient_vs);
+
+	XNFasprintf(&gradient_fs,
+	            gradient_fs_template,
+	            PIXMAN_REPEAT_NONE, PIXMAN_REPEAT_NORMAL, PIXMAN_REPEAT_REFLECT);
+
+	fs_main_prog = glamor_compile_glsl_prog(dispatch,
+	                                        GL_FRAGMENT_SHADER, gradient_fs);
+
+	free(gradient_fs);
+
+	fs_getcolor_prog =
+	    _glamor_create_getcolor_fs_program(screen, stops_count, (stops_count > 0));
+
+	dispatch->glAttachShader(gradient_prog, vs_prog);
+	dispatch->glAttachShader(gradient_prog, fs_getcolor_prog);
+	dispatch->glAttachShader(gradient_prog, fs_main_prog);
+
+	dispatch->glBindAttribLocation(gradient_prog, GLAMOR_VERTEX_POS, "v_positionsition");
+	dispatch->glBindAttribLocation(gradient_prog, GLAMOR_VERTEX_SOURCE, "v_texcoord");
+
+	glamor_link_glsl_prog(dispatch, gradient_prog);
+
+	dispatch->glUseProgram(0);
+
+	if (dyn_gen) {
+		index = 2;
+		glamor_priv->radial_max_nstops = stops_count;
+	} else if (stops_count) {
+		index = 1;
+	} else {
+		index = 0;
+	}
+
+	glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][index] = gradient_prog;
+	glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_VS_PROG][index] = vs_prog;
+	glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][index] = fs_main_prog;
+	glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][index] = fs_getcolor_prog;
+
+	glamor_put_dispatch(glamor_priv);
+}
+
+static void
+_glamor_create_linear_gradient_program(ScreenPtr screen, int stops_count, int dyn_gen)
+{
+	glamor_screen_private *glamor_priv;
+	glamor_gl_dispatch *dispatch;
+
+	int index = 0;
+	GLint gradient_prog = 0;
+	char *gradient_fs = NULL;
+	GLint fs_main_prog, fs_getcolor_prog, vs_prog;
+
+	const char *gradient_vs =
+	    GLAMOR_DEFAULT_PRECISION
+	    "attribute vec4 v_position;\n"
+	    "attribute vec4 v_texcoord;\n"
+	    "varying vec2 source_texture;\n"
+	    "\n"
+	    "void main()\n"
+	    "{\n"
+	    "    gl_Position = v_position;\n"
+	    "    source_texture = v_texcoord.xy;\n"
+	    "}\n";
+
+	/*
+	 *                                      |
+	 *                                      |\
+	 *                                      | \
+	 *                                      |  \
+	 *                                      |   \
+	 *                                      |\   \
+	 *                                      | \   \
+	 *     cos_val =                        |\ p1d \   /
+	 *      sqrt(1/(slope*slope+1.0))  ------>\ \   \ /
+	 *                                      |  \ \   \
+	 *                                      |   \ \ / \
+	 *                                      |    \ *Pt1\
+	 *         *p1                          |     \     \     *P
+	 *          \                           |    / \     \   /
+	 *           \                          |   /   \     \ /
+	 *            \                         |       pd     \
+	 *             \                        |         \   / \
+	 *            p2*                       |          \ /   \       /
+	 *        slope = (p2.y - p1.y) /       |           /     p2d   /
+	 *                    (p2.x - p1.x)     |          /       \   /
+	 *                                      |         /         \ /
+	 *                                      |        /           /
+	 *                                      |       /           /
+	 *                                      |      /           *Pt2
+	 *                                      |                 /
+	 *                                      |                /
+	 *                                      |               /
+	 *                                      |              /
+	 *                                      |             /
+	 *                               -------+---------------------------------
+	 *                                     O|
+	 *                                      |
+	 *                                      |
+	 *
+	 *	step 1: compute the distance of p, pt1 and pt2 in the slope direction.
+	 *		Caculate the distance on Y axis first and multiply cos_val to
+	 *		get the value on slope direction(pd, p1d and p2d represent the
+	 *		distance of p, pt1, and pt2 respectively).
+	 *
+	 *	step 2: caculate the percentage of (pd - p1d)/(p2d - p1d).
+	 *		If (pd - p1d) > (p2d - p1d) or < 0, then sub or add (p2d - p1d)
+	 *		to make it in the range of [0, (p2d - p1d)].
+	 *
+	 *	step 3: compare the percentage to every stop and find the stpos just
+	 *		before and after it. Use the interpolation fomula to compute RGBA.
+	 */
+
+	const char *gradient_fs_template =
+	    GLAMOR_DEFAULT_PRECISION
+	    "uniform mat3 transform_mat;\n"
+	    "uniform int repeat_type;\n"
+	    "uniform int hor_ver;\n"
+	    "uniform float pt_slope;\n"
+	    "uniform float cos_val;\n"
+	    "uniform float p1_distance;\n"
+	    "uniform float pt_distance;\n"
+	    "varying vec2 source_texture;\n"
+	    "\n"
+	    "vec4 get_color(float stop_len);\n"
+	    "\n"
+	    "float get_stop_len()\n"
+	    "{\n"
+	    "    vec3 tmp = vec3(source_texture.x, source_texture.y, 1.0);\n"
+	    "    float len_percentage;\n"
+	    "    float distance;\n"
+	    "    float _p1_distance;\n"
+	    "    float _pt_distance;\n"
+	    "    float y_dist;\n"
+	    "    float stop_after;\n"
+	    "    float stop_before;\n"
+	    "    vec4 stop_color_before;\n"
+	    "    vec4 stop_color_after;\n"
+	    "    float new_alpha; \n"
+	    "    int revserse = 0;\n"
+	    "    vec4 gradient_color;\n"
+	    "    float percentage; \n"
+	    "    vec3 source_texture_trans = transform_mat * tmp;\n"
+	    "    \n"
+	    "    if(hor_ver == 0) { \n" //Normal case.
+	    "        y_dist = source_texture_trans.y - source_texture_trans.x*pt_slope;\n"
+	    "        distance = y_dist * cos_val;\n"
+	    "        _p1_distance = p1_distance * source_texture_trans.z;\n"
+	    "        _pt_distance = pt_distance * source_texture_trans.z;\n"
+	    "        \n"
+	    "    } else if (hor_ver == 1) {\n"//horizontal case.
+	    "        distance = source_texture_trans.x;\n"
+	    "        _p1_distance = p1_distance * source_texture_trans.z;\n"
+	    "        _pt_distance = pt_distance * source_texture_trans.z;\n"
+	    "    } \n"
+	    "    \n"
+	    "    distance = distance - _p1_distance; \n"
+	    "    \n"
+	    "    if(repeat_type == %d){\n" // repeat normal
+	    "        while(distance > _pt_distance) \n"
+	    "            distance = distance - (_pt_distance); \n"
+	    "        while(distance < 0.0) \n"
+	    "            distance = distance + (_pt_distance); \n"
+	    "    }\n"
+	    "    \n"
+	    "    if(repeat_type == %d) {\n" // repeat reflect
+	    "        while(distance > _pt_distance) {\n"
+	    "            distance = distance - (_pt_distance); \n"
+	    "            if(revserse == 0)\n"
+	    "                revserse = 1;\n"
+	    "            else\n"
+	    "                revserse = 0;\n"
+	    "        }\n"
+	    "        while(distance < 0.0) {\n"
+	    "            distance = distance + (_pt_distance); \n"
+	    "            if(revserse == 0)\n"
+	    "                revserse = 1;\n"
+	    "            else\n"
+	    "                revserse = 0;\n"
+	    "        }\n"
+	    "        if(revserse == 1) {\n"
+	    "            distance = (_pt_distance) - distance; \n"
+	    "        }\n"
+	    "    }\n"
+	    "    \n"
+	    "    len_percentage = distance/(_pt_distance);\n"
+	    "    \n"
+	    "    return len_percentage;\n"
+	    "}\n"
+	    "\n"
+	    "void main()\n"
+	    "{\n"
+	    "    float stop_len = get_stop_len();\n"
+	    "    gl_FragColor = get_color(stop_len);\n"
+	    "}\n";
+
+
+	glamor_priv = glamor_get_screen_private(screen);
+
+	if ((glamor_priv->linear_max_nstops >= stops_count) && (dyn_gen)) {
+		/* Very Good, not to generate again. */
+		return;
+	}
+
+	dispatch = glamor_get_dispatch(glamor_priv);
+	if (dyn_gen && glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][2]) {
+		dispatch->glDeleteShader(
+		    glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_VS_PROG][2]);
+		glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_VS_PROG][2] = 0;
+
+		dispatch->glDeleteShader(
+		    glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][2]);
+		glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][2] = 0;
+
+		dispatch->glDeleteShader(
+		    glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][2]);
+		glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][2] = 0;
+
+		dispatch->glDeleteProgram(glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][2]);
+		glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][2] = 0;
+	}
+
+	gradient_prog = dispatch->glCreateProgram();
+
+	vs_prog = glamor_compile_glsl_prog(dispatch,
+	                                   GL_VERTEX_SHADER, gradient_vs);
+
+	XNFasprintf(&gradient_fs,
+	            gradient_fs_template,
+	            PIXMAN_REPEAT_NORMAL, PIXMAN_REPEAT_REFLECT);
+
+	fs_main_prog = glamor_compile_glsl_prog(dispatch,
+	                                        GL_FRAGMENT_SHADER, gradient_fs);
+	free(gradient_fs);
+
+	fs_getcolor_prog =
+	    _glamor_create_getcolor_fs_program(screen, stops_count, (stops_count > 0));
+
+	dispatch->glAttachShader(gradient_prog, vs_prog);
+	dispatch->glAttachShader(gradient_prog, fs_getcolor_prog);
+	dispatch->glAttachShader(gradient_prog, fs_main_prog);
+
+	dispatch->glBindAttribLocation(gradient_prog, GLAMOR_VERTEX_POS, "v_position");
+	dispatch->glBindAttribLocation(gradient_prog, GLAMOR_VERTEX_SOURCE, "v_texcoord");
+
+	glamor_link_glsl_prog(dispatch, gradient_prog);
+
+	dispatch->glUseProgram(0);
+
+	if (dyn_gen) {
+		index = 2;
+		glamor_priv->linear_max_nstops = stops_count;
+	} else if (stops_count) {
+		index = 1;
+	} else {
+		index = 0;
+	}
+
+	glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][index] = gradient_prog;
+	glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_VS_PROG][index] = vs_prog;
+	glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][index] = fs_main_prog;
+	glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][index] = fs_getcolor_prog;
+
+	glamor_put_dispatch(glamor_priv);
+}
+
+void
+glamor_init_gradient_shader(ScreenPtr screen)
+{
+	glamor_screen_private *glamor_priv;
+	int i;
+
+	glamor_priv = glamor_get_screen_private(screen);
+
+	for (i = 0; i < 3; i++) {
+		glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][i] = 0;
+		glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_VS_PROG][i] = 0;
+		glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][i] = 0;
+		glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][i] = 0;
+
+		glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][i] = 0;
+		glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_VS_PROG][i] = 0;
+		glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][i] = 0;
+		glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][i] = 0;
+	}
+	glamor_priv->linear_max_nstops = 0;
+	glamor_priv->radial_max_nstops = 0;
+
+	_glamor_create_linear_gradient_program(screen, 0, 0);
+	_glamor_create_linear_gradient_program(screen, LINEAR_LARGE_STOPS, 0);
+
+	_glamor_create_radial_gradient_program(screen, 0, 0);
+	_glamor_create_radial_gradient_program(screen, RADIAL_LARGE_STOPS, 0);
+}
+
+void
+glamor_fini_gradient_shader(ScreenPtr screen)
+{
+	glamor_screen_private *glamor_priv;
+	glamor_gl_dispatch *dispatch;
+	int i = 0;
+
+	glamor_priv = glamor_get_screen_private(screen);
+	dispatch = glamor_get_dispatch(glamor_priv);
+
+	for (i = 0; i < 3; i++) {
+		/* Linear Gradient */
+		if (glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_VS_PROG][i])
+			dispatch->glDeleteShader(
+			    glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_VS_PROG][i]);
+
+		if (glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][i])
+			dispatch->glDeleteShader(
+			    glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][i]);
+
+		if (glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][i])
+			dispatch->glDeleteShader(
+			    glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][i]);
+
+		if (glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][i])
+			dispatch->glDeleteProgram(glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][i]);
+
+		/* Radial Gradient */
+		if (glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_VS_PROG][i])
+			dispatch->glDeleteShader(
+			    glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_VS_PROG][i]);
+
+		if (glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][i])
+			dispatch->glDeleteShader(
+			    glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][i]);
+
+		if (glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][i])
+			dispatch->glDeleteShader(
+			    glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][i]);
+
+		if (glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][i])
+			dispatch->glDeleteProgram(glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][i]);
+	}
+
+	glamor_put_dispatch(glamor_priv);
+}
+
+static void
+_glamor_gradient_convert_trans_matrix(PictTransform *from, float to[3][3],
+				      int width, int height, int normalize)
+{
+	/*
+	 * Because in the shader program, we normalize all the pixel cood to [0, 1],
+	 * so with the transform matrix, the correct logic should be:
+	 * v_s = A*T*v
+	 * v_s: point vector in shader after normalized.
+	 * A: The transition matrix from   width X height --> 1.0 X 1.0
+	 * T: The transform matrix.
+	 * v: point vector in width X height space.
+	 *
+	 * result is OK if we use this fomula. But for every point in width X height space,
+	 * we can just use their normalized point vector in shader, namely we can just
+	 * use the result of A*v in shader. So we have no chance to insert T in A*v.
+	 * We can just convert v_s = A*T*v to v_s = A*T*inv(A)*A*v, where inv(A) is the
+	 * inverse matrix of A. Now, v_s = (A*T*inv(A)) * (A*v)
+	 * So, to get the correct v_s, we need to cacula1 the matrix: (A*T*inv(A)), and
+	 * we name this matrix T_s.
+	 *
+	 * Firstly, because A is for the scale convertion, we find
+	 *      --         --
+	 *      |1/w  0   0 |
+	 * A =  | 0  1/h  0 |
+	 *      | 0   0  1.0|
+	 *      --         --
+	 * so T_s = A*T*inv(a) and result
+	 *
+	 *       --                      --
+	 *       | t11      h*t12/w  t13/w|
+	 * T_s = | w*t21/h  t22      t23/h|
+	 *       | w*t31    h*t32    t33  |
+	 *       --                      --
+	 */
+
+	to[0][0] = (float)pixman_fixed_to_double(from->matrix[0][0]);
+	to[0][1] = (float)pixman_fixed_to_double(from->matrix[0][1])
+	                        * (normalize ? (((float)height) / ((float)width)) : 1.0);
+	to[0][2] = (float)pixman_fixed_to_double(from->matrix[0][2])
+	                        / (normalize ? ((float)width) : 1.0);
+
+	to[1][0] = (float)pixman_fixed_to_double(from->matrix[1][0])
+	                        * (normalize ? (((float)width) / ((float)height)) : 1.0);
+	to[1][1] = (float)pixman_fixed_to_double(from->matrix[1][1]);
+	to[1][2] = (float)pixman_fixed_to_double(from->matrix[1][2])
+	                        / (normalize ? ((float)height) : 1.0);
+
+	to[2][0] = (float)pixman_fixed_to_double(from->matrix[2][0])
+	                        * (normalize ? ((float)width) : 1.0);
+	to[2][1] = (float)pixman_fixed_to_double(from->matrix[2][1])
+	                        * (normalize ? ((float)height) : 1.0);
+	to[2][2] = (float)pixman_fixed_to_double(from->matrix[2][2]);
+
+	DEBUGF("the transform matrix is:\n%f\t%f\t%f\n%f\t%f\t%f\n%f\t%f\t%f\n",
+	       to[0][0], to[0][1], to[0][2],
+	       to[1][0], to[1][1], to[1][2],
+	       to[2][0], to[2][1], to[2][2]);
+}
+
+static int
+_glamor_gradient_set_pixmap_destination(ScreenPtr screen,
+                                        glamor_screen_private *glamor_priv,
+                                        PicturePtr dst_picture,
+                                        GLfloat *xscale, GLfloat *yscale,
+                                        int x_source, int y_source,
+                                        float vertices[8],
+                                        float tex_vertices[8],
+					int tex_normalize)
+{
+	glamor_pixmap_private *pixmap_priv;
+	PixmapPtr pixmap = NULL;
+	glamor_gl_dispatch *dispatch = NULL;
+
+	pixmap = glamor_get_drawable_pixmap(dst_picture->pDrawable);
+	pixmap_priv = glamor_get_pixmap_private(pixmap);
+
+	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv)) { /* should always have here. */
+		return 0;
+	}
+
+	glamor_set_destination_pixmap_priv_nc(pixmap_priv);
+
+	pixmap_priv_get_dest_scale(pixmap_priv, xscale, yscale);
+
+	DEBUGF("xscale = %f, yscale = %f,"
+	       " x_source = %d, y_source = %d, width = %d, height = %d\n",
+	       *xscale, *yscale, x_source, y_source,
+	       dst_picture->pDrawable->width, dst_picture->pDrawable->height);
+
+	glamor_set_normalize_vcoords_tri_strip(*xscale, *yscale,
+	                  0, 0,
+	                  (INT16)(dst_picture->pDrawable->width),
+	                  (INT16)(dst_picture->pDrawable->height),
+	                  glamor_priv->yInverted, vertices);
+
+	if (tex_normalize) {
+		glamor_set_normalize_tcoords_tri_stripe(*xscale, *yscale,
+		                x_source, y_source,
+		                (INT16)(dst_picture->pDrawable->width + x_source),
+		                (INT16)(dst_picture->pDrawable->height + y_source),
+		                glamor_priv->yInverted, tex_vertices);
+	} else {
+		glamor_set_tcoords_tri_strip((INT16)(dst_picture->pDrawable->width),
+		                 (INT16)(dst_picture->pDrawable->height),
+		                 x_source, y_source,
+		                 (INT16)(dst_picture->pDrawable->width) + x_source,
+		                 (INT16)(dst_picture->pDrawable->height) + y_source,
+		                 glamor_priv->yInverted, tex_vertices);
+	}
+
+	DEBUGF("vertices --> leftup : %f X %f, rightup: %f X %f,"
+	       "rightbottom: %f X %f, leftbottom : %f X %f\n",
+	       vertices[0], vertices[1], vertices[2], vertices[3],
+	       vertices[4], vertices[5], vertices[6], vertices[7]);
+	DEBUGF("tex_vertices --> leftup : %f X %f, rightup: %f X %f,"
+	       "rightbottom: %f X %f, leftbottom : %f X %f\n",
+	       tex_vertices[0], tex_vertices[1], tex_vertices[2], tex_vertices[3],
+	       tex_vertices[4], tex_vertices[5], tex_vertices[6], tex_vertices[7]);
+
+	dispatch = glamor_get_dispatch(glamor_priv);
+
+	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_POS, 2, GL_FLOAT,
+					GL_FALSE, 0, vertices);
+	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_SOURCE, 2, GL_FLOAT,
+					GL_FALSE, 0, tex_vertices);
+
+	dispatch->glEnableVertexAttribArray(GLAMOR_VERTEX_POS);
+	dispatch->glEnableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
+
+	glamor_put_dispatch(glamor_priv);
+
+	return 1;
+}
+
+static int
+_glamor_gradient_set_stops(PicturePtr src_picture, PictGradient * pgradient,
+        GLfloat *stop_colors, GLfloat *n_stops)
+{
+	int i;
+	int count = 1;
+
+	for (i = 0; i < pgradient->nstops; i++) {
+		stop_colors[count*4] = pixman_fixed_to_double(
+		                                pgradient->stops[i].color.red);
+		stop_colors[count*4+1] = pixman_fixed_to_double(
+		                                pgradient->stops[i].color.green);
+		stop_colors[count*4+2] = pixman_fixed_to_double(
+		                                pgradient->stops[i].color.blue);
+		stop_colors[count*4+3] = pixman_fixed_to_double(
+		                                pgradient->stops[i].color.alpha);
+
+		n_stops[count] = (GLfloat)pixman_fixed_to_double(
+		                                pgradient->stops[i].x);
+		count++;
+	}
+
+	/* for the end stop. */
+	count++;
+
+	switch (src_picture->repeatType) {
+#define REPEAT_FILL_STOPS(m, n) \
+			stop_colors[(m)*4 + 0] = stop_colors[(n)*4 + 0]; \
+			stop_colors[(m)*4 + 1] = stop_colors[(n)*4 + 1]; \
+			stop_colors[(m)*4 + 2] = stop_colors[(n)*4 + 2]; \
+			stop_colors[(m)*4 + 3] = stop_colors[(n)*4 + 3];
+
+		default:
+		case PIXMAN_REPEAT_NONE:
+			stop_colors[0] = 0.0;	   //R
+			stop_colors[1] = 0.0;	   //G
+			stop_colors[2] = 0.0;	   //B
+			stop_colors[3] = 0.0;	   //Alpha
+			n_stops[0] = -(float)INT_MAX;  //should be small enough.
+
+			stop_colors[0 + (count-1)*4] = 0.0;	 //R
+			stop_colors[1 + (count-1)*4] = 0.0;	 //G
+			stop_colors[2 + (count-1)*4] = 0.0;	 //B
+			stop_colors[3 + (count-1)*4] = 0.0;	 //Alpha
+			n_stops[count-1] = (float)INT_MAX;  //should be large enough.
+			break;
+		case PIXMAN_REPEAT_NORMAL:
+			REPEAT_FILL_STOPS(0, count - 2);
+			n_stops[0] = n_stops[count-2] - 1.0;
+
+			REPEAT_FILL_STOPS(count - 1, 1);
+			n_stops[count-1] = n_stops[1] + 1.0;
+			break;
+		case PIXMAN_REPEAT_REFLECT:
+			REPEAT_FILL_STOPS(0, 1);
+			n_stops[0] = -n_stops[1];
+
+			REPEAT_FILL_STOPS(count - 1, count - 2);
+			n_stops[count-1] = 1.0 + 1.0 - n_stops[count-2];
+			break;
+		case PIXMAN_REPEAT_PAD:
+			REPEAT_FILL_STOPS(0, 1);
+			n_stops[0] = -(float)INT_MAX;
+
+			REPEAT_FILL_STOPS(count - 1, count - 2);
+			n_stops[count-1] = (float)INT_MAX;
+			break;
+#undef REPEAT_FILL_STOPS
+	}
+
+	for (i = 0; i < count; i++) {
+		DEBUGF("n_stops[%d] = %f, color = r:%f g:%f b:%f a:%f\n",
+		       i, n_stops[i],
+		       stop_colors[i*4], stop_colors[i*4+1],
+		       stop_colors[i*4+2], stop_colors[i*4+3]);
+	}
+
+	return count;
+}
+
+PicturePtr
+glamor_generate_radial_gradient_picture(ScreenPtr screen,
+                                         PicturePtr src_picture,
+                                         int x_source, int y_source,
+                                         int width, int height,
+                                         PictFormatShort format)
+{
+	glamor_screen_private *glamor_priv;
+	glamor_gl_dispatch *dispatch;
+	PicturePtr dst_picture = NULL;
+	PixmapPtr pixmap = NULL;
+	GLint gradient_prog = 0;
+	int error;
+	float tex_vertices[8];
+	int stops_count = 0;
+	int count = 0;
+	GLfloat *stop_colors = NULL;
+	GLfloat *n_stops = NULL;
+	GLfloat xscale, yscale;
+	float vertices[8];
+	float transform_mat[3][3];
+	static const float identity_mat[3][3] = {{1.0, 0.0, 0.0},
+	                                         {0.0, 1.0, 0.0},
+	                                         {0.0, 0.0, 1.0}};
+	GLfloat stop_colors_st[RADIAL_SMALL_STOPS*4];
+	GLfloat n_stops_st[RADIAL_SMALL_STOPS];
+	GLfloat A_value;
+	GLfloat cxy[4];
+	float c1x, c1y, c2x, c2y, r1, r2;
+
+	GLint transform_mat_uniform_location = 0;
+	GLint repeat_type_uniform_location = 0;
+	GLint n_stop_uniform_location = 0;
+	GLint stops_uniform_location = 0;
+	GLint stop_colors_uniform_location = 0;
+	GLint stop0_uniform_location = 0;
+	GLint stop1_uniform_location = 0;
+	GLint stop2_uniform_location = 0;
+	GLint stop3_uniform_location = 0;
+	GLint stop4_uniform_location = 0;
+	GLint stop5_uniform_location = 0;
+	GLint stop6_uniform_location = 0;
+	GLint stop7_uniform_location = 0;
+	GLint stop_color0_uniform_location = 0;
+	GLint stop_color1_uniform_location = 0;
+	GLint stop_color2_uniform_location = 0;
+	GLint stop_color3_uniform_location = 0;
+	GLint stop_color4_uniform_location = 0;
+	GLint stop_color5_uniform_location = 0;
+	GLint stop_color6_uniform_location = 0;
+	GLint stop_color7_uniform_location = 0;
+	GLint A_value_uniform_location = 0;
+	GLint c1_uniform_location = 0;
+	GLint r1_uniform_location = 0;
+	GLint c2_uniform_location = 0;
+	GLint r2_uniform_location = 0;
+
+	glamor_priv = glamor_get_screen_private(screen);
+	dispatch = glamor_get_dispatch(glamor_priv);
+
+	/* Create a pixmap with VBO. */
+	pixmap = glamor_create_pixmap(screen,
+	                              width, height,
+	                              PIXMAN_FORMAT_DEPTH(format),
+	                              0);
+	if (!pixmap)
+		goto GRADIENT_FAIL;
+
+	dst_picture = CreatePicture(0, &pixmap->drawable,
+	                            PictureMatchFormat(screen,
+	                                 PIXMAN_FORMAT_DEPTH(format), format),
+	                            0, 0, serverClient, &error);
+
+	/* Release the reference, picture will hold the last one. */
+	glamor_destroy_pixmap(pixmap);
+
+	if (!dst_picture)
+		goto GRADIENT_FAIL;
+
+	ValidatePicture(dst_picture);
+
+	stops_count = src_picture->pSourcePict->radial.nstops + 2;
+
+	/* Because the max value of nstops is unkown, so create a program
+	   when nstops > LINEAR_LARGE_STOPS.*/
+	if (stops_count <= RADIAL_SMALL_STOPS) {
+		gradient_prog = glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][0];
+	} else if (stops_count <= RADIAL_LARGE_STOPS) {
+		gradient_prog = glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][1];
+	} else {
+		_glamor_create_radial_gradient_program(screen,
+						       src_picture->pSourcePict->linear.nstops + 2,
+						       1);
+		gradient_prog = glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][2];
+	}
+
+	/* Bind all the uniform vars .*/
+	transform_mat_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "transform_mat");
+	repeat_type_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "repeat_type");
+	n_stop_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "n_stop");
+	A_value_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "A_value");
+	repeat_type_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "repeat_type");
+	c1_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "c1");
+	r1_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "r1");
+	c2_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "c2");
+	r2_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "r2");
+
+	if (src_picture->pSourcePict->radial.nstops + 2 <= RADIAL_SMALL_STOPS) {
+		stop0_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop0");
+		stop1_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop1");
+		stop2_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop2");
+		stop3_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop3");
+		stop4_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop4");
+		stop5_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop5");
+		stop6_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop6");
+		stop7_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop7");
+
+		stop_color0_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color0");
+		stop_color1_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color1");
+		stop_color2_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color2");
+		stop_color3_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color3");
+		stop_color4_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color4");
+		stop_color5_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color5");
+		stop_color6_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color6");
+		stop_color7_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color7");
+	} else {
+		stops_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stops");
+		stop_colors_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_colors");
+	}
+
+	dispatch->glUseProgram(gradient_prog);
+
+	dispatch->glUniform1i(repeat_type_uniform_location, src_picture->repeatType);
+
+
+	if (src_picture->transform) {
+		_glamor_gradient_convert_trans_matrix(src_picture->transform,
+		                                      transform_mat,
+		                                      width, height, 0);
+		dispatch->glUniformMatrix3fv(transform_mat_uniform_location,
+		                             1, 1, &transform_mat[0][0]);
+	} else {
+		dispatch->glUniformMatrix3fv(transform_mat_uniform_location,
+		                             1, 1, &identity_mat[0][0]);
+	}
+
+	if (!_glamor_gradient_set_pixmap_destination(screen, glamor_priv, dst_picture,
+	                                             &xscale, &yscale, x_source, y_source,
+	                                             vertices, tex_vertices, 0))
+		goto GRADIENT_FAIL;
+
+	/* Set all the stops and colors to shader. */
+	if (stops_count > RADIAL_SMALL_STOPS) {
+		stop_colors = malloc(4 * stops_count * sizeof(float));
+		if (stop_colors == NULL) {
+			ErrorF("Failed to allocate stop_colors memory.\n");
+			goto GRADIENT_FAIL;
+		}
+
+		n_stops = malloc(stops_count * sizeof(float));
+		if (n_stops == NULL) {
+			ErrorF("Failed to allocate n_stops memory.\n");
+			goto GRADIENT_FAIL;
+		}
+	} else {
+		stop_colors = stop_colors_st;
+		n_stops = n_stops_st;
+	}
+
+	count = _glamor_gradient_set_stops(src_picture, &src_picture->pSourcePict->gradient,
+	                                   stop_colors, n_stops);
+
+	if (src_picture->pSourcePict->linear.nstops + 2 <= RADIAL_SMALL_STOPS) {
+		int j = 0;
+		dispatch->glUniform4f(stop_color0_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color1_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color2_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color3_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color4_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color5_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color6_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color7_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+
+		j = 0;
+		dispatch->glUniform1f(stop0_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop1_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop2_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop3_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop4_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop5_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop6_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop7_uniform_location, n_stops[j++]);
+		dispatch->glUniform1i(n_stop_uniform_location, count);
+	} else {
+		dispatch->glUniform4fv(stop_colors_uniform_location, count, stop_colors);
+		dispatch->glUniform1fv(stops_uniform_location, count, n_stops);
+		dispatch->glUniform1i(n_stop_uniform_location, count);
+	}
+
+	c1x = (float)pixman_fixed_to_double(src_picture->pSourcePict->radial.c1.x);
+	c1y = (float)pixman_fixed_to_double(src_picture->pSourcePict->radial.c1.y);
+	c2x = (float)pixman_fixed_to_double(src_picture->pSourcePict->radial.c2.x);
+	c2y = (float)pixman_fixed_to_double(src_picture->pSourcePict->radial.c2.y);
+
+	r1 = (float)pixman_fixed_to_double(src_picture->pSourcePict->radial.c1.radius);
+	r2 = (float)pixman_fixed_to_double(src_picture->pSourcePict->radial.c2.radius);
+
+	glamor_set_circle_centre(width, height, c1x, c1y, glamor_priv->yInverted, cxy);
+	dispatch->glUniform2fv(c1_uniform_location, 1, cxy);
+	dispatch->glUniform1f(r1_uniform_location, r1);
+
+	glamor_set_circle_centre(width, height, c2x, c2y, glamor_priv->yInverted, cxy);
+	dispatch->glUniform2fv(c2_uniform_location, 1, cxy);
+	dispatch->glUniform1f(r2_uniform_location, r2);
+
+	A_value = (c2x - c1x) * (c2x - c1x) + (c2y - c1y) * (c2y - c1y) - (r2 - r1) * (r2 - r1);
+	dispatch->glUniform1f(A_value_uniform_location, A_value);
+
+	DEBUGF("C1:(%f, %f) R1:%f\nC2:(%f, %f) R2:%f\nA = %f\n",
+	       c1x, c1y, r1, c2x, c2y, r2, A_value);
+
+	/* Now rendering. */
+	dispatch->glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+
+	/* Do the clear logic.*/
+	if (stops_count > RADIAL_SMALL_STOPS) {
+		free(n_stops);
+		free(stop_colors);
+	}
+
+	dispatch->glBindBuffer(GL_ARRAY_BUFFER, 0);
+	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
+	dispatch->glUseProgram(0);
+
+	glamor_put_dispatch(glamor_priv);
+	return dst_picture;
+
+GRADIENT_FAIL:
+	if (dst_picture) {
+		FreePicture(dst_picture, 0);
+	}
+
+	if (stops_count > RADIAL_SMALL_STOPS) {
+		if (n_stops)
+			free(n_stops);
+		if (stop_colors)
+			free(stop_colors);
+	}
+
+	dispatch->glBindBuffer(GL_ARRAY_BUFFER, 0);
+	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
+	dispatch->glUseProgram(0);
+	glamor_put_dispatch(glamor_priv);
+	return NULL;
+}
+
+PicturePtr
+glamor_generate_linear_gradient_picture(ScreenPtr screen,
+                                         PicturePtr src_picture,
+                                         int x_source, int y_source,
+                                         int width, int height,
+                                         PictFormatShort format)
+{
+	glamor_screen_private *glamor_priv;
+	glamor_gl_dispatch *dispatch;
+	PicturePtr dst_picture = NULL;
+	PixmapPtr pixmap = NULL;
+	GLint gradient_prog = 0;
+	int error;
+	float pt_distance;
+	float p1_distance;
+	GLfloat cos_val;
+	float tex_vertices[8];
+	int stops_count = 0;
+	GLfloat *stop_colors = NULL;
+	GLfloat *n_stops = NULL;
+	int count = 0;
+	float slope;
+	GLfloat xscale, yscale;
+	GLfloat pt1[2], pt2[2];
+	float vertices[8];
+	float transform_mat[3][3];
+	static const float identity_mat[3][3] = {{1.0, 0.0, 0.0},
+	                                         {0.0, 1.0, 0.0},
+	                                         {0.0, 0.0, 1.0}};
+	GLfloat stop_colors_st[LINEAR_SMALL_STOPS*4];
+	GLfloat n_stops_st[LINEAR_SMALL_STOPS];
+
+	GLint transform_mat_uniform_location = 0;
+	GLint n_stop_uniform_location = 0;
+	GLint stops_uniform_location = 0;
+	GLint stop0_uniform_location = 0;
+	GLint stop1_uniform_location = 0;
+	GLint stop2_uniform_location = 0;
+	GLint stop3_uniform_location = 0;
+	GLint stop4_uniform_location = 0;
+	GLint stop5_uniform_location = 0;
+	GLint stop6_uniform_location = 0;
+	GLint stop7_uniform_location = 0;
+	GLint stop_colors_uniform_location = 0;
+	GLint stop_color0_uniform_location = 0;
+	GLint stop_color1_uniform_location = 0;
+	GLint stop_color2_uniform_location = 0;
+	GLint stop_color3_uniform_location = 0;
+	GLint stop_color4_uniform_location = 0;
+	GLint stop_color5_uniform_location = 0;
+	GLint stop_color6_uniform_location = 0;
+	GLint stop_color7_uniform_location = 0;
+	GLint pt_slope_uniform_location = 0;
+	GLint repeat_type_uniform_location = 0;
+	GLint hor_ver_uniform_location = 0;
+	GLint cos_val_uniform_location = 0;
+	GLint p1_distance_uniform_location = 0;
+	GLint pt_distance_uniform_location = 0;
+
+	glamor_priv = glamor_get_screen_private(screen);
+	dispatch = glamor_get_dispatch(glamor_priv);
+
+	/* Create a pixmap with VBO. */
+	pixmap = glamor_create_pixmap(screen,
+	                              width, height,
+	                              PIXMAN_FORMAT_DEPTH(format),
+	                              0);
+
+	if (!pixmap)
+		goto GRADIENT_FAIL;
+
+	dst_picture = CreatePicture(0, &pixmap->drawable,
+	                            PictureMatchFormat(screen,
+	                                    PIXMAN_FORMAT_DEPTH(format), format),
+	                            0, 0, serverClient, &error);
+
+	/* Release the reference, picture will hold the last one. */
+	glamor_destroy_pixmap(pixmap);
+
+	if (!dst_picture)
+		goto GRADIENT_FAIL;
+
+	ValidatePicture(dst_picture);
+
+	stops_count = src_picture->pSourcePict->linear.nstops + 2;
+
+	/* Because the max value of nstops is unkown, so create a program
+	   when nstops > LINEAR_LARGE_STOPS.*/
+	if (stops_count <= LINEAR_SMALL_STOPS) {
+		gradient_prog = glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][0];
+	} else if (stops_count <= LINEAR_LARGE_STOPS) {
+		gradient_prog = glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][1];
+	} else {
+		_glamor_create_linear_gradient_program(screen,
+		        src_picture->pSourcePict->linear.nstops + 2, 1);
+		gradient_prog = glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][2];
+	}
+
+	/* Bind all the uniform vars .*/
+	n_stop_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "n_stop");
+	pt_slope_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "pt_slope");
+	repeat_type_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "repeat_type");
+	hor_ver_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "hor_ver");
+	transform_mat_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "transform_mat");
+	cos_val_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "cos_val");
+	p1_distance_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "p1_distance");
+	pt_distance_uniform_location =
+	    dispatch->glGetUniformLocation(gradient_prog, "pt_distance");
+
+	if (src_picture->pSourcePict->linear.nstops + 2 <= LINEAR_SMALL_STOPS) {
+		stop0_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop0");
+		stop1_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop1");
+		stop2_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop2");
+		stop3_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop3");
+		stop4_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop4");
+		stop5_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop5");
+		stop6_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop6");
+		stop7_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop7");
+
+		stop_color0_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color0");
+		stop_color1_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color1");
+		stop_color2_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color2");
+		stop_color3_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color3");
+		stop_color4_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color4");
+		stop_color5_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color5");
+		stop_color6_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color6");
+		stop_color7_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_color7");
+	} else {
+		stops_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stops");
+		stop_colors_uniform_location =
+		    dispatch->glGetUniformLocation(gradient_prog, "stop_colors");
+	}
+
+	dispatch->glUseProgram(gradient_prog);
+
+	dispatch->glUniform1i(repeat_type_uniform_location, src_picture->repeatType);
+
+	/* set the transform matrix. */
+	if (src_picture->transform) {
+		_glamor_gradient_convert_trans_matrix(src_picture->transform,
+		                                      transform_mat,
+		                                      width, height, 1);
+		dispatch->glUniformMatrix3fv(transform_mat_uniform_location,
+		                             1, 1, &transform_mat[0][0]);
+	} else {
+		dispatch->glUniformMatrix3fv(transform_mat_uniform_location,
+		                             1, 1, &identity_mat[0][0]);
+	}
+
+	if (!_glamor_gradient_set_pixmap_destination(screen, glamor_priv, dst_picture,
+	                                             &xscale, &yscale, x_source, y_source,
+	                                             vertices, tex_vertices, 1))
+		goto GRADIENT_FAIL;
+
+	/* Normalize the PTs. */
+	glamor_set_normalize_pt(xscale, yscale,
+	                        pixman_fixed_to_double(src_picture->pSourcePict->linear.p1.x),
+	                        pixman_fixed_to_double(src_picture->pSourcePict->linear.p1.y),
+	                        glamor_priv->yInverted,
+	                        pt1);
+	DEBUGF("pt1:(%f, %f) ---> (%f %f)\n", pixman_fixed_to_double(src_picture->pSourcePict->linear.p1.x),
+	       pixman_fixed_to_double(src_picture->pSourcePict->linear.p1.y), pt1[0], pt1[1]);
+
+	glamor_set_normalize_pt(xscale, yscale,
+	                        pixman_fixed_to_double(src_picture->pSourcePict->linear.p2.x),
+	                        pixman_fixed_to_double(src_picture->pSourcePict->linear.p2.y),
+	                        glamor_priv->yInverted,
+	                        pt2);
+	DEBUGF("pt2:(%f, %f) ---> (%f %f)\n", pixman_fixed_to_double(src_picture->pSourcePict->linear.p2.x),
+	       pixman_fixed_to_double(src_picture->pSourcePict->linear.p2.y), pt2[0], pt2[1]);
+
+	/* Set all the stops and colors to shader. */
+	if (stops_count > LINEAR_SMALL_STOPS) {
+		stop_colors = malloc(4 * stops_count * sizeof(float));
+		if (stop_colors == NULL) {
+			ErrorF("Failed to allocate stop_colors memory.\n");
+			goto GRADIENT_FAIL;
+		}
+
+		n_stops = malloc(stops_count * sizeof(float));
+		if (n_stops == NULL) {
+			ErrorF("Failed to allocate n_stops memory.\n");
+			goto GRADIENT_FAIL;
+		}
+	} else {
+		stop_colors = stop_colors_st;
+		n_stops = n_stops_st;
+	}
+
+	count = _glamor_gradient_set_stops(src_picture, &src_picture->pSourcePict->gradient,
+	                                   stop_colors, n_stops);
+
+	if (src_picture->pSourcePict->linear.nstops + 2 <= LINEAR_SMALL_STOPS) {
+		int j = 0;
+		dispatch->glUniform4f(stop_color0_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color1_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color2_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color3_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color4_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color5_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color6_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+		j++;
+		dispatch->glUniform4f(stop_color7_uniform_location,
+		                      stop_colors[4*j+0], stop_colors[4*j+1],
+		                      stop_colors[4*j+2], stop_colors[4*j+3]);
+
+		j = 0;
+		dispatch->glUniform1f(stop0_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop1_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop2_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop3_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop4_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop5_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop6_uniform_location, n_stops[j++]);
+		dispatch->glUniform1f(stop7_uniform_location, n_stops[j++]);
+
+		dispatch->glUniform1i(n_stop_uniform_location, count);
+	} else {
+		dispatch->glUniform4fv(stop_colors_uniform_location, count, stop_colors);
+		dispatch->glUniform1fv(stops_uniform_location, count, n_stops);
+		dispatch->glUniform1i(n_stop_uniform_location, count);
+	}
+
+	if (src_picture->pSourcePict->linear.p2.y ==
+	              src_picture->pSourcePict->linear.p1.y) { // The horizontal case.
+		dispatch->glUniform1i(hor_ver_uniform_location, 1);
+		DEBUGF("p1.y: %f, p2.y: %f, enter the horizontal case\n",
+		       pt1[1], pt2[1]);
+
+		p1_distance = pt1[0];
+		pt_distance = (pt2[0] - p1_distance);
+		dispatch->glUniform1f(p1_distance_uniform_location, p1_distance);
+		dispatch->glUniform1f(pt_distance_uniform_location, pt_distance);
+	} else {
+		/* The slope need to compute here. In shader, the viewport set will change
+		   the orginal slope and the slope which is vertical to it will not be correct.*/
+		slope = - (float)(src_picture->pSourcePict->linear.p2.x
+				  - src_picture->pSourcePict->linear.p1.x) /
+		          (float)(src_picture->pSourcePict->linear.p2.y
+				  - src_picture->pSourcePict->linear.p1.y);
+		slope = slope * yscale / xscale;
+		dispatch->glUniform1f(pt_slope_uniform_location, slope);
+		dispatch->glUniform1i(hor_ver_uniform_location, 0);
+
+		cos_val = sqrt(1.0 / (slope * slope + 1.0));
+		dispatch->glUniform1f(cos_val_uniform_location, cos_val);
+
+		p1_distance = (pt1[1] - pt1[0] * slope) * cos_val;
+		pt_distance = (pt2[1] - pt2[0] * slope) * cos_val - p1_distance;
+		dispatch->glUniform1f(p1_distance_uniform_location, p1_distance);
+		dispatch->glUniform1f(pt_distance_uniform_location, pt_distance);
+	}
+
+	/* Now rendering. */
+	dispatch->glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+
+	/* Do the clear logic.*/
+	if (stops_count > LINEAR_SMALL_STOPS) {
+		free(n_stops);
+		free(stop_colors);
+	}
+
+	dispatch->glBindBuffer(GL_ARRAY_BUFFER, 0);
+	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
+	dispatch->glUseProgram(0);
+
+	glamor_put_dispatch(glamor_priv);
+	return dst_picture;
+
+GRADIENT_FAIL:
+	if (dst_picture) {
+		FreePicture(dst_picture, 0);
+	}
+
+	if (stops_count > LINEAR_SMALL_STOPS) {
+		if (n_stops)
+			free(n_stops);
+		if (stop_colors)
+			free(stop_colors);
+	}
+
+	dispatch->glBindBuffer(GL_ARRAY_BUFFER, 0);
+	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
+	dispatch->glUseProgram(0);
+	glamor_put_dispatch(glamor_priv);
+	return NULL;
+}
+
+#endif /* End of GLAMOR_GRADIENT_SHADER */
+
+#endif /* End of RENDER */
diff --git a/glamor_largepixmap.c b/glamor_largepixmap.c
new file mode 100644
index 0000000..f07095a
--- /dev/null
+++ b/glamor_largepixmap.c
@@ -0,0 +1,1336 @@
+#include <stdlib.h>
+
+#include "glamor_priv.h"
+
+/**
+ * Clip the boxes regards to each pixmap's block array.
+ *
+ * Should translate the region to relative coords to the pixmap,
+ * start at (0,0).
+ */
+#if 0
+//#define DEBUGF(str, ...)  do {} while(0)
+#define DEBUGF(str, ...) ErrorF(str, ##__VA_ARGS__)
+//#define DEBUGRegionPrint(x) do {} while (0)
+#define DEBUGRegionPrint RegionPrint
+#endif
+
+static glamor_pixmap_clipped_regions *
+__glamor_compute_clipped_regions(int block_w,
+			       int block_h,
+			       int block_stride,
+			       int x, int y,
+			       int w, int h,
+                               RegionPtr region,
+                               int *n_region,
+			       int reverse,
+			       int upsidedown)
+{
+	glamor_pixmap_clipped_regions * clipped_regions;
+	BoxPtr extent;
+	int start_x, start_y, end_x, end_y;
+	int start_block_x, start_block_y;
+	int end_block_x, end_block_y;
+	int loop_start_block_x, loop_start_block_y;
+	int loop_end_block_x, loop_end_block_y;
+	int loop_block_stride;
+	int i, j, delta_i, delta_j;
+	int width, height;
+	RegionRec temp_region;
+	RegionPtr current_region;
+	int block_idx;
+	int k = 0;
+	int temp_block_idx;
+
+	extent = RegionExtents(region);
+	start_x = MAX(x, extent->x1);
+	start_y = MAX(y, extent->y1);
+	end_x = MIN(x + w, extent->x2);
+	end_y = MIN(y + h, extent->y2);
+
+	DEBUGF("start compute clipped regions:\n");
+	DEBUGF("block w %d h %d  x %d y %d w %d h %d, block_stride %d \n",
+		block_w, block_h, x, y, w, h, block_stride);
+	DEBUGRegionPrint(region);
+
+	DEBUGF("start_x %d start_y %d end_x %d end_y %d \n", start_x, start_y, end_x, end_y);
+
+	if (start_x >= end_x || start_y >= end_y) {
+		*n_region = 0;
+		return NULL;
+	}
+
+	width = end_x - start_x;
+	height = end_y - start_y;
+	start_block_x = (start_x  - x)/ block_w;
+	start_block_y = (start_y - y)/ block_h;
+	end_block_x = (end_x - x)/ block_w;
+	end_block_y = (end_y - y)/ block_h;
+
+	clipped_regions = calloc((end_block_x - start_block_x + 1)
+				 * (end_block_y - start_block_y + 1),
+				 sizeof(*clipped_regions));
+
+
+	DEBUGF("startx %d starty %d endx %d endy %d \n",
+		start_x, start_y, end_x, end_y);
+	DEBUGF("start_block_x %d end_block_x %d \n", start_block_x, end_block_x);
+	DEBUGF("start_block_y %d end_block_y %d \n", start_block_y, end_block_y);
+
+	if (!reverse) {
+		loop_start_block_x = start_block_x;
+		loop_end_block_x = end_block_x + 1;
+		delta_i = 1;
+	} else {
+		loop_start_block_x = end_block_x;
+		loop_end_block_x = start_block_x - 1;
+		delta_i = -1;
+	}
+
+	if (!upsidedown) {
+		loop_start_block_y = start_block_y;
+		loop_end_block_y = end_block_y + 1;
+		delta_j = 1;
+	} else {
+		loop_start_block_y = end_block_y;
+		loop_end_block_y = start_block_y - 1;
+		delta_j = -1;
+	}
+
+	loop_block_stride = delta_j * block_stride;
+	block_idx = (loop_start_block_y - delta_j) * block_stride;
+
+	for(j = loop_start_block_y; j != loop_end_block_y; j += delta_j)
+	{
+		block_idx += loop_block_stride;
+		temp_block_idx = block_idx + loop_start_block_x;
+		for(i = loop_start_block_x;
+		    i != loop_end_block_x; i += delta_i, temp_block_idx += delta_i)
+		{
+			BoxRec temp_box;
+			temp_box.x1 = x + i * block_w;
+			temp_box.y1 = y + j * block_h;
+			temp_box.x2 = MIN(temp_box.x1 + block_w, end_x);
+			temp_box.y2 = MIN(temp_box.y1 + block_h, end_y);
+			RegionInitBoxes(&temp_region, &temp_box, 1);
+			DEBUGF("block idx %d \n",temp_block_idx);
+			DEBUGRegionPrint(&temp_region);
+			current_region = RegionCreate(NULL, 4);
+			RegionIntersect(current_region, &temp_region, region);
+			DEBUGF("i %d j %d  region: \n",i ,j);
+			DEBUGRegionPrint(current_region);
+			if (RegionNumRects(current_region)) {
+				clipped_regions[k].region = current_region;
+				clipped_regions[k].block_idx = temp_block_idx;
+				k++;
+			} else
+				RegionDestroy(current_region);
+			RegionUninit(&temp_region);
+		}
+	}
+
+	*n_region = k;
+	return clipped_regions;
+}
+
+/**
+ * Do a two round clipping,
+ * first is to clip the region regard to current pixmap's
+ * block array. Then for each clipped region, do a inner
+ * block clipping. This is to make sure the final result
+ * will be shapped by inner_block_w and inner_block_h, and
+ * the final region also will not cross the pixmap's block
+ * boundary.
+ *
+ * This is mainly used by transformation support when do
+ * compositing.
+ */
+
+glamor_pixmap_clipped_regions *
+glamor_compute_clipped_regions_ext(glamor_pixmap_private *pixmap_priv,
+				   RegionPtr region,
+				   int *n_region,
+				   int inner_block_w, int inner_block_h,
+				   int reverse, int upsidedown)
+{
+	glamor_pixmap_clipped_regions * clipped_regions, *inner_regions, *result_regions;
+	int i, j, x, y, k, inner_n_regions;
+	int width, height;
+	glamor_pixmap_private_large_t *priv;
+	priv = &pixmap_priv->large;
+
+	DEBUGF("ext called \n");
+
+	if (pixmap_priv->type != GLAMOR_TEXTURE_LARGE) {
+		clipped_regions = calloc(1, sizeof(*clipped_regions));
+		if (clipped_regions == NULL) {
+			*n_region = 0;
+			return NULL;
+		}
+		clipped_regions[0].region = RegionCreate(NULL, 1);
+		clipped_regions[0].block_idx = 0;
+		RegionCopy(clipped_regions[0].region, region);
+		*n_region = 1;
+		priv->block_w = priv->base.pixmap->drawable.width;
+		priv->block_h = priv->base.pixmap->drawable.height;
+		priv->box_array = &priv->box;
+		priv->box.x1 = priv->box.y1 = 0;
+		priv->box.x2 = priv->block_w;
+		priv->box.y2 = priv->block_h;
+	} else {
+		clipped_regions =  __glamor_compute_clipped_regions(priv->block_w,
+					priv->block_h,
+					priv->block_wcnt,
+					0, 0,
+					priv->base.pixmap->drawable.width,
+					priv->base.pixmap->drawable.height,
+					region, n_region, reverse, upsidedown
+					);
+
+		if (clipped_regions == NULL) {
+			*n_region = 0;
+			return NULL;
+		}
+	}
+	if (inner_block_w >= priv->block_w
+	    && inner_block_h >= priv->block_h)
+		return clipped_regions;
+	result_regions = calloc(*n_region
+				* ((priv->block_w + inner_block_w - 1)/inner_block_w)
+				* ((priv->block_h + inner_block_h - 1)/ inner_block_h),
+				sizeof(*result_regions));
+	k = 0;
+	for(i = 0; i < *n_region; i++)
+	{
+		x = priv->box_array[clipped_regions[i].block_idx].x1;
+		y = priv->box_array[clipped_regions[i].block_idx].y1;
+		width = priv->box_array[clipped_regions[i].block_idx].x2 - x;
+		height = priv->box_array[clipped_regions[i].block_idx].y2 - y;
+		inner_regions = __glamor_compute_clipped_regions(inner_block_w,
+					inner_block_h,
+					0, x, y,
+					width,
+					height,
+					clipped_regions[i].region,
+					&inner_n_regions, reverse, upsidedown);
+		for(j = 0; j < inner_n_regions; j++)
+		{
+			result_regions[k].region = inner_regions[j].region;
+			result_regions[k].block_idx = clipped_regions[i].block_idx;
+			k++;
+		}
+		free(inner_regions);
+	}
+	*n_region = k;
+	free(clipped_regions);
+	return result_regions;
+}
+
+/*
+ *
+ * For the repeat pad mode, we can simply convert the region and
+ * let the out-of-box region can cover the needed edge of the source/mask
+ * Then apply a normal clip we can get what we want.
+ */
+static RegionPtr
+_glamor_convert_pad_region(RegionPtr region, int w, int h)
+{
+	RegionPtr pad_region;
+	int nrect;
+	BoxPtr box;
+	int overlap;
+
+	nrect = RegionNumRects(region);
+	box = RegionRects(region);
+	pad_region = RegionCreate(NULL, 4);
+	if (pad_region == NULL)
+		return NULL;
+	while(nrect--) {
+		BoxRec pad_box;
+		RegionRec temp_region;
+		pad_box = *box;
+		if (pad_box.x1 < 0 && pad_box.x2 <= 0)
+			pad_box.x2 = 1;
+		else if (pad_box.x1 >= w && pad_box.x2 > w)
+			pad_box.x1 = w - 1;
+		if (pad_box.y1 < 0 && pad_box.y2 <=0)
+			pad_box.y2 = 1;
+		else if (pad_box.y1 >= h && pad_box.y2 > h)
+			pad_box.y1 = h - 1;
+		RegionInitBoxes(&temp_region, &pad_box, 1);
+		RegionAppend(pad_region, &temp_region);
+		RegionUninit(&temp_region);
+		box++;
+	}
+	RegionValidate(pad_region, &overlap);
+	return pad_region;
+}
+
+/*
+ * For one type of large pixmap, its one direction is not exceed the
+ * size limitation, and in another word, on one direction it has only
+ * one block.
+ *
+ * This case of reflect repeating, we can optimize it and avoid repeat
+ * clip on that direction. We can just enlarge the repeat box and can
+ * cover all the dest region on that direction. But latter, we need to
+ * fixup the clipped result to get a correct coords for the subsequent
+ * processing. This function is to do the coords correction.
+ *
+ * */
+static void
+_glamor_largepixmap_reflect_fixup(short *xy1, short *xy2, int wh)
+{
+	int odd1, odd2;
+	int c1, c2;
+
+	if (*xy2 - *xy1 > wh) {
+		*xy1 = 0;
+		*xy2 = wh;
+		return;
+	}
+	modulus(*xy1, wh, c1);
+	odd1 = ((*xy1 - c1) / wh) & 0x1;
+	modulus(*xy2, wh, c2);
+	odd2 = ((*xy2 - c2) / wh) & 0x1;
+
+	if (odd1 && odd2) {
+		*xy1 = wh - c2;
+		*xy2 = wh - c1;
+	} else if (odd1 && !odd2) {
+		*xy1 = 0;
+		*xy2 = MAX(c2, wh - c1);
+	} else if (!odd1 && odd2) {
+		*xy2 = wh;
+		*xy1 = MIN(c1, wh - c2);
+	} else {
+		*xy1 = c1;
+		*xy2 = c2;
+	}
+}
+
+/**
+ * Clip the boxes regards to each pixmap's block array.
+ *
+ * Should translate the region to relative coords to the pixmap,
+ * start at (0,0).
+ *
+ * @is_transform: if it is set, it has a transform matrix.
+ *
+ */
+static glamor_pixmap_clipped_regions *
+_glamor_compute_clipped_regions(glamor_pixmap_private *pixmap_priv,
+				RegionPtr region, int *n_region,
+				int repeat_type, int is_transform,
+				int reverse, int upsidedown)
+{
+	glamor_pixmap_clipped_regions * clipped_regions;
+	BoxPtr extent;
+	int i, j;
+	int width, height;
+	RegionPtr current_region;
+	int pixmap_width, pixmap_height;
+	int m;
+	BoxRec repeat_box;
+	RegionRec repeat_region;
+	int right_shift = 0;
+	int down_shift = 0;
+	int x_center_shift = 0, y_center_shift = 0;
+	glamor_pixmap_private_large_t *priv;
+	priv = &pixmap_priv->large;
+
+	DEBUGRegionPrint(region);
+	if (pixmap_priv->type != GLAMOR_TEXTURE_LARGE) {
+		clipped_regions = calloc(1, sizeof(*clipped_regions));
+		clipped_regions[0].region = RegionCreate(NULL, 1);
+		clipped_regions[0].block_idx = 0;
+		RegionCopy(clipped_regions[0].region, region);
+		*n_region = 1;
+		return clipped_regions;
+	}
+
+	pixmap_width = priv->base.pixmap->drawable.width;
+	pixmap_height = priv->base.pixmap->drawable.height;
+	if (repeat_type == 0 || repeat_type == RepeatPad) {
+		RegionPtr saved_region = NULL;
+		if (repeat_type == RepeatPad) {
+			saved_region = region;
+			region = _glamor_convert_pad_region(saved_region, pixmap_width, pixmap_height);
+			if (region == NULL) {
+				*n_region = 0;
+				return NULL;
+			}
+		}
+		clipped_regions = __glamor_compute_clipped_regions(priv->block_w,
+							priv->block_h,
+							priv->block_wcnt,
+							0, 0,
+							priv->base.pixmap->drawable.width,
+							priv->base.pixmap->drawable.height,
+							region, n_region, reverse, upsidedown
+							);
+		if (saved_region)
+			RegionDestroy(region);
+		return clipped_regions;
+	}
+	extent = RegionExtents(region);
+
+	x_center_shift = extent->x1 / pixmap_width;
+	if (x_center_shift < 0)
+		x_center_shift--;
+	if (abs(x_center_shift) & 1)
+		x_center_shift++;
+	y_center_shift = extent->y1 / pixmap_height;
+	if (y_center_shift < 0)
+		y_center_shift--;
+	if (abs(y_center_shift) & 1)
+		y_center_shift++;
+
+	if (extent->x1 < 0)
+		right_shift = ((-extent->x1 + pixmap_width - 1) / pixmap_width );
+	if (extent->y1 < 0)
+		down_shift = ((-extent->y1 + pixmap_height - 1) / pixmap_height );
+
+	if (right_shift != 0 || down_shift != 0) {
+		if (repeat_type == RepeatReflect) {
+			right_shift = (right_shift + 1)&~1;
+			down_shift = (down_shift + 1)&~1;
+		}
+		RegionTranslate(region, right_shift * pixmap_width, down_shift * pixmap_height);
+	}
+
+	extent = RegionExtents(region);
+	width = extent->x2 - extent->x1;
+	height = extent->y2 - extent->y1;
+	/* Tile a large pixmap to another large pixmap.
+	 * We can't use the target large pixmap as the
+	 * loop variable, instead we need to loop for all
+	 * the blocks in the tile pixmap.
+	 *
+	 * simulate repeat each single block to cover the
+	 * target's blocks. Two special case:
+	 * a block_wcnt == 1 or block_hcnt ==1, then we
+	 * only need to loop one direction as the other
+	 * direction is fully included in the first block.
+	 *
+	 * For the other cases, just need to start
+	 * from a proper shiftx/shifty, and then increase
+	 * y by tile_height each time to walk trhough the
+	 * target block and then walk trhough the target
+	 * at x direction by increate tile_width each time.
+	 *
+	 * This way, we can consolidate all the sub blocks
+	 * of the target boxes into one tile source's block.
+	 *
+	 * */
+	m = 0;
+	clipped_regions = calloc(priv->block_wcnt * priv->block_hcnt,
+				 sizeof(*clipped_regions));
+	if (clipped_regions == NULL) {
+		*n_region = 0;
+		return NULL;
+	}
+	if (right_shift != 0 || down_shift != 0) {
+		DEBUGF("region to be repeated shifted \n");
+		DEBUGRegionPrint(region);
+	}
+	DEBUGF("repeat pixmap width %d height %d \n", pixmap_width, pixmap_height);
+	DEBUGF("extent x1 %d y1 %d x2 %d y2 %d \n", extent->x1, extent->y1, extent->x2, extent->y2);
+	for(j = 0; j < priv->block_hcnt; j++)
+	{
+		for(i = 0; i < priv->block_wcnt; i++)
+		{
+			int dx = pixmap_width;
+			int dy = pixmap_height;
+			int idx;
+			int shift_x;
+			int shift_y;
+			int saved_y1, saved_y2;
+			int x_idx = 0, y_idx = 0, saved_y_idx = 0;
+			RegionRec temp_region;
+			BoxRec reflect_repeat_box;
+			BoxPtr valid_repeat_box;
+
+			shift_x = (extent->x1 / pixmap_width) * pixmap_width;
+			shift_y = (extent->y1 / pixmap_height) * pixmap_height;
+			idx = j * priv->block_wcnt + i;
+			if (repeat_type == RepeatReflect) {
+				x_idx = (extent->x1 / pixmap_width);
+				y_idx = (extent->y1 / pixmap_height);
+			}
+
+			/* Construct a rect to clip the target region. */
+			repeat_box.x1 = shift_x + priv->box_array[idx].x1;
+			repeat_box.y1 = shift_y + priv->box_array[idx].y1;
+			if (priv->block_wcnt == 1)
+				repeat_box.x2 = extent->x2;
+			else
+				repeat_box.x2 = shift_x + priv->box_array[idx].x2;
+			if (priv->block_hcnt == 1)
+				repeat_box.y2 = extent->y2;
+			else
+				repeat_box.y2 = shift_y + priv->box_array[idx].y2;
+
+			current_region = RegionCreate(NULL, 4);
+			RegionInit(&temp_region, NULL, 4);
+			DEBUGF("init repeat box %d %d %d %d \n",
+				repeat_box.x1, repeat_box.y1, repeat_box.x2, repeat_box.y2);
+
+			if (repeat_type == RepeatNormal) {
+				saved_y1 = repeat_box.y1;
+				saved_y2 = repeat_box.y2;
+				for(; repeat_box.x1 < extent->x2;
+				      repeat_box.x1 += dx, repeat_box.x2 += dx)
+				{
+					repeat_box.y1 = saved_y1;
+					repeat_box.y2 = saved_y2;
+					for( repeat_box.y1 = saved_y1, repeat_box.y2 = saved_y2;
+					     repeat_box.y1 < extent->y2;
+					     repeat_box.y1 += dy, repeat_box.y2 += dy)
+					{
+
+						RegionInitBoxes(&repeat_region, &repeat_box, 1);
+						DEBUGF("Start to clip repeat region: \n");
+						DEBUGRegionPrint(&repeat_region);
+						RegionIntersect(&temp_region, &repeat_region, region);
+						DEBUGF("clip result:\n");
+						DEBUGRegionPrint(&temp_region);
+						RegionAppend(current_region, &temp_region);
+						RegionUninit(&repeat_region);
+					}
+				}
+			} else if (repeat_type == RepeatReflect) {
+				saved_y1 = repeat_box.y1;
+				saved_y2 = repeat_box.y2;
+				saved_y_idx = y_idx;
+				for(; ; repeat_box.x1 += dx, repeat_box.x2 += dx)
+				{
+					repeat_box.y1 = saved_y1;
+					repeat_box.y2 = saved_y2;
+					y_idx = saved_y_idx;
+					reflect_repeat_box.x1 = (x_idx & 1) ?
+								((2 * x_idx + 1) * dx - repeat_box.x2) : repeat_box.x1;
+					reflect_repeat_box.x2 = (x_idx & 1) ?
+								((2 * x_idx + 1) * dx - repeat_box.x1) : repeat_box.x2;
+					valid_repeat_box = &reflect_repeat_box;
+
+					if (valid_repeat_box->x1 >= extent->x2)
+						break;
+					for( repeat_box.y1 = saved_y1, repeat_box.y2 = saved_y2;
+					     ;
+					     repeat_box.y1 += dy, repeat_box.y2 += dy)
+					{
+
+						DEBUGF("x_idx %d y_idx %d dx %d dy %d\n", x_idx, y_idx, dx, dy);
+						DEBUGF("repeat box %d %d %d %d \n",
+							repeat_box.x1, repeat_box.y1, repeat_box.x2, repeat_box.y2);
+
+						if (priv->block_hcnt > 1) {
+						reflect_repeat_box.y1 = (y_idx & 1) ?
+							((2 * y_idx + 1) * dy - repeat_box.y2) : repeat_box.y1;
+						reflect_repeat_box.y2 = (y_idx & 1) ?
+							((2 * y_idx + 1) * dy - repeat_box.y1) : repeat_box.y2;
+						} else {
+						reflect_repeat_box.y1 = repeat_box.y1;
+						reflect_repeat_box.y2 = repeat_box.y2;
+						}
+
+						DEBUGF("valid_repeat_box x1 %d y1 %d \n",
+							valid_repeat_box->x1, valid_repeat_box->y1);
+						if (valid_repeat_box->y1 >= extent->y2)
+							break;
+						RegionInitBoxes(&repeat_region, valid_repeat_box, 1);
+						DEBUGF("start to clip repeat[reflect] region: \n");
+						DEBUGRegionPrint(&repeat_region);
+						RegionIntersect(&temp_region, &repeat_region, region);
+						DEBUGF("result:\n");
+						DEBUGRegionPrint(&temp_region);
+						if (is_transform && RegionNumRects(&temp_region)) {
+							BoxRec temp_box;
+							BoxPtr temp_extent;
+							temp_extent = RegionExtents(&temp_region);
+							if (priv->block_wcnt > 1) {
+								if (x_idx & 1) {
+									temp_box.x1 = ((2 * x_idx + 1)*dx - temp_extent->x2);
+									temp_box.x2 = ((2 * x_idx + 1)*dx - temp_extent->x1);
+								} else {
+									temp_box.x1 = temp_extent->x1;
+									temp_box.x2 = temp_extent->x2;
+								}
+								modulus(temp_box.x1, pixmap_width, temp_box.x1);
+								modulus(temp_box.x2, pixmap_width, temp_box.x2);
+								if (temp_box.x2 == 0) temp_box.x2 = pixmap_width;
+							} else {
+								temp_box.x1 = temp_extent->x1;
+								temp_box.x2 = temp_extent->x2;
+								_glamor_largepixmap_reflect_fixup(&temp_box.x1, &temp_box.x2, pixmap_width);
+							}
+
+							if (priv->block_hcnt > 1) {
+								if (y_idx & 1) {
+									temp_box.y1 = ((2 * y_idx + 1)*dy - temp_extent->y2);
+									temp_box.y2 = ((2 * y_idx + 1)*dy - temp_extent->y1);
+								} else {
+									temp_box.y1 = temp_extent->y1;
+									temp_box.y2 = temp_extent->y2;
+								}
+
+								modulus(temp_box.y1, pixmap_height, temp_box.y1);
+								modulus(temp_box.y2, pixmap_height, temp_box.y2);
+								if (temp_box.y2 == 0) temp_box.y2 = pixmap_height;
+							} else {
+								temp_box.y1 = temp_extent->y1;
+								temp_box.y2 = temp_extent->y2;
+								_glamor_largepixmap_reflect_fixup(&temp_box.y1, &temp_box.y2, pixmap_height);
+							}
+
+							RegionInitBoxes(&temp_region, &temp_box, 1);
+							RegionTranslate(&temp_region, x_center_shift * pixmap_width, y_center_shift * pixmap_height);
+							DEBUGF("for transform result:\n");
+							DEBUGRegionPrint(&temp_region);
+						}
+						RegionAppend(current_region, &temp_region);
+						RegionUninit(&repeat_region);
+						y_idx++;
+					}
+					x_idx++;
+				}
+			}
+			DEBUGF("dx %d dy %d \n", dx, dy);
+
+			if (RegionNumRects(current_region)) {
+
+				if ((right_shift != 0 || down_shift != 0) && !(is_transform && repeat_type == RepeatReflect))
+					RegionTranslate(current_region,
+							-right_shift * pixmap_width,
+							-down_shift * pixmap_height);
+				clipped_regions[m].region = current_region;
+				clipped_regions[m].block_idx = idx;
+				m++;
+			} else
+				RegionDestroy(current_region);
+			RegionUninit(&temp_region);
+		}
+	}
+
+	if (right_shift != 0 || down_shift != 0)
+		RegionTranslate(region, -right_shift * pixmap_width, -down_shift * pixmap_height);
+	*n_region = m;
+
+	return clipped_regions;
+}
+
+glamor_pixmap_clipped_regions *
+glamor_compute_clipped_regions(glamor_pixmap_private *priv, RegionPtr region,
+			       int *n_region, int repeat_type,
+			       int reverse, int upsidedown)
+{
+	return _glamor_compute_clipped_regions(priv, region, n_region, repeat_type, 0, reverse, upsidedown);
+}
+
+/* XXX overflow still exist. maybe we need to change to use region32.
+ * by default. Or just use region32 for repeat cases?
+ **/
+glamor_pixmap_clipped_regions *
+glamor_compute_transform_clipped_regions(glamor_pixmap_private *priv, struct pixman_transform *transform,
+					 RegionPtr region, int *n_region, int dx, int dy, int repeat_type,
+					 int reverse, int upsidedown)
+{
+	BoxPtr temp_extent;
+	struct pixman_box32 temp_box;
+	struct pixman_box16 short_box;
+	RegionPtr temp_region;
+	glamor_pixmap_clipped_regions *ret;
+
+	temp_region = RegionCreate(NULL, 4);
+	temp_extent = RegionExtents(region);
+	DEBUGF("dest region \n");
+	DEBUGRegionPrint(region);
+	/* dx/dy may exceed MAX SHORT. we have to use
+	 * a box32 to represent it.*/
+	temp_box.x1 = temp_extent->x1 + dx;
+	temp_box.x2 = temp_extent->x2 + dx;
+	temp_box.y1 = temp_extent->y1 + dy;
+	temp_box.y2 = temp_extent->y2 + dy;
+
+	DEBUGF("source box %d %d %d %d \n", temp_box.x1, temp_box.y1, temp_box.x2, temp_box.y2);
+	if (transform)
+		glamor_get_transform_extent_from_box(&temp_box, transform);
+	if (repeat_type == RepeatNone) {
+		if (temp_box.x1 < 0) temp_box.x1 = 0;
+		if (temp_box.y1 < 0) temp_box.y1 = 0;
+		temp_box.x2 = MIN(temp_box.x2, priv->base.pixmap->drawable.width);
+		temp_box.y2 = MIN(temp_box.y2, priv->base.pixmap->drawable.height);
+	}
+	/* Now copy back the box32 to a box16 box. */
+	short_box.x1 = temp_box.x1;
+	short_box.y1 = temp_box.y1;
+	short_box.x2 = temp_box.x2;
+	short_box.y2 = temp_box.y2;
+	RegionInitBoxes(temp_region, &short_box, 1);
+	DEBUGF("copy to temp source region \n");
+	DEBUGRegionPrint(temp_region);
+	ret = _glamor_compute_clipped_regions(priv,
+					      temp_region,
+					      n_region,
+					      repeat_type,
+					      1, reverse,
+					      upsidedown);
+	DEBUGF("n_regions = %d \n", *n_region);
+	RegionDestroy(temp_region);
+
+	return ret;
+}
+/*
+ * As transform and repeatpad mode.
+ * We may get a clipped result which in multipe regions.
+ * It's not easy to do a 2nd round clipping just as we do
+ * without transform/repeatPad. As it's not easy to reverse
+ * the 2nd round clipping result with a transform/repeatPad mode,
+ * or even impossible for some transformation.
+ *
+ * So we have to merge the fragmental region into one region
+ * if the clipped result cross the region boundary.
+ */
+static void
+glamor_merge_clipped_regions(glamor_pixmap_private *pixmap_priv, int repeat_type,
+			     glamor_pixmap_clipped_regions *clipped_regions,
+			     int *n_regions, int *need_clean_fbo)
+{
+	BoxPtr temp_extent;
+	BoxRec temp_box, copy_box;
+	RegionPtr temp_region;
+	glamor_pixmap_private *temp_priv;
+	PixmapPtr temp_pixmap;
+	int overlap;
+	int i;
+	int pixmap_width, pixmap_height;
+	glamor_pixmap_private_large_t *priv;
+
+	priv = &pixmap_priv->large;
+	pixmap_width = priv->base.pixmap->drawable.width;
+	pixmap_height = priv->base.pixmap->drawable.height;
+
+	temp_region = RegionCreate(NULL, 4);
+	for(i = 0; i < *n_regions; i++)
+	{
+		DEBUGF("Region %d:\n", i);
+		DEBUGRegionPrint(clipped_regions[i].region);
+		RegionAppend(temp_region, clipped_regions[i].region);
+	}
+
+	RegionValidate(temp_region, &overlap);
+	DEBUGF("temp region: \n");
+	DEBUGRegionPrint(temp_region);
+	temp_extent = RegionExtents(temp_region);
+
+	temp_box = *temp_extent;
+
+	DEBUGF("need copy region: \n");
+	DEBUGF("%d %d %d %d \n", temp_box.x1, temp_box.y1, temp_box.x2, temp_box.y2);
+	temp_pixmap = glamor_create_pixmap(priv->base.pixmap->drawable.pScreen,
+					  temp_box.x2 - temp_box.x1,
+					  temp_box.y2 - temp_box.y1,
+					  priv->base.pixmap->drawable.depth,
+					  GLAMOR_CREATE_PIXMAP_FIXUP);
+	if (temp_pixmap == NULL) {
+		assert(0);
+		return;
+	}
+
+	temp_priv = glamor_get_pixmap_private(temp_pixmap);
+	assert(temp_priv->type != GLAMOR_TEXTURE_LARGE);
+
+	priv->box = temp_box;
+	if (temp_extent->x1 >= 0 && temp_extent->x2 <= pixmap_width
+	    && temp_extent->y1 >= 0 && temp_extent->y2 <= pixmap_height) {
+		int dx, dy;
+		copy_box.x1 = 0;
+		copy_box.y1 = 0;
+		copy_box.x2 = temp_extent->x2 - temp_extent->x1;
+		copy_box.y2 = temp_extent->y2 - temp_extent->y1;
+		dx = temp_extent->x1;
+		dy = temp_extent->y1;
+		glamor_copy_n_to_n(&priv->base.pixmap->drawable,
+				   &temp_pixmap->drawable,
+				   NULL, &copy_box, 1, dx,
+				   dy, 0, 0, 0, NULL);
+//		glamor_solid(temp_pixmap, 0, 0, temp_pixmap->drawable.width,
+//			       temp_pixmap->drawable.height, GXcopy, 0xffffffff, 0xff00);
+	} else {
+		for (i = 0; i < *n_regions; i++)
+		{
+			BoxPtr box;
+			int nbox;
+			box = REGION_RECTS(clipped_regions[i].region);
+			nbox = REGION_NUM_RECTS(clipped_regions[i].region);
+			while(nbox--) {
+				int dx, dy, c, d;
+				DEBUGF("box x1 %d y1 %d x2 %d y2 %d \n",
+					box->x1, box->y1, box->x2, box->y2);
+				modulus(box->x1, pixmap_width, c);
+				dx = c - (box->x1 - temp_box.x1);
+				copy_box.x1 = box->x1 - temp_box.x1;
+				copy_box.x2 = box->x2 - temp_box.x1;
+
+				modulus(box->y1, pixmap_height, d);
+				dy = d - (box->y1 - temp_box.y1);
+				copy_box.y1 = box->y1 - temp_box.y1;
+				copy_box.y2 = box->y2 - temp_box.y1;
+
+				DEBUGF("copying box %d %d %d %d, dx %d dy %d\n",
+					copy_box.x1, copy_box.y1, copy_box.x2,
+					copy_box.y2, dx, dy);
+
+				glamor_copy_n_to_n(&priv->base.pixmap->drawable,
+						   &temp_pixmap->drawable,
+						   NULL, &copy_box, 1, dx,
+						   dy, 0, 0, 0, NULL);
+				box++;
+			}
+		}
+		//glamor_solid(temp_pixmap, 0, 0, temp_pixmap->drawable.width,
+		//	       temp_pixmap->drawable.height, GXcopy, 0xffffffff, 0xff);
+	}
+	/* The first region will be released at caller side. */
+	for(i = 1; i < *n_regions; i++)
+		RegionDestroy(clipped_regions[i].region);
+	RegionDestroy(temp_region);
+	priv->box = temp_box;
+	priv->base.fbo = glamor_pixmap_detach_fbo(temp_priv);
+	DEBUGF("priv box x1 %d y1 %d x2 %d y2 %d \n",
+		priv->box.x1, priv->box.y1, priv->box.x2, priv->box.y2);
+	glamor_destroy_pixmap(temp_pixmap);
+	*need_clean_fbo = 1;
+	*n_regions = 1;
+}
+
+
+
+/**
+ * Given an expected transformed block width and block height,
+ *
+ * This function calculate a new block width and height which
+ * guarantee the transform result will not exceed the given
+ * block width and height.
+ *
+ * For large block width and height (> 2048), we choose a
+ * smaller new width and height and to reduce the cross region
+ * boundary and can avoid some overhead.
+ *
+ **/
+Bool
+glamor_get_transform_block_size(struct pixman_transform *transform,
+			   int block_w, int block_h,
+			   int *transformed_block_w,
+			   int *transformed_block_h)
+{
+	double a,b,c,d,e,f,g,h;
+	double scale;
+	int width, height;
+	a = pixman_fixed_to_double(transform->matrix[0][0]);
+	b = pixman_fixed_to_double(transform->matrix[0][1]);
+	c = pixman_fixed_to_double(transform->matrix[1][0]);
+	d = pixman_fixed_to_double(transform->matrix[1][1]);
+	scale = pixman_fixed_to_double(transform->matrix[2][2]);
+	if (block_w > 2048) {
+	/* For large block size, we shrink it to smaller box,
+	 * thus latter we may get less cross boundary regions and
+	 * thus can avoid some extra copy.
+	 *
+	 **/
+		width = block_w  / 4;
+		height = block_h / 4;
+	} else {
+		width = block_w - 2;
+		height = block_h - 2;
+	}
+	e = a + b;
+	f = c + d;
+
+	g = a - b;
+	h = c - d;
+
+	e = MIN(block_w, floor(width * scale) / MAX(fabs(e), fabs(g)));
+	f = MIN(block_h, floor(height * scale) / MAX(fabs(f), fabs(h)));
+	*transformed_block_w = MIN(e, f) - 1;
+	*transformed_block_h = *transformed_block_w;
+	if (*transformed_block_w <= 0 || *transformed_block_h <= 0)
+		return FALSE;
+	DEBUGF("original block_w/h %d %d, fixed %d %d \n", block_w, block_h,
+		*transformed_block_w, *transformed_block_h);
+	return TRUE;
+}
+
+#define VECTOR_FROM_POINT(p, x, y)	\
+	p.v[0] = x;  \
+	p.v[1] = y;  \
+	p.v[2] = 1.0;
+void
+glamor_get_transform_extent_from_box(struct pixman_box32 *box,
+		struct pixman_transform *transform)
+{
+	struct pixman_f_vector p0, p1, p2, p3;
+	float min_x, min_y, max_x, max_y;
+
+	struct pixman_f_transform ftransform;
+
+	VECTOR_FROM_POINT(p0, box->x1, box->y1)
+	VECTOR_FROM_POINT(p1, box->x2, box->y1)
+	VECTOR_FROM_POINT(p2, box->x2, box->y2)
+	VECTOR_FROM_POINT(p3, box->x1, box->y2)
+
+	pixman_f_transform_from_pixman_transform(&ftransform, transform);
+	pixman_f_transform_point(&ftransform, &p0);
+	pixman_f_transform_point(&ftransform, &p1);
+	pixman_f_transform_point(&ftransform, &p2);
+	pixman_f_transform_point(&ftransform, &p3);
+
+	min_x = MIN(p0.v[0], p1.v[0]);
+	min_x = MIN(min_x, p2.v[0]);
+	min_x = MIN(min_x, p3.v[0]);
+
+	min_y = MIN(p0.v[1], p1.v[1]);
+	min_y = MIN(min_y, p2.v[1]);
+	min_y = MIN(min_y, p3.v[1]);
+
+	max_x = MAX(p0.v[0], p1.v[0]);
+	max_x = MAX(max_x, p2.v[0]);
+	max_x = MAX(max_x, p3.v[0]);
+
+	max_y = MAX(p0.v[1], p1.v[1]);
+	max_y = MAX(max_y, p2.v[1]);
+	max_y = MAX(max_y, p3.v[1]);
+	box->x1 = floor(min_x) - 1;
+	box->y1 = floor(min_y) - 1;
+	box->x2 = ceil(max_x) + 1;
+	box->y2 = ceil(max_y) + 1;
+}
+
+static void
+_glamor_process_transformed_clipped_region(glamor_pixmap_private *priv,
+					int repeat_type,
+					glamor_pixmap_clipped_regions *clipped_regions,
+					int *n_regions, int *need_clean_fbo)
+{
+	int shift_x, shift_y;
+	if (*n_regions != 1) {
+	/* Merge all source regions into one region. */
+		glamor_merge_clipped_regions(priv, repeat_type,
+					     clipped_regions, n_regions,
+					     need_clean_fbo);
+	} else {
+		SET_PIXMAP_FBO_CURRENT(priv,
+				       clipped_regions[0].block_idx);
+		if (repeat_type == RepeatReflect || repeat_type == RepeatNormal) {
+			/* The required source areas are in one region,
+			 * we need to shift the corresponding box's coords to proper position,
+			 * thus we can calculate the relative coords correctly.*/
+			BoxPtr temp_box;
+			int rem;
+			temp_box = RegionExtents(clipped_regions[0].region);
+			modulus(temp_box->x1, priv->base.pixmap->drawable.width, rem);
+			shift_x = (temp_box->x1 - rem) / priv->base.pixmap->drawable.width;
+			modulus(temp_box->y1, priv->base.pixmap->drawable.height, rem);
+			shift_y = (temp_box->y1 - rem) / priv->base.pixmap->drawable.height;
+
+			if (shift_x != 0) {
+				priv->large.box.x1 += shift_x * priv->base.pixmap->drawable.width;
+				priv->large.box.x2 += shift_x * priv->base.pixmap->drawable.width;
+			}
+			if (shift_y != 0) {
+				priv->large.box.y1 += shift_y * priv->base.pixmap->drawable.height;
+				priv->large.box.y2 += shift_y * priv->base.pixmap->drawable.height;
+			}
+		}
+	}
+}
+
+
+Bool
+glamor_composite_largepixmap_region(CARD8 op,
+			  PicturePtr source,
+			  PicturePtr mask,
+			  PicturePtr dest,
+			  glamor_pixmap_private * source_pixmap_priv,
+			  glamor_pixmap_private * mask_pixmap_priv,
+			  glamor_pixmap_private * dest_pixmap_priv,
+			  RegionPtr region, Bool force_clip,
+			  INT16 x_source,
+			  INT16 y_source,
+			  INT16 x_mask,
+			  INT16 y_mask,
+			  INT16 x_dest, INT16 y_dest,
+			  CARD16 width, CARD16 height)
+{
+	glamor_screen_private *glamor_priv;
+	glamor_pixmap_clipped_regions *clipped_dest_regions;
+	glamor_pixmap_clipped_regions *clipped_source_regions;
+	glamor_pixmap_clipped_regions *clipped_mask_regions;
+	int n_dest_regions;
+	int n_mask_regions;
+	int n_source_regions;
+	int i,j,k;
+	int need_clean_source_fbo = 0;
+	int need_clean_mask_fbo = 0;
+	int is_normal_source_fbo = 0;
+	int is_normal_mask_fbo = 0;
+	int fixed_block_width, fixed_block_height;
+	int null_source, null_mask;
+	glamor_pixmap_private * need_free_source_pixmap_priv = NULL;
+	glamor_pixmap_private * need_free_mask_pixmap_priv = NULL;
+	int source_repeat_type = 0, mask_repeat_type = 0;
+	PixmapPtr source_pixmap = NULL;
+	PixmapPtr mask_pixmap = NULL;
+	int ok = TRUE;
+
+	if (source_pixmap_priv)
+		source_pixmap = source_pixmap_priv->base.pixmap;
+
+	if (mask_pixmap_priv)
+		mask_pixmap = mask_pixmap_priv->base.pixmap;
+
+	if (source->repeat)
+		source_repeat_type = source->repeatType;
+	else
+		source_repeat_type = RepeatNone;
+
+	if (mask && mask->repeat)
+		mask_repeat_type = mask->repeatType;
+	else
+		mask_repeat_type = RepeatNone;
+
+	glamor_priv = dest_pixmap_priv->base.glamor_priv;
+	fixed_block_width = glamor_priv->max_fbo_size;
+	fixed_block_height = glamor_priv->max_fbo_size;
+	/* If we got an totally out-of-box region for a source or mask
+	 * region without repeat, we need to set it as null_source and
+	 * give it a solid color (0,0,0,0). */
+	null_source = 0;
+	null_mask = 0;
+	RegionTranslate(region, -dest->pDrawable->x,
+			-dest->pDrawable->y);
+
+	/* need to transform the dest region to the correct sourcei/mask region.
+	 * it's a little complex, as one single edge of the
+	 * target region may be transformed to cross a block boundary of the
+	 * source or mask. Then it's impossible to handle it as usual way.
+	 * We may have to split the original dest region to smaller region, and
+	 * make sure each region's transformed region can fit into one texture,
+	 * and then continue this loop again, and each time when a transformed region
+	 * cross the bound, we need to copy it to a single pixmap and do the composition
+	 * with the new pixmap. If the transformed region doesn't cross a source/mask's
+	 * boundary then we don't need to copy.
+	 *
+	 */
+	if (source_pixmap_priv
+	    && source->transform
+	    && source_pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
+		int source_transformed_block_width, source_transformed_block_height;
+		if (!glamor_get_transform_block_size(source->transform,
+					  source_pixmap_priv->large.block_w,
+					  source_pixmap_priv->large.block_h,
+					  &source_transformed_block_width,
+					  &source_transformed_block_height)) {
+			DEBUGF("source block size less than 1, fallback.\n");
+			RegionTranslate(region, dest->pDrawable->x,
+					dest->pDrawable->y);
+			return FALSE;
+		}
+		fixed_block_width = min(fixed_block_width , source_transformed_block_width);
+		fixed_block_height = min(fixed_block_height , source_transformed_block_height);
+		DEBUGF("new source block size %d x %d \n", fixed_block_width, fixed_block_height);
+	}
+
+	if (mask_pixmap_priv
+	    && mask->transform
+	    && mask_pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
+		int mask_transformed_block_width, mask_transformed_block_height;
+		if (!glamor_get_transform_block_size(mask->transform,
+					  mask_pixmap_priv->large.block_w,
+					  mask_pixmap_priv->large.block_h,
+					  &mask_transformed_block_width,
+					  &mask_transformed_block_height)) {
+			DEBUGF("mask block size less than 1, fallback.\n");
+			RegionTranslate(region, dest->pDrawable->x,
+					dest->pDrawable->y);
+			return FALSE;
+		}
+		fixed_block_width = min(fixed_block_width , mask_transformed_block_width);
+		fixed_block_height = min(fixed_block_height , mask_transformed_block_height);
+		DEBUGF("new mask block size %d x %d \n", fixed_block_width, fixed_block_height);
+	}
+
+	/*compute the correct block width and height whose transformed source/mask
+	 *region can fit into one texture.*/
+	if (force_clip || fixed_block_width < glamor_priv->max_fbo_size
+	    || fixed_block_height < glamor_priv->max_fbo_size)
+		clipped_dest_regions = glamor_compute_clipped_regions_ext(dest_pixmap_priv,
+									  region,
+									  &n_dest_regions,
+									  fixed_block_width,
+									  fixed_block_height,
+									  0, 0);
+	else
+		clipped_dest_regions = glamor_compute_clipped_regions(dest_pixmap_priv,
+								      region,
+								      &n_dest_regions,
+								      0, 0, 0);
+	DEBUGF("dest clipped result %d region: \n", n_dest_regions);
+	if (source_pixmap_priv
+	    && (source_pixmap_priv == dest_pixmap_priv || source_pixmap_priv == mask_pixmap_priv)
+		&& source_pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
+		/* XXX self-copy...*/
+		need_free_source_pixmap_priv = source_pixmap_priv;
+		source_pixmap_priv = malloc(sizeof(*source_pixmap_priv));
+		*source_pixmap_priv = *need_free_source_pixmap_priv;
+		need_free_source_pixmap_priv = source_pixmap_priv;
+	}
+	assert(mask_pixmap_priv != dest_pixmap_priv);
+
+	for(i = 0; i < n_dest_regions; i++)
+	{
+		DEBUGF("dest region %d  idx %d\n", i, clipped_dest_regions[i].block_idx);
+		DEBUGRegionPrint(clipped_dest_regions[i].region);
+		SET_PIXMAP_FBO_CURRENT(dest_pixmap_priv, clipped_dest_regions[i].block_idx);
+		if ( source_pixmap_priv && source_pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
+			if (!source->transform && source_repeat_type != RepeatPad) {
+				RegionTranslate(clipped_dest_regions[i].region,
+						x_source - x_dest,
+						y_source - y_dest);
+				clipped_source_regions = glamor_compute_clipped_regions(source_pixmap_priv,
+										        clipped_dest_regions[i].region,
+										        &n_source_regions, source_repeat_type,
+											0, 0);
+				is_normal_source_fbo = 1;
+			}
+			else {
+				clipped_source_regions = glamor_compute_transform_clipped_regions(source_pixmap_priv,
+									source->transform,
+									clipped_dest_regions[i].region,
+									&n_source_regions,
+									x_source - x_dest, y_source - y_dest,
+									source_repeat_type, 0, 0);
+				is_normal_source_fbo = 0;
+				if (n_source_regions == 0) {
+					/* Pad the out-of-box region to (0,0,0,0). */
+					null_source = 1;
+					n_source_regions = 1;
+				} else
+					_glamor_process_transformed_clipped_region(source_pixmap_priv,
+						source_repeat_type, clipped_source_regions, &n_source_regions,
+						&need_clean_source_fbo);
+			}
+			DEBUGF("source clipped result %d region: \n", n_source_regions);
+			for(j = 0; j < n_source_regions; j++)
+			{
+				if (is_normal_source_fbo)
+					SET_PIXMAP_FBO_CURRENT(source_pixmap_priv,
+							       clipped_source_regions[j].block_idx);
+
+				if (mask_pixmap_priv && mask_pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
+					if (is_normal_mask_fbo && is_normal_source_fbo) {
+						/* both mask and source are normal fbo box without transform or repeatpad.
+						 * The region is clipped against source and then we clip it against mask here.*/
+						DEBUGF("source region %d  idx %d\n", j, clipped_source_regions[j].block_idx);
+						DEBUGRegionPrint(clipped_source_regions[j].region);
+						RegionTranslate(clipped_source_regions[j].region,
+								- x_source + x_mask,
+							- y_source + y_mask);
+						clipped_mask_regions = glamor_compute_clipped_regions(mask_pixmap_priv,
+											     clipped_source_regions[j].region,
+											     &n_mask_regions, mask_repeat_type,
+											     0, 0);
+						is_normal_mask_fbo = 1;
+					} else if (is_normal_mask_fbo && !is_normal_source_fbo) {
+						assert(n_source_regions == 1);
+						/* The source fbo is not a normal fbo box, it has transform or repeatpad.
+						 * the valid clip region should be the clip dest region rather than the
+						 * clip source region.*/
+						RegionTranslate(clipped_dest_regions[i].region,
+								- x_dest + x_mask,
+								- y_dest + y_mask);
+						clipped_mask_regions = glamor_compute_clipped_regions(mask_pixmap_priv,
+											     clipped_dest_regions[i].region,
+											     &n_mask_regions, mask_repeat_type,
+											     0, 0);
+						is_normal_mask_fbo = 1;
+					} else {
+						/* This mask region has transform or repeatpad, we need clip it agains the previous
+						 * valid region rather than the mask region. */
+						if (!is_normal_source_fbo)
+							clipped_mask_regions = glamor_compute_transform_clipped_regions(mask_pixmap_priv,
+												mask->transform,
+												clipped_dest_regions[i].region,
+												&n_mask_regions,
+												x_mask - x_dest,
+												y_mask - y_dest,
+												mask_repeat_type, 0, 0);
+						else
+							clipped_mask_regions = glamor_compute_transform_clipped_regions(mask_pixmap_priv,
+												mask->transform,
+												clipped_source_regions[j].region,
+												&n_mask_regions,
+												x_mask - x_source, y_mask - y_source,
+												mask_repeat_type, 0, 0);
+						is_normal_mask_fbo = 0;
+						if (n_mask_regions == 0) {
+						/* Pad the out-of-box region to (0,0,0,0). */
+							null_mask = 1;
+							n_mask_regions = 1;
+						} else
+							_glamor_process_transformed_clipped_region(mask_pixmap_priv,
+								mask_repeat_type, clipped_mask_regions, &n_mask_regions,
+								&need_clean_mask_fbo);
+					}
+					DEBUGF("mask clipped result %d region: \n", n_mask_regions);
+
+#define COMPOSITE_REGION(region) do {				\
+	if (!glamor_composite_clipped_region(op,		\
+			 null_source ? NULL : source,		\
+			 null_mask ? NULL : mask, dest,		\
+			 null_source ? NULL : source_pixmap_priv, \
+			 null_mask ? NULL : mask_pixmap_priv, 	\
+			 dest_pixmap_priv, region,		\
+			 x_source, y_source, x_mask, y_mask,	\
+			 x_dest, y_dest)) {			\
+		assert(0);					\
+	}							\
+   } while(0)
+
+					for(k = 0; k < n_mask_regions; k++)
+					{
+						DEBUGF("mask region %d  idx %d\n", k, clipped_mask_regions[k].block_idx);
+						DEBUGRegionPrint(clipped_mask_regions[k].region);
+						if (is_normal_mask_fbo) {
+							SET_PIXMAP_FBO_CURRENT(mask_pixmap_priv,
+								       clipped_mask_regions[k].block_idx);
+							DEBUGF("mask fbo off %d %d \n",
+								mask_pixmap_priv->large.box.x1,
+								mask_pixmap_priv->large.box.y1);
+							DEBUGF("start composite mask hasn't transform.\n");
+							RegionTranslate(clipped_mask_regions[k].region,
+									x_dest - x_mask + dest->pDrawable->x,
+									y_dest - y_mask + dest->pDrawable->y);
+							COMPOSITE_REGION(clipped_mask_regions[k].region);
+						} else if (!is_normal_mask_fbo && !is_normal_source_fbo) {
+							DEBUGF("start composite both mask and source have transform.\n");
+							RegionTranslate(clipped_dest_regions[i].region,
+									dest->pDrawable->x,
+									dest->pDrawable->y);
+							COMPOSITE_REGION(clipped_dest_regions[i].region);
+						} else {
+							DEBUGF("start composite only mask has transform.\n");
+							RegionTranslate(clipped_source_regions[j].region,
+									x_dest - x_source + dest->pDrawable->x,
+									y_dest - y_source + dest->pDrawable->y);
+							COMPOSITE_REGION(clipped_source_regions[j].region);
+						}
+						RegionDestroy(clipped_mask_regions[k].region);
+					}
+					free(clipped_mask_regions);
+					if (null_mask) null_mask = 0;
+					if (need_clean_mask_fbo) {
+						assert(is_normal_mask_fbo == 0);
+						glamor_destroy_fbo(mask_pixmap_priv->base.fbo);
+						mask_pixmap_priv->base.fbo = NULL;
+						need_clean_mask_fbo = 0;
+					}
+				} else {
+					if (is_normal_source_fbo) {
+						RegionTranslate(clipped_source_regions[j].region,
+								-x_source + x_dest + dest->pDrawable->x,
+								-y_source + y_dest + dest->pDrawable->y);
+						COMPOSITE_REGION(clipped_source_regions[j].region);
+					} else {
+						/* Source has transform or repeatPad. dest regions is the right
+						 * region to do the composite. */
+						RegionTranslate(clipped_dest_regions[i].region,
+								dest->pDrawable->x,
+								dest->pDrawable->y);
+						COMPOSITE_REGION(clipped_dest_regions[i].region);
+					}
+				}
+				if (clipped_source_regions && clipped_source_regions[j].region)
+					RegionDestroy(clipped_source_regions[j].region);
+			}
+			free(clipped_source_regions);
+			if (null_source) null_source = 0;
+			if (need_clean_source_fbo) {
+				assert(is_normal_source_fbo == 0);
+				glamor_destroy_fbo(source_pixmap_priv->base.fbo);
+				source_pixmap_priv->base.fbo = NULL;
+				need_clean_source_fbo = 0;
+			}
+		}
+		else {
+			if (mask_pixmap_priv && mask_pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
+				if (!mask->transform && mask_repeat_type != RepeatPad) {
+					RegionTranslate(clipped_dest_regions[i].region,
+							x_mask - x_dest,
+							y_mask - y_dest);
+					clipped_mask_regions = glamor_compute_clipped_regions(mask_pixmap_priv,
+								        clipped_dest_regions[i].region,
+								        &n_mask_regions, mask_repeat_type, 0, 0);
+					is_normal_mask_fbo = 1;
+				}
+				else {
+					clipped_mask_regions = glamor_compute_transform_clipped_regions(mask_pixmap_priv,
+										mask->transform,
+										clipped_dest_regions[i].region,
+										&n_mask_regions,
+										x_mask - x_dest, y_mask - y_dest,
+										mask_repeat_type, 0, 0);
+					is_normal_mask_fbo = 0;
+					if (n_mask_regions == 0) {
+						/* Pad the out-of-box region to (0,0,0,0). */
+						null_mask = 1;
+						n_mask_regions = 1;
+					} else
+						_glamor_process_transformed_clipped_region(mask_pixmap_priv,
+							mask_repeat_type, clipped_mask_regions, &n_mask_regions,
+							&need_clean_mask_fbo);
+				}
+
+				for(k = 0; k < n_mask_regions; k++)
+				{
+					DEBUGF("mask region %d  idx %d\n", k, clipped_mask_regions[k].block_idx);
+					DEBUGRegionPrint(clipped_mask_regions[k].region);
+					if (is_normal_mask_fbo) {
+						SET_PIXMAP_FBO_CURRENT(mask_pixmap_priv,
+								       clipped_mask_regions[k].block_idx);
+						RegionTranslate(clipped_mask_regions[k].region,
+								x_dest - x_mask + dest->pDrawable->x,
+								y_dest - y_mask + dest->pDrawable->y);
+						COMPOSITE_REGION(clipped_mask_regions[k].region);
+					} else {
+						RegionTranslate(clipped_dest_regions[i].region,
+								dest->pDrawable->x,
+								dest->pDrawable->y);
+						COMPOSITE_REGION(clipped_dest_regions[i].region);
+					}
+					RegionDestroy(clipped_mask_regions[k].region);
+				}
+				free(clipped_mask_regions);
+				if (null_mask) null_mask = 0;
+				if (need_clean_mask_fbo) {
+					glamor_destroy_fbo(mask_pixmap_priv->base.fbo);
+					mask_pixmap_priv->base.fbo = NULL;
+					need_clean_mask_fbo = 0;
+				}
+			}
+			else {
+				RegionTranslate(clipped_dest_regions[i].region,
+						dest->pDrawable->x,
+						dest->pDrawable->y);
+				COMPOSITE_REGION(clipped_dest_regions[i].region);
+			}
+		}
+		RegionDestroy(clipped_dest_regions[i].region);
+	}
+	free(clipped_dest_regions);
+	free(need_free_source_pixmap_priv);
+	free(need_free_mask_pixmap_priv);
+	ok = TRUE;
+	return ok;
+}
diff --git a/glamor_picture.c b/glamor_picture.c
index a6d21f1..44e1e40 100644
--- a/glamor_picture.c
+++ b/glamor_picture.c
@@ -101,8 +101,8 @@ glamor_create_picture(PicturePtr picture)
 		}
 	}
 
-	pixmap_priv->is_picture = 1;
-	pixmap_priv->pict_format = picture->format;
+	pixmap_priv->base.is_picture = 1;
+	pixmap_priv->base.picture = picture;
 
 	return miCreatePicture(picture);
 }
@@ -123,8 +123,8 @@ glamor_destroy_picture(PicturePtr picture)
 	pixmap_priv = glamor_get_pixmap_private(pixmap);
 
 	if (pixmap_priv) {
-		pixmap_priv->is_picture = 0;
-		pixmap_priv->pict_format = 0;
+		pixmap_priv->base.is_picture = 0;
+		pixmap_priv->base.picture = NULL;
 	}
 	miDestroyPicture(picture);
 }
@@ -133,5 +133,5 @@ void
 glamor_picture_format_fixup(PicturePtr picture,
 			    glamor_pixmap_private * pixmap_priv)
 {
-	pixmap_priv->pict_format = picture->format;
+	pixmap_priv->base.picture = picture;
 }
diff --git a/glamor_pixmap.c b/glamor_pixmap.c
index 9b40b66..f3a2a87 100644
--- a/glamor_pixmap.c
+++ b/glamor_pixmap.c
@@ -64,7 +64,7 @@ glamor_pixmap_fini(ScreenPtr screen)
 }
 
 void
-glamor_set_destination_pixmap_fbo(glamor_pixmap_fbo * fbo)
+glamor_set_destination_pixmap_fbo(glamor_pixmap_fbo * fbo, int x0, int y0, int width, int height)
 {
 	glamor_gl_dispatch *dispatch = glamor_get_dispatch(fbo->glamor_priv);
 	dispatch->glBindFramebuffer(GL_FRAMEBUFFER, fbo->fb);
@@ -74,9 +74,8 @@ glamor_set_destination_pixmap_fbo(glamor_pixmap_fbo * fbo)
 	dispatch->glMatrixMode(GL_MODELVIEW);
 	dispatch->glLoadIdentity();
 #endif
-	dispatch->glViewport(0, 0,
-			     fbo->width,
-			     fbo->height);
+	dispatch->glViewport(x0, y0,
+			     width, height);
 
 	glamor_put_dispatch(fbo->glamor_priv);
 }
@@ -84,7 +83,11 @@ glamor_set_destination_pixmap_fbo(glamor_pixmap_fbo * fbo)
 void
 glamor_set_destination_pixmap_priv_nc(glamor_pixmap_private * pixmap_priv)
 {
-	glamor_set_destination_pixmap_fbo(pixmap_priv->fbo);
+	int w,h;
+
+	PIXMAP_PRIV_GET_ACTUAL_SIZE(pixmap_priv, w, h);
+	glamor_set_destination_pixmap_fbo(pixmap_priv->base.fbo, 0, 0,
+					  w, h);
 }
 
 int
@@ -185,7 +188,7 @@ glamor_set_alu(struct glamor_gl_dispatch *dispatch, unsigned char alu)
 	return TRUE;
 }
 
-void *
+static void *
 _glamor_color_convert_a1_a8(void *src_bits, void *dst_bits, int w, int h, int stride, int revert)
 {
 	PictFormatShort dst_format, src_format;
@@ -269,7 +272,7 @@ _glamor_color_convert_a1_a8(void *src_bits, void *dst_bits, int w, int h, int st
 			(*dst) = ((a) << (a_shift)) | ((r) << (b_shift)) | ((g) << (g_shift)) | ((b) << (r_shift)); \
 	}
 
-void *
+static void *
 _glamor_color_revert_x2b10g10r10(void *src_bits, void *dst_bits, int w, int h, int stride, int no_alpha, int revert, int swap_rb)
 {
 	int x,y;
@@ -306,7 +309,7 @@ _glamor_color_revert_x2b10g10r10(void *src_bits, void *dst_bits, int w, int h, i
 
 }
 
-void *
+static void *
 _glamor_color_revert_x1b5g5r5(void *src_bits, void *dst_bits, int w, int h, int stride, int no_alpha, int revert, int swap_rb)
 {
 	int x,y;
@@ -360,7 +363,7 @@ _glamor_color_revert_x1b5g5r5(void *src_bits, void *dst_bits, int w, int h, int
  *
  */
 
-void *
+static void *
 glamor_color_convert_to_bits(void *src_bits, void *dst_bits, int w, int h, int stride, int no_alpha, int revert, int swap_rb)
 {
 	if (revert == REVERT_DOWNLOADING_A1 || revert == REVERT_UPLOADING_A1) {
@@ -488,16 +491,27 @@ _glamor_upload_bits_to_pixmap_texture(PixmapPtr pixmap, GLenum format, GLenum ty
 	}
 
 ready_to_upload:
+
 	/* Try fast path firstly, upload the pixmap to the texture attached
 	 * to the fbo directly. */
 	if (no_alpha == 0
 	    && revert == REVERT_NONE
 	    && swap_rb == SWAP_NONE_UPLOADING
-	    && !need_flip) {
-		assert(pixmap_priv->fbo->tex);
-		__glamor_upload_pixmap_to_texture(pixmap, &pixmap_priv->fbo->tex,
+	    && !need_flip
+#ifdef WALKAROUND_LARGE_TEXTURE_MAP
+	    && pixmap_priv->type != GLAMOR_TEXTURE_LARGE
+#endif
+		) {
+		int fbo_x_off, fbo_y_off;
+		assert(pixmap_priv->base.fbo->tex);
+		pixmap_priv_get_fbo_off(pixmap_priv, &fbo_x_off, &fbo_y_off);
+
+		assert(x + fbo_x_off >= 0 && y + fbo_y_off >= 0);
+		assert(x + fbo_x_off + w <= pixmap_priv->base.fbo->width);
+		assert(y + fbo_y_off + h <= pixmap_priv->base.fbo->height);
+		__glamor_upload_pixmap_to_texture(pixmap, &pixmap_priv->base.fbo->tex,
 						  format, type,
-						  x, y, w, h,
+						  x + fbo_x_off, y + fbo_y_off, w, h,
 						  bits, pbo);
 		return TRUE;
 	}
@@ -507,14 +521,13 @@ ready_to_upload:
 	else
 		ptexcoords = texcoords_inv;
 
-	pixmap_priv_get_scale(pixmap_priv, &dst_xscale, &dst_yscale);
-	glamor_set_normalize_vcoords(dst_xscale,
+	pixmap_priv_get_dest_scale(pixmap_priv, &dst_xscale, &dst_yscale);
+	glamor_set_normalize_vcoords(pixmap_priv, dst_xscale,
 				     dst_yscale,
 				     x, y,
 				     x + w, y + h,
 				     glamor_priv->yInverted,
 				     vertices);
-
 	/* Slow path, we need to flip y or wire alpha to 1. */
 	dispatch = glamor_get_dispatch(glamor_priv);
 	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_POS, 2, GL_FLOAT,
@@ -585,18 +598,21 @@ glamor_pixmap_upload_prepare(PixmapPtr pixmap, GLenum format, int no_alpha, int
 	pixmap_priv = glamor_get_pixmap_private(pixmap);
 	glamor_priv = glamor_get_screen_private(pixmap->drawable.pScreen);
 
-	if (pixmap_priv->fbo
-	     && (pixmap_priv->fbo->width < pixmap->drawable.width
-           || pixmap_priv->fbo->height < pixmap->drawable.height)) {
+	if (pixmap_priv->base.gl_fbo)
+		return 0;
+
+	if (pixmap_priv->base.fbo
+	     && (pixmap_priv->base.fbo->width < pixmap->drawable.width
+           || pixmap_priv->base.fbo->height < pixmap->drawable.height)) {
 		fbo = glamor_pixmap_detach_fbo(pixmap_priv);
 		glamor_destroy_fbo(fbo);
         }
 
-	if (pixmap_priv->fbo && pixmap_priv->fbo->fb)
+	if (pixmap_priv->base.fbo && pixmap_priv->base.fbo->fb)
 		return 0;
 
 	if (!(no_alpha
-	      || (revert != REVERT_NONE)
+	      || (revert == REVERT_NORMAL)
 	      || (swap_rb != SWAP_NONE_UPLOADING)
 	      || !glamor_priv->yInverted)) {
 		/* We don't need a fbo, a simple texture uploading should work. */
@@ -604,8 +620,10 @@ glamor_pixmap_upload_prepare(PixmapPtr pixmap, GLenum format, int no_alpha, int
 		flag = GLAMOR_CREATE_FBO_NO_FBO;
 	}
 
-	if ((flag == 0 && pixmap_priv && pixmap_priv->fbo && pixmap_priv->fbo->tex)
-	    || (flag != 0 && pixmap_priv && pixmap_priv->fbo && pixmap_priv->fbo->fb))
+	if ((flag == GLAMOR_CREATE_FBO_NO_FBO
+		&& pixmap_priv->base.fbo && pixmap_priv->base.fbo->tex)
+	    || (flag == 0
+		&& pixmap_priv->base.fbo && pixmap_priv->base.fbo->fb))
 		return 0;
 
 	if (glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP)
@@ -613,35 +631,64 @@ glamor_pixmap_upload_prepare(PixmapPtr pixmap, GLenum format, int no_alpha, int
 	else
 		iformat = format;
 
-	if (pixmap_priv == NULL || pixmap_priv->fbo == NULL) {
-
-		fbo = glamor_create_fbo(glamor_priv, pixmap->drawable.width,
-					pixmap->drawable.height,
-					iformat,
-					flag);
-		if (fbo == NULL) {
-			glamor_fallback
-			    ("upload failed, depth %d x %d @depth %d \n",
-			     pixmap->drawable.width, pixmap->drawable.height,
-			     pixmap->drawable.depth);
-			return -1;
-		}
+	if (!glamor_pixmap_ensure_fbo(pixmap, iformat, flag))
+		return -1;
 
-		glamor_pixmap_attach_fbo(pixmap, fbo);
-	} else {
-		/* We do have a fbo, but it may lack of fb or tex. */
-		glamor_pixmap_ensure_fbo(pixmap, iformat, flag);
+	return 0;
+}
+
+/*
+ * upload sub region to a large region.
+ * */
+static void
+glamor_put_bits(char *dst_bits, int dst_stride, char *src_bits,
+		int src_stride, int bpp,
+		int x, int y, int w, int h)
+{
+	int j;
+	int byte_per_pixel;
+
+	byte_per_pixel = bpp / 8;
+	src_bits += y * src_stride + (x * byte_per_pixel);
+
+	for(j = y; j < y + h; j++)
+	{
+		memcpy(dst_bits, src_bits, w * byte_per_pixel);
+		src_bits += src_stride;
+		dst_bits += dst_stride;
 	}
+}
+/*
+ * download sub region from a large region.
+ */
+static void
+glamor_get_bits(char *dst_bits, int dst_stride, char *src_bits,
+		int src_stride, int bpp,
+		int x, int y, int w, int h)
+{
+	int j;
+	int byte_per_pixel;
 
-	return 0;
+	byte_per_pixel = bpp / 8;
+	dst_bits += y * dst_stride + x * byte_per_pixel;
+
+	for(j = y; j < y + h; j++)
+	{
+		memcpy(dst_bits, src_bits, w * byte_per_pixel);
+		src_bits += src_stride;
+		dst_bits += dst_stride;
+	}
 }
 
+
 Bool
 glamor_upload_sub_pixmap_to_texture(PixmapPtr pixmap, int x, int y, int w, int h,
 				    int stride, void *bits, int pbo)
 {
 	GLenum format, type;
 	int no_alpha, revert, swap_rb;
+	glamor_pixmap_private *pixmap_priv;
+	Bool force_clip;
 
 	if (glamor_get_tex_format_type_from_pixmap(pixmap,
 						   &format,
@@ -656,7 +703,85 @@ glamor_upload_sub_pixmap_to_texture(PixmapPtr pixmap, int x, int y, int w, int h
 	if (glamor_pixmap_upload_prepare(pixmap, format, no_alpha, revert, swap_rb))
 		return FALSE;
 
-	return _glamor_upload_bits_to_pixmap_texture(pixmap, format, type, no_alpha, revert, swap_rb,
+	pixmap_priv = glamor_get_pixmap_private(pixmap);
+	force_clip = pixmap_priv->base.glamor_priv->gl_flavor != GLAMOR_GL_DESKTOP
+			&& !glamor_check_fbo_size(pixmap_priv->base.glamor_priv, w, h);
+
+	if (pixmap_priv->type == GLAMOR_TEXTURE_LARGE || force_clip) {
+		RegionRec region;
+		BoxRec box;
+		int n_region;
+		glamor_pixmap_clipped_regions *clipped_regions;
+		void *sub_bits;
+		int i,j;
+
+		sub_bits = malloc(h * stride);
+		if (sub_bits == NULL)
+			return FALSE;
+		box.x1 = x;
+		box.y1 = y;
+		box.x2 = x + w;
+		box.y2 = y + h;
+		RegionInitBoxes(&region, &box, 1);
+		if (!force_clip)
+			clipped_regions = glamor_compute_clipped_regions(pixmap_priv, &region, &n_region, 0, 0, 0);
+		else
+			clipped_regions = glamor_compute_clipped_regions_ext(pixmap_priv, &region, &n_region,
+							pixmap_priv->base.glamor_priv->max_fbo_size,
+							pixmap_priv->base.glamor_priv->max_fbo_size, 0, 0);
+		DEBUGF("prepare upload %dx%d to a large pixmap %p\n", w, h, pixmap);
+		for(i = 0; i < n_region; i++)
+		{
+			BoxPtr boxes;
+			int nbox;
+			int temp_stride;
+			void *temp_bits;
+
+			assert(pbo == 0);
+
+			SET_PIXMAP_FBO_CURRENT(pixmap_priv, clipped_regions[i].block_idx);
+
+			boxes = RegionRects(clipped_regions[i].region);
+			nbox = RegionNumRects(clipped_regions[i].region);
+			DEBUGF("split to %d boxes\n", nbox);
+			for(j = 0; j < nbox; j++)
+			{
+				temp_stride = PixmapBytePad(boxes[j].x2 - boxes[j].x1,
+							    pixmap->drawable.depth);
+
+				if (boxes[j].x1 == x && temp_stride == stride) {
+					temp_bits = (char*)bits + (boxes[j].y1 - y) * stride;
+				} else {
+					temp_bits = sub_bits;
+					glamor_put_bits(temp_bits, temp_stride, bits, stride,
+							pixmap->drawable.bitsPerPixel,
+							boxes[j].x1 - x, boxes[j].y1 - y,
+							boxes[j].x2 - boxes[j].x1,
+							boxes[j].y2 - boxes[j].y1);
+				}
+				DEBUGF("upload x %d y %d w %d h %d temp stride %d \n",
+					boxes[j].x1 - x, boxes[j].y1 - y,
+					boxes[j].x2 - boxes[j].x1,
+					boxes[j].y2 - boxes[j].y1, temp_stride);
+				if (_glamor_upload_bits_to_pixmap_texture(pixmap, format, type, no_alpha,
+									  revert, swap_rb, boxes[j].x1, boxes[j].y1,
+									  boxes[j].x2 - boxes[j].x1,
+									  boxes[j].y2 - boxes[j].y1,
+									  temp_stride, temp_bits, pbo) == FALSE) {
+					RegionUninit(&region);
+					free(sub_bits);
+					assert(0);
+					return FALSE;
+				}
+			}
+			RegionDestroy(clipped_regions[i].region);
+		}
+		free(sub_bits);
+		free(clipped_regions);
+		RegionUninit(&region);
+		return TRUE;
+	} else
+		return _glamor_upload_bits_to_pixmap_texture(pixmap, format, type, no_alpha, revert, swap_rb,
 						     x, y, w, h, stride, bits, pbo);
 }
 
@@ -670,11 +795,10 @@ glamor_upload_pixmap_to_texture(PixmapPtr pixmap)
 
 	pixmap_priv = glamor_get_pixmap_private(pixmap);
 
-	if (pixmap_priv
-	    && (pixmap_priv->fbo)
-	    && (pixmap_priv->fbo->pbo_valid)) {
+	if ((pixmap_priv->base.fbo)
+	    && (pixmap_priv->base.fbo->pbo_valid)) {
 		data = NULL;
-		pbo = pixmap_priv->fbo->pbo;
+		pbo = pixmap_priv->base.fbo->pbo;
 	} else {
 		data = pixmap->devPrivate.ptr;
 		pbo = 0;
@@ -733,10 +857,10 @@ glamor_es2_pixmap_read_prepare(PixmapPtr source, int x, int y, int w, int h, GLe
 		return NULL;
 
 	dispatch = glamor_get_dispatch(glamor_priv);
-	temp_xscale = 1.0 / temp_fbo->width;
-	temp_yscale = 1.0 / temp_fbo->height;
+	temp_xscale = 1.0 / w;
+	temp_yscale = 1.0 / h;
 
-	glamor_set_normalize_vcoords(temp_xscale,
+	glamor_set_normalize_vcoords((struct glamor_pixmap_private*)NULL,temp_xscale,
 				     temp_yscale,
 				     0, 0,
 				     w, h,
@@ -749,7 +873,7 @@ glamor_es2_pixmap_read_prepare(PixmapPtr source, int x, int y, int w, int h, GLe
 	dispatch->glEnableVertexAttribArray(GLAMOR_VERTEX_POS);
 
 	pixmap_priv_get_scale(source_priv, &source_xscale, &source_yscale);
-	glamor_set_normalize_tcoords(source_xscale,
+	glamor_set_normalize_tcoords(source_priv, source_xscale,
 				     source_yscale,
 				     x, y,
 				     x + w, y + h,
@@ -762,7 +886,7 @@ glamor_es2_pixmap_read_prepare(PixmapPtr source, int x, int y, int w, int h, GLe
 	dispatch->glEnableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
 
 	dispatch->glActiveTexture(GL_TEXTURE0);
-	dispatch->glBindTexture(GL_TEXTURE_2D, source_priv->fbo->tex);
+	dispatch->glBindTexture(GL_TEXTURE_2D, source_priv->base.fbo->tex);
 	dispatch->glTexParameteri(GL_TEXTURE_2D,
 				  GL_TEXTURE_MIN_FILTER,
 				  GL_NEAREST);
@@ -770,7 +894,7 @@ glamor_es2_pixmap_read_prepare(PixmapPtr source, int x, int y, int w, int h, GLe
 				  GL_TEXTURE_MAG_FILTER,
 				  GL_NEAREST);
 
-	glamor_set_destination_pixmap_fbo(temp_fbo);
+	glamor_set_destination_pixmap_fbo(temp_fbo, 0, 0, w, h);
 	dispatch->glUseProgram(glamor_priv->finish_access_prog[no_alpha]);
 	dispatch->glUniform1i(glamor_priv->
 			      finish_access_revert[no_alpha],
@@ -792,13 +916,15 @@ glamor_es2_pixmap_read_prepare(PixmapPtr source, int x, int y, int w, int h, GLe
  * The pixmap must have a valid FBO, otherwise return a NULL.
  * */
 
-void *
-glamor_download_sub_pixmap_to_cpu(PixmapPtr pixmap, int x, int y, int w, int h,
-				  int stride, void *bits, int pbo, glamor_access_t access)
+static void *
+_glamor_download_sub_pixmap_to_cpu(PixmapPtr pixmap, GLenum format,
+				   GLenum type, int no_alpha,
+				   int revert, int swap_rb,
+				   int x, int y, int w, int h,
+				   int stride, void *bits, int pbo, glamor_access_t access)
 {
 	glamor_pixmap_private *pixmap_priv;
-	GLenum format, type, gl_access = 0, gl_usage = 0;
-	int no_alpha, revert, swap_rb;
+	GLenum gl_access = 0, gl_usage = 0;
 	void *data, *read;
 	ScreenPtr screen;
 	glamor_screen_private *glamor_priv =
@@ -807,6 +933,7 @@ glamor_download_sub_pixmap_to_cpu(PixmapPtr pixmap, int x, int y, int w, int h,
 	glamor_pixmap_fbo *temp_fbo = NULL;
 	int need_post_conversion = 0;
 	int need_free_data = 0;
+	int fbo_x_off, fbo_y_off;
 
 	data = bits;
 	screen = pixmap->drawable.pScreen;
@@ -830,18 +957,6 @@ glamor_download_sub_pixmap_to_cpu(PixmapPtr pixmap, int x, int y, int w, int h,
 		assert(0);
 	}
 
-	if (glamor_get_tex_format_type_from_pixmap(pixmap,
-						   &format,
-						   &type,
-						   &no_alpha,
-						   &revert,
-						   &swap_rb, 0)) {
-		ErrorF("Unknown pixmap depth %d.\n",
-		       pixmap->drawable.depth);
-		assert(0);	// Should never happen.
-		return NULL;
-	}
-
 	glamor_set_destination_pixmap_priv_nc(pixmap_priv);
 
 	need_post_conversion = (revert > REVERT_NORMAL);
@@ -856,6 +971,8 @@ glamor_download_sub_pixmap_to_cpu(PixmapPtr pixmap, int x, int y, int w, int h,
 		}
 	}
 
+	pixmap_priv_get_fbo_off(pixmap_priv, &fbo_x_off, &fbo_y_off);
+
 	if (glamor_priv->gl_flavor == GLAMOR_GL_ES2
 	    && !need_post_conversion
 	    && (swap_rb != SWAP_NONE_DOWNLOADING || revert != REVERT_NONE)) {
@@ -867,6 +984,8 @@ glamor_download_sub_pixmap_to_cpu(PixmapPtr pixmap, int x, int y, int w, int h,
 		}
 		x = 0;
 		y = 0;
+		fbo_x_off = 0;
+		fbo_y_off = 0;
 	}
 
 	dispatch = glamor_get_dispatch(glamor_priv);
@@ -889,7 +1008,7 @@ glamor_download_sub_pixmap_to_cpu(PixmapPtr pixmap, int x, int y, int w, int h,
 					       NULL, gl_usage);
 		}
 
-		dispatch->glReadPixels(x, y, w, h, format, type, data);
+		dispatch->glReadPixels(x + fbo_x_off, y + fbo_y_off, w, h, format, type, data);
 
 		if (!glamor_priv->yInverted) {
 			assert(glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP);
@@ -912,13 +1031,13 @@ glamor_download_sub_pixmap_to_cpu(PixmapPtr pixmap, int x, int y, int w, int h,
 				       stride *
 				       h,
 				       NULL, GL_STREAM_READ);
-		dispatch->glReadPixels(0, 0, w, h,
+		dispatch->glReadPixels(x + fbo_x_off, y + fbo_y_off, w, h,
 				       format, type, 0);
 		read = dispatch->glMapBuffer(GL_PIXEL_PACK_BUFFER,
 					     GL_READ_ONLY);
 		for (yy = 0; yy < pixmap->drawable.height; yy++)
-			memcpy(data + yy * stride,
-			       read + (h - yy - 1) * stride, stride);
+			memcpy((char*)data + yy * stride,
+			       (char*)read + (h - yy - 1) * stride, stride);
 		dispatch->glUnmapBuffer(GL_PIXEL_PACK_BUFFER);
 		dispatch->glBindBuffer(GL_PIXEL_PACK_BUFFER, 0);
 		dispatch->glDeleteBuffers(1, &temp_pbo);
@@ -945,6 +1064,118 @@ glamor_download_sub_pixmap_to_cpu(PixmapPtr pixmap, int x, int y, int w, int h,
 	return bits;
 }
 
+void *
+glamor_download_sub_pixmap_to_cpu(PixmapPtr pixmap, int x, int y, int w, int h,
+				  int stride, void *bits, int pbo, glamor_access_t access)
+{
+	GLenum format, type;
+	int no_alpha, revert, swap_rb;
+	glamor_pixmap_private *pixmap_priv;
+	Bool force_clip;
+
+	if (glamor_get_tex_format_type_from_pixmap(pixmap,
+						   &format,
+						   &type,
+						   &no_alpha,
+						   &revert,
+						   &swap_rb, 0)) {
+		glamor_fallback("Unknown pixmap depth %d.\n",
+				pixmap->drawable.depth);
+		return NULL;
+	}
+
+	pixmap_priv = glamor_get_pixmap_private(pixmap);
+	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv))
+		return NULL;
+
+	force_clip = pixmap_priv->base.glamor_priv->gl_flavor != GLAMOR_GL_DESKTOP
+			&& !glamor_check_fbo_size(pixmap_priv->base.glamor_priv, w, h);
+
+	if (pixmap_priv->type == GLAMOR_TEXTURE_LARGE || force_clip) {
+
+		RegionRec region;
+		BoxRec box;
+		int n_region;
+		glamor_pixmap_clipped_regions *clipped_regions;
+		void *sub_bits;
+		int i,j;
+
+		sub_bits = malloc(h * stride);
+		if (sub_bits == NULL)
+			return FALSE;
+		box.x1 = x;
+		box.y1 = y;
+		box.x2 = x + w;
+		box.y2 = y + h;
+		RegionInitBoxes(&region, &box, 1);
+
+		if (!force_clip)
+			clipped_regions = glamor_compute_clipped_regions(pixmap_priv, &region, &n_region, 0, 0, 0);
+		else
+			clipped_regions = glamor_compute_clipped_regions_ext(pixmap_priv, &region, &n_region,
+							pixmap_priv->base.glamor_priv->max_fbo_size,
+							pixmap_priv->base.glamor_priv->max_fbo_size, 0, 0);
+
+		DEBUGF("start download large pixmap %p %dx%d \n", pixmap, w, h);
+		for(i = 0; i < n_region; i++)
+		{
+			BoxPtr boxes;
+			int nbox;
+			int temp_stride;
+			void *temp_bits;
+
+			assert(pbo == 0);
+			SET_PIXMAP_FBO_CURRENT(pixmap_priv, clipped_regions[i].block_idx);
+
+			boxes = RegionRects(clipped_regions[i].region);
+			nbox = RegionNumRects(clipped_regions[i].region);
+			for(j = 0; j < nbox; j++)
+			{
+				temp_stride = PixmapBytePad(boxes[j].x2 - boxes[j].x1,
+							    pixmap->drawable.depth);
+
+				if (boxes[j].x1 == x && temp_stride == stride) {
+					temp_bits = (char*)bits + (boxes[j].y1 - y) * stride;
+				} else {
+					temp_bits = sub_bits;
+				}
+				DEBUGF("download x %d y %d w %d h %d temp stride %d \n",
+					boxes[j].x1, boxes[j].y1,
+					boxes[j].x2 - boxes[j].x1,
+					boxes[j].y2 - boxes[j].y1, temp_stride);
+
+				/* For large pixmap, we don't support pbo currently.*/
+				assert(pbo == 0);
+				if (_glamor_download_sub_pixmap_to_cpu(pixmap, format, type, no_alpha,
+								       revert, swap_rb, boxes[j].x1, boxes[j].y1,
+								       boxes[j].x2 - boxes[j].x1,
+								       boxes[j].y2 - boxes[j].y1,
+								       temp_stride, temp_bits, pbo, access) == FALSE) {
+					RegionUninit(&region);
+					free(sub_bits);
+					assert(0);
+					return NULL;
+				}
+				if (boxes[j].x1 != x || temp_stride != stride)
+					glamor_get_bits(bits, stride, temp_bits, temp_stride,
+							pixmap->drawable.bitsPerPixel,
+							boxes[j].x1 - x , boxes[j].y1 - y,
+							boxes[j].x2 - boxes[j].x1,
+							boxes[j].y2 - boxes[j].y1);
+			}
+
+			RegionDestroy(clipped_regions[i].region);
+		}
+		free(sub_bits);
+		free(clipped_regions);
+		RegionUninit(&region);
+		return bits;
+	} else
+	return _glamor_download_sub_pixmap_to_cpu(pixmap, format, type, no_alpha, revert, swap_rb,
+						  x, y, w, h, stride,
+						  bits, pbo, access);
+}
+
 
 /**
  * Move a pixmap to CPU memory.
@@ -983,20 +1214,21 @@ glamor_download_pixmap_to_cpu(PixmapPtr pixmap, glamor_access_t access)
 
 	if (access == GLAMOR_ACCESS_WO
 	    || glamor_priv->gl_flavor == GLAMOR_GL_ES2
-	    || (!glamor_priv->has_pack_invert && !glamor_priv->yInverted)) {
+	    || (!glamor_priv->has_pack_invert && !glamor_priv->yInverted)
+	    || pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
 		data = malloc(stride * pixmap->drawable.height);
 	} else {
 		dispatch = glamor_get_dispatch(glamor_priv);
-		if (pixmap_priv->fbo->pbo == 0)
+		if (pixmap_priv->base.fbo->pbo == 0)
 			dispatch->glGenBuffers(1,
-					       &pixmap_priv->fbo->pbo);
+					       &pixmap_priv->base.fbo->pbo);
 		glamor_put_dispatch(glamor_priv);
-		pbo = pixmap_priv->fbo->pbo;
+		pbo = pixmap_priv->base.fbo->pbo;
 	}
 
 	if (pixmap_priv->type == GLAMOR_TEXTURE_DRM) {
 		stride = PixmapBytePad(pixmap->drawable.width, pixmap->drawable.depth);
-		pixmap_priv->drm_stride = pixmap->devKind;
+		pixmap_priv->base.drm_stride = pixmap->devKind;
 		pixmap->devKind = stride;
 	}
 
@@ -1013,9 +1245,9 @@ glamor_download_pixmap_to_cpu(PixmapPtr pixmap, glamor_access_t access)
 	}
 
 	if (pbo != 0)
-		pixmap_priv->fbo->pbo_valid = 1;
+		pixmap_priv->base.fbo->pbo_valid = 1;
 
-	pixmap_priv->gl_fbo = GLAMOR_FBO_DOWNLOADED;
+	pixmap_priv->base.gl_fbo = GLAMOR_FBO_DOWNLOADED;
 
 	pixmap->devPrivate.ptr = dst;
 
@@ -1023,6 +1255,7 @@ glamor_download_pixmap_to_cpu(PixmapPtr pixmap, glamor_access_t access)
 }
 
 /* fixup a fbo to the exact size as the pixmap. */
+/* XXX LARGE pixmap? */
 Bool
 glamor_fixup_pixmap_priv(ScreenPtr screen, glamor_pixmap_private *pixmap_priv)
 {
@@ -1035,14 +1268,13 @@ glamor_fixup_pixmap_priv(ScreenPtr screen, glamor_pixmap_private *pixmap_priv)
 	GCPtr gc = NULL;
 	int ret = FALSE;
 
-	drawable = &pixmap_priv->container->drawable;
+	drawable = &pixmap_priv->base.pixmap->drawable;
 
-	if (pixmap_priv->container->drawable.width == pixmap_priv->fbo->width
-	    && pixmap_priv->container->drawable.height == pixmap_priv->fbo->height)
+	if (!GLAMOR_PIXMAP_FBO_NOT_EAXCT_SIZE(pixmap_priv))
 		return	TRUE;
 
-	old_fbo = pixmap_priv->fbo;
-	glamor_priv = pixmap_priv->glamor_priv;
+	old_fbo = pixmap_priv->base.fbo;
+	glamor_priv = pixmap_priv->base.glamor_priv;
 
 	if (!old_fbo)
 		return FALSE;
@@ -1057,7 +1289,7 @@ glamor_fixup_pixmap_priv(ScreenPtr screen, glamor_pixmap_private *pixmap_priv)
 
 	scratch_priv = glamor_get_pixmap_private(scratch);
 
-	if (!scratch_priv || !scratch_priv->fbo)
+	if (!scratch_priv->base.fbo)
 		goto fail;
 
 	ValidateGC(&scratch->drawable, gc);
@@ -1068,7 +1300,7 @@ glamor_fixup_pixmap_priv(ScreenPtr screen, glamor_pixmap_private *pixmap_priv)
 			 0, 0);
 	old_fbo = glamor_pixmap_detach_fbo(pixmap_priv);
 	new_fbo = glamor_pixmap_detach_fbo(scratch_priv);
-	glamor_pixmap_attach_fbo(pixmap_priv->container, new_fbo);
+	glamor_pixmap_attach_fbo(pixmap_priv->base.pixmap, new_fbo);
 	glamor_pixmap_attach_fbo(scratch, old_fbo);
 
 	DEBUGF("old %dx%d type %d\n",
@@ -1110,14 +1342,13 @@ glamor_get_sub_pixmap(PixmapPtr pixmap, int x, int y, int w, int h, glamor_acces
 	void *data;
 	int pbo;
 	int flag;
-
-	assert(x >= 0 && y >= 0);
+	if (x < 0 || y < 0)
+		return NULL;
 	w = (x + w) > pixmap->drawable.width ? (pixmap->drawable.width - x) : w;
 	h = (y + h) > pixmap->drawable.height ? (pixmap->drawable.height - y) : h;
 	if (access == GLAMOR_ACCESS_WO) {
 		sub_pixmap = glamor_create_pixmap(pixmap->drawable.pScreen, w, h,
 						  pixmap->drawable.depth, GLAMOR_CREATE_PIXMAP_CPU);
-		ErrorF("WO\n");
 		return sub_pixmap;
 	}
 
@@ -1126,7 +1357,7 @@ glamor_get_sub_pixmap(PixmapPtr pixmap, int x, int y, int w, int h, glamor_acces
 
 	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv))
 		return NULL;
-	if (glamor_priv->gl_flavor == GLAMOR_GL_ES2)
+	if (glamor_priv->gl_flavor == GLAMOR_GL_ES2 || pixmap_priv->type == GLAMOR_TEXTURE_LARGE)
 		flag = GLAMOR_CREATE_PIXMAP_CPU;
 	else
 		flag = GLAMOR_CREATE_PIXMAP_MAP;
@@ -1138,25 +1369,24 @@ glamor_get_sub_pixmap(PixmapPtr pixmap, int x, int y, int w, int h, glamor_acces
 		return NULL;
 
 	sub_pixmap_priv = glamor_get_pixmap_private(sub_pixmap);
-	pbo = sub_pixmap_priv ? (sub_pixmap_priv->fbo ? sub_pixmap_priv->fbo->pbo : 0): 0;
+	pbo = sub_pixmap_priv ? (sub_pixmap_priv->base.fbo ? sub_pixmap_priv->base.fbo->pbo : 0): 0;
 
-	if (pixmap_priv->is_picture) {
-		sub_pixmap_priv->pict_format = pixmap_priv->pict_format;
-		sub_pixmap_priv->is_picture = pixmap_priv->is_picture;
+	if (pixmap_priv->base.is_picture) {
+		sub_pixmap_priv->base.picture = pixmap_priv->base.picture;
+		sub_pixmap_priv->base.is_picture = pixmap_priv->base.is_picture;
 	}
 
 	if (pbo)
 		data = NULL;
-	else {
+	else
 		data = sub_pixmap->devPrivate.ptr;
-		assert(flag != GLAMOR_CREATE_PIXMAP_MAP);
-	}
+
 	data = glamor_download_sub_pixmap_to_cpu(pixmap, x, y, w, h, sub_pixmap->devKind,
 						 data, pbo, access);
 	if (pbo) {
 		assert(sub_pixmap->devPrivate.ptr == NULL);
 		sub_pixmap->devPrivate.ptr = data;
-		sub_pixmap_priv->fbo->pbo_valid = 1;
+		sub_pixmap_priv->base.fbo->pbo_valid = 1;
 	}
 #if 0
 	struct pixman_box16 box;
@@ -1172,7 +1402,7 @@ glamor_get_sub_pixmap(PixmapPtr pixmap, int x, int y, int w, int h, glamor_acces
 
 	new_sub_pixmap = glamor_create_pixmap(pixmap->drawable.pScreen, w, h,
 					      pixmap->drawable.depth, GLAMOR_CREATE_PIXMAP_CPU);
-	glamor_copy_n_to_n(&pixmap->drawable, &new_sub_pixmap, NULL, &box, 1, dx, dy, 0, 0, 0, NULL);
+	glamor_copy_n_to_n(&pixmap->drawable, &new_sub_pixmap->drawable, NULL, &box, 1, dx, dy, 0, 0, 0, NULL);
 	glamor_compare_pixmaps(new_sub_pixmap, sub_pixmap, 0, 0, w, h, 1, 1);
 #endif
 
@@ -1187,11 +1417,10 @@ glamor_put_sub_pixmap(PixmapPtr sub_pixmap, PixmapPtr pixmap, int x, int y, int
 	glamor_pixmap_private *sub_pixmap_priv;
 	if (access != GLAMOR_ACCESS_RO) {
 		sub_pixmap_priv = glamor_get_pixmap_private(sub_pixmap);
-		if (sub_pixmap_priv
-		    && sub_pixmap_priv->fbo
-		    && sub_pixmap_priv->fbo->pbo_valid) {
+		if (sub_pixmap_priv->base.fbo
+		    && sub_pixmap_priv->base.fbo->pbo_valid) {
 			bits = NULL;
-			pbo = sub_pixmap_priv->fbo->pbo;
+			pbo = sub_pixmap_priv->base.fbo->pbo;
 		} else {
 			bits = sub_pixmap->devPrivate.ptr;
 			pbo = 0;
diff --git a/glamor_priv.h b/glamor_priv.h
index ca88fb4..11d09c4 100644
--- a/glamor_priv.h
+++ b/glamor_priv.h
@@ -31,11 +31,14 @@
 #include "config.h"
 #endif
 
+#include "compiler.h"
+
 #include <xorg-server.h>
 #ifndef DEBUG
 #define NDEBUG
 #endif
 #include "glamor.h"
+#include "compat-api.h"
 
 #define GL_GLEXT_PROTOTYPES
 
@@ -72,6 +75,7 @@
 #define xorg_list_init list_init
 #endif
 
+struct glamor_pixmap_private;
 
 typedef struct glamor_composite_shader {
 	GLuint prog;
@@ -84,26 +88,23 @@ typedef struct glamor_composite_shader {
 	GLint mask_wh;
 	GLint source_repeat_mode;
 	GLint mask_repeat_mode;
+	union {
+		float source_solid_color[4];
+		struct {
+			struct glamor_pixmap_private *source_priv;
+			PicturePtr source;
+		};
+	};
+
+	union {
+		float mask_solid_color[4];
+		struct {
+			struct glamor_pixmap_private *mask_priv;
+			PicturePtr mask;
+		};
+	};
 } glamor_composite_shader;
 
-typedef struct {
-	INT16 x_src;
-	INT16 y_src;
-	INT16 x_mask;
-	INT16 y_mask;
-	INT16 x_dst;
-	INT16 y_dst;
-	INT16 width;
-	INT16 height;
-} glamor_composite_rect_t;
-
-
-enum glamor_vertex_type {
-	GLAMOR_VERTEX_POS,
-	GLAMOR_VERTEX_SOURCE,
-	GLAMOR_VERTEX_MASK
-};
-
 enum shader_source {
 	SHADER_SOURCE_SOLID,
 	SHADER_SOURCE_TEXTURE,
@@ -127,6 +128,38 @@ enum shader_in {
 	SHADER_IN_COUNT,
 };
 
+struct shader_key {
+	enum shader_source source;
+	enum shader_mask mask;
+	enum shader_in in;
+};
+
+struct blendinfo {
+	Bool dest_alpha;
+	Bool source_alpha;
+	GLenum source_blend;
+	GLenum dest_blend;
+};
+
+typedef struct {
+	INT16 x_src;
+	INT16 y_src;
+	INT16 x_mask;
+	INT16 y_mask;
+	INT16 x_dst;
+	INT16 y_dst;
+	INT16 width;
+	INT16 height;
+} glamor_composite_rect_t;
+
+
+enum glamor_vertex_type {
+	GLAMOR_VERTEX_POS,
+	GLAMOR_VERTEX_SOURCE,
+	GLAMOR_VERTEX_MASK
+};
+
+
 enum gradient_shader {
 	SHADER_GRADIENT_LINEAR,
 	SHADER_GRADIENT_RADIAL,
@@ -158,6 +191,8 @@ enum glamor_gl_flavor {
 
 #define GLAMOR_NUM_GLYPH_CACHE_FORMATS 2
 
+#define GLAMOR_COMPOSITE_VBO_VERT_CNT 1024
+
 typedef struct {
 	PicturePtr picture;	/* Where the glyphs of the cache are stored */
 	GlyphPtr *glyphs;
@@ -165,7 +200,6 @@ typedef struct {
 	uint16_t evict;
 } glamor_glyph_cache_t;
 
-
 #include "glamor_gl_dispatch.h"
 
 struct glamor_saved_procs { 
@@ -176,6 +210,7 @@ struct glamor_saved_procs {
 	GetSpansProcPtr get_spans;
 	GetImageProcPtr get_image;
 	CompositeProcPtr composite;
+	CompositeRectsProcPtr composite_rects;
 	TrapezoidsProcPtr trapezoids;
 	GlyphsProcPtr glyphs;
 	ChangeWindowAttributesProcPtr change_window_attributes;
@@ -200,6 +235,11 @@ struct glamor_saved_procs {
 #define GLAMOR_TICK_AFTER(t0, t1) 	\
 	(((int)(t1) - (int)(t0)) < 0)
 
+#define IDLE_STATE 0
+#define RENDER_STATE 1
+#define BLIT_STATE 2
+#define RENDER_IDEL_MAX 32
+
 typedef struct glamor_screen_private {
 	struct glamor_gl_dispatch _dispatch;
 	int yInverted;
@@ -210,7 +250,6 @@ typedef struct glamor_screen_private {
 	int max_fbo_size;
 
 	struct xorg_list fbo_cache[CACHE_FORMAT_COUNT][CACHE_BUCKET_WCOUNT][CACHE_BUCKET_HCOUNT];
-	struct xorg_list tex_cache[CACHE_FORMAT_COUNT][CACHE_BUCKET_WCOUNT][CACHE_BUCKET_HCOUNT];
 	unsigned long    fbo_cache_watermark;
 
 	/* glamor_solid */
@@ -248,6 +287,9 @@ typedef struct glamor_screen_private {
 	GLint radial_gradient_shaders[SHADER_GRADIENT_PROG_COUNT][3];
 	int radial_max_nstops;
 
+	/* glamor trapezoid shader. */
+	GLint trapezoid_prog;
+
 	/* glamor_putimage */
 	GLint put_image_xybitmap_prog;
 	GLint put_image_xybitmap_fg_uniform_location;
@@ -259,6 +301,8 @@ typedef struct glamor_screen_private {
 	char delayed_fallback_string[GLAMOR_DELAYED_STRING_MAX + 1];
 	int delayed_fallback_pending;
 	int flags;
+	int state;
+	unsigned int render_idle_cnt;
 	ScreenPtr screen;
 } glamor_screen_private;
 
@@ -310,19 +354,132 @@ typedef struct glamor_pixmap_fbo {
  * @gl_tex:  The pixmap is in a gl texture originally.
  * @is_picture: The drawable is attached to a picture.
  * @pict_format: the corresponding picture's format.
- * @container: The corresponding pixmap's pointer.
+ * @pixmap: The corresponding pixmap's pointer.
+ *
+ * For GLAMOR_TEXTURE_LARGE, nbox should larger than 1.
+ * And the box and fbo will both have nbox elements.
+ * and box[i] store the relatively coords in this pixmap
+ * of the fbo[i]. The reason why use boxes not region to
+ * represent this structure is we may need to use overlapped
+ * boxes for one pixmap for some special reason.
+ *
+ * pixmap
+ * ******************
+ * *  fbo0 * fbo1   *
+ * *       *        *
+ * ******************
+ * *  fbo2 * fbo3   *
+ * *       *        *
+ * ******************
+ *
+ * Let's assume the texture has size of 1024x1024
+ * box[0] = {0,0,1024,1024}
+ * box[1] = {1024,0,2048,2048}
+ * ...
+ *
+ * For GLAMOR_TEXTURE_ATLAS nbox should be 1. And box
+ * and fbo both has one elements, and the box store
+ * the relatively coords in the fbo of this pixmap:
+ *
+ * fbo
+ * ******************
+ * *   pixmap       *
+ * *   *********    *
+ * *   *       *    *
+ * *   *********    *
+ * *                *
+ * ******************
+ *
+ * Assume the pixmap is at the (100,100) relatively to
+ * the fbo's origin.
+ * box[0]={100, 100, 1124, 1124};
+ *
+ * Considering large pixmap is not a normal case, to keep
+ * it simple, I designe it as the following way.
+ * When deal with a large pixmap, it split the working
+ * rectangle into serval boxes, and each box fit into a
+ * corresponding fbo. And then the rendering function will
+ * loop from the left-top box to the right-bottom box,
+ * each time, we will set current box and current fbo
+ * to the box and fbo elements. Thus the inner routines
+ * can handle it as normal, only the coords calculation need
+ * to aware of it's large pixmap.
+ *
+ * Currently, we haven't implemented the atlas pixmap.
+ *
  **/
-typedef struct glamor_pixmap_private {
+
+typedef struct glamor_pixmap_clipped_regions{
+	int block_idx;
+	RegionPtr region;
+} glamor_pixmap_clipped_regions;
+
+#define SET_PIXMAP_FBO_CURRENT(priv, idx) 				\
+  do {									\
+	if (priv->type == GLAMOR_TEXTURE_LARGE) {			\
+		(priv)->large.base.fbo = priv->large.fbo_array[idx]; 	\
+		(priv)->large.box = priv->large.box_array[idx]; 	\
+	}								\
+  } while(0)
+
+typedef struct glamor_pixmap_private_base {
+	glamor_pixmap_type_t type;
 	unsigned char gl_fbo:2;
 	unsigned char is_picture:1;
 	unsigned char gl_tex:1;
-	glamor_pixmap_type_t type;
 	glamor_pixmap_fbo *fbo;
-	PictFormatShort pict_format;
-	PixmapPtr container;
+	PixmapPtr pixmap;
 	int drm_stride;
 	glamor_screen_private *glamor_priv;
-} glamor_pixmap_private;
+	PicturePtr picture;
+}glamor_pixmap_private_base_t;
+
+/*
+ * @base.fbo: current fbo.
+ * @box: current fbo's coords in the whole pixmap.
+ * @block_w: block width of this large pixmap.
+ * @block_h: block height of this large pixmap.
+ * @block_wcnt: block count in one block row.
+ * @block_hcnt: block count in one block column.
+ * @nbox: total block count.
+ * @box_array: contains each block's corresponding box.
+ * @fbo_array: contains each block's fbo pointer.
+ *
+ **/
+typedef struct glamor_pixmap_private_large {
+	union {
+		glamor_pixmap_type_t type;
+		glamor_pixmap_private_base_t base;
+	};
+	BoxRec box;
+	int block_w;
+	int block_h;
+	int block_wcnt;
+	int block_hcnt;
+	int nbox;
+	BoxPtr box_array;
+	glamor_pixmap_fbo **fbo_array;
+}glamor_pixmap_private_large_t;
+
+/*
+ * @box: the relative coords in the corresponding fbo.
+ */
+typedef struct glamor_pixmap_private_atlas {
+	union {
+		glamor_pixmap_type_t type;
+		glamor_pixmap_private_base_t base;
+	};
+	BoxRec box;
+}glamor_pixmap_private_atlas_t;
+
+typedef struct glamor_pixmap_private {
+	union {
+		glamor_pixmap_type_t type;
+		glamor_pixmap_private_base_t base;
+		glamor_pixmap_private_large_t large;
+		glamor_pixmap_private_atlas_t atlas;
+	};
+}glamor_pixmap_private;
 
 /* 
  * Pixmap dynamic status, used by dynamic upload feature.
@@ -340,7 +497,6 @@ typedef enum glamor_pixmap_status {
 	GLAMOR_UPLOAD_FAILED
 } glamor_pixmap_status_t;
 
-
 extern DevPrivateKey glamor_screen_private_key;
 extern DevPrivateKey glamor_pixmap_private_key;
 static inline glamor_screen_private *
@@ -405,6 +561,7 @@ glamor_pixmap_fbo * glamor_create_fbo_from_tex(glamor_screen_private *glamor_pri
 glamor_pixmap_fbo * glamor_create_fbo(glamor_screen_private *glamor_priv,
 				      int w, int h, GLenum format, int flag);
 void glamor_destroy_fbo(glamor_pixmap_fbo *fbo);
+void glamor_pixmap_destroy_fbo(glamor_pixmap_private *priv);
 void glamor_purge_fbo(glamor_pixmap_fbo *fbo);
 
 void glamor_init_pixmap_fbo(ScreenPtr screen);
@@ -414,6 +571,11 @@ void glamor_fbo_expire(glamor_screen_private *glamor_priv);
 void glamor_init_pixmap_fbo(ScreenPtr screen);
 void glamor_fini_pixmap_fbo(ScreenPtr screen);
 
+glamor_pixmap_fbo *
+glamor_create_fbo_array(glamor_screen_private *glamor_priv,
+			int w, int h, GLenum format, int flag,
+			int block_w, int block_h, glamor_pixmap_private *);
+
 Bool glamor_fixup_pixmap_priv(ScreenPtr screen, glamor_pixmap_private *pixmap_priv);
 
 /* glamor_copyarea.c */
@@ -457,7 +619,7 @@ void glamor_get_color_4f_from_pixel(PixmapPtr pixmap,
 int glamor_set_destination_pixmap(PixmapPtr pixmap);
 int glamor_set_destination_pixmap_priv(glamor_pixmap_private *
 				       pixmap_priv);
-void glamor_set_destination_pixmap_fbo(glamor_pixmap_fbo *);
+void glamor_set_destination_pixmap_fbo(glamor_pixmap_fbo *, int, int, int, int);
 
 /* nc means no check. caller must ensure this pixmap has valid fbo.
  * usually use the GLAMOR_PIXMAP_PRIV_HAS_FBO firstly. 
@@ -490,8 +652,10 @@ Bool glamor_fill(DrawablePtr drawable,
 Bool glamor_solid(PixmapPtr pixmap, int x, int y, int width, int height,
 		  unsigned char alu, unsigned long planemask,
 		  unsigned long fg_pixel);
-void glamor_solid_fail_region(PixmapPtr pixmap,
-			      int x, int y, int width, int height);
+Bool
+glamor_solid_boxes(PixmapPtr pixmap,
+		   BoxPtr box, int nbox,
+		   unsigned long fg_pixel);
 
 /* glamor_fillspans.c */
 void glamor_fill_spans(DrawablePtr drawable,
@@ -544,6 +708,22 @@ void glamor_init_putimage_shaders(ScreenPtr screen);
 void glamor_fini_putimage_shaders(ScreenPtr screen);
 
 /* glamor_render.c */
+Bool
+glamor_composite_clipped_region(CARD8 op,
+				PicturePtr source,
+				PicturePtr mask,
+				PicturePtr dest,
+				glamor_pixmap_private *soruce_pixmap_priv,
+				glamor_pixmap_private *mask_pixmap_priv,
+				glamor_pixmap_private *dest_pixmap_priv,
+				RegionPtr region,
+				int x_source,
+				int y_source,
+				int x_mask,
+				int y_mask,
+				int x_dest,
+				int y_dest);
+
 void glamor_composite(CARD8 op,
 		      PicturePtr pSrc,
 		      PicturePtr pMask,
@@ -553,10 +733,7 @@ void glamor_composite(CARD8 op,
 		      INT16 xMask,
 		      INT16 yMask,
 		      INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);
-void glamor_trapezoids(CARD8 op,
-		       PicturePtr src, PicturePtr dst,
-		       PictFormatPtr mask_format, INT16 x_src, INT16 y_src,
-		       int ntrap, xTrapezoid * traps);
+
 void glamor_init_composite_shaders(ScreenPtr screen);
 void glamor_fini_composite_shaders(ScreenPtr screen);
 void glamor_composite_glyph_rects(CARD8 op,
@@ -568,7 +745,42 @@ void glamor_composite_rects (CARD8         op,
 			     xRenderColor  *color,
 			     int           nRect,
 			     xRectangle    *rects);
+void glamor_init_trapezoid_shader(ScreenPtr screen);
+void glamor_fini_trapezoid_shader(ScreenPtr screen);
+PicturePtr glamor_convert_gradient_picture(ScreenPtr screen,
+                                           PicturePtr source,
+                                           int x_source,
+                                           int y_source, int width, int height);
+
+Bool glamor_composite_choose_shader(CARD8 op,
+                                    PicturePtr source,
+                                    PicturePtr mask,
+                                    PicturePtr dest,
+			     	    glamor_pixmap_private *source_pixmap_priv,
+			     	    glamor_pixmap_private *mask_pixmap_priv,
+			     	    glamor_pixmap_private *dest_pixmap_priv,
+                                    struct shader_key *s_key,
+				    glamor_composite_shader **shader, 
+				    struct blendinfo *op_info,
+                                    PictFormatShort *psaved_source_format);
 
+void
+glamor_composite_set_shader_blend(glamor_pixmap_private *dest_priv,
+				  struct shader_key *key,
+				  glamor_composite_shader *shader,
+				  struct blendinfo *op_info);
+
+void glamor_setup_composite_vbo(ScreenPtr screen, int n_verts);
+void glamor_emit_composite_vert(ScreenPtr screen,
+                                const float *src_coords,
+                                const float *mask_coords,
+                                const float *dst_coords, int i);
+
+/* glamor_trapezoid.c */
+void glamor_trapezoids(CARD8 op,
+		       PicturePtr src, PicturePtr dst,
+		       PictFormatPtr mask_format, INT16 x_src, INT16 y_src,
+		       int ntrap, xTrapezoid * traps);
 
 /* glamor_tile.c */
 Bool glamor_tile(PixmapPtr pixmap, PixmapPtr tile,
@@ -578,8 +790,19 @@ Bool glamor_tile(PixmapPtr pixmap, PixmapPtr tile,
 void glamor_init_tile_shader(ScreenPtr screen);
 void glamor_fini_tile_shader(ScreenPtr screen);
 
+/* glamor_gradient.c */
 void glamor_init_gradient_shader(ScreenPtr screen);
 void glamor_fini_gradient_shader(ScreenPtr screen);
+PicturePtr glamor_generate_linear_gradient_picture(ScreenPtr screen,
+                                                   PicturePtr src_picture,
+                                                   int x_source, int y_source,
+                                                   int width, int height,
+                                                   PictFormatShort format);
+PicturePtr glamor_generate_radial_gradient_picture(ScreenPtr screen,
+                                                   PicturePtr src_picture,
+                                                   int x_source, int y_source,
+                                                   int width, int height,
+                                                   PictFormatShort format);
 
 /* glamor_triangles.c */
 void
@@ -644,7 +867,6 @@ Bool
 glamor_upload_sub_pixmap_to_texture(PixmapPtr pixmap, int x, int y, int w, int h,
 				    int stride, void *bits, int pbo);
 
-
 PixmapPtr
 glamor_get_sub_pixmap(PixmapPtr pixmap, int x, int y,
 		      int w, int h, glamor_access_t access);
@@ -652,6 +874,48 @@ void
 glamor_put_sub_pixmap(PixmapPtr sub_pixmap, PixmapPtr pixmap, int x, int y,
 		      int w, int h, glamor_access_t access);
 
+glamor_pixmap_clipped_regions *
+glamor_compute_clipped_regions(glamor_pixmap_private *priv, RegionPtr region,
+			       int *clipped_nbox, int repeat_type,
+			       int reverse, int upsidedown);
+
+glamor_pixmap_clipped_regions *
+glamor_compute_clipped_regions_ext(glamor_pixmap_private *pixmap_priv,
+				   RegionPtr region,
+				   int *n_region,
+				   int inner_block_w, int inner_block_h,
+			           int reverse, int upsidedown);
+
+glamor_pixmap_clipped_regions *
+glamor_compute_transform_clipped_regions(glamor_pixmap_private *priv, struct pixman_transform *transform,
+					 RegionPtr region, int *n_region, int dx, int dy, int repeat_type,
+			                 int reverse, int upsidedown);
+
+Bool
+glamor_composite_largepixmap_region(CARD8 op,
+			  PicturePtr source,
+			  PicturePtr mask,
+			  PicturePtr dest,
+			  glamor_pixmap_private * source_pixmap_priv,
+			  glamor_pixmap_private * mask_pixmap_priv,
+			  glamor_pixmap_private * dest_pixmap_priv,
+			  RegionPtr region, Bool force_clip,
+			  INT16 x_source,
+			  INT16 y_source,
+			  INT16 x_mask,
+			  INT16 y_mask,
+			  INT16 x_dest, INT16 y_dest,
+			  CARD16 width, CARD16 height);
+
+Bool
+glamor_get_transform_block_size(struct pixman_transform *transform,
+			   int block_w, int block_h,
+			   int *transformed_block_w,
+			   int *transformed_block_h);
+
+void
+glamor_get_transform_extent_from_box(struct pixman_box32 *temp_box,
+		struct pixman_transform *transform);
 
 /**
  * Upload a picture to gl texture. Similar to the
@@ -734,6 +998,13 @@ void
 glamor_poly_line(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
 		 DDXPointPtr ppt);
 
+void
+glamor_composite_rectangles(CARD8	 op,
+			 PicturePtr	 dst,
+			 xRenderColor	*color,
+			 int		 num_rects,
+			 xRectangle	*rects);
+
 #include"glamor_utils.h"
 
 /* Dynamic pixmap upload to texture if needed. 
@@ -744,8 +1015,14 @@ glamor_poly_line(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
  * this will increase performance obviously. */
 
 #define GLAMOR_PIXMAP_DYNAMIC_UPLOAD
-#ifndef GLAMOR_GLES2
-//#define GLAMOR_GRADIENT_SHADER
+#define GLAMOR_GRADIENT_SHADER
+//#define GLAMOR_TRAPEZOID_SHADER
+#define GLAMOR_TEXTURED_LARGE_PIXMAP 1
+#define WALKAROUND_LARGE_TEXTURE_MAP
+#if 0
+#define MAX_FBO_SIZE 32 /* For test purpose only. */
 #endif
+//#define GLYPHS_NO_EDEGEMAP_OVERLAP_CHECK
+#define GLYPHS_EDEGE_OVERLAP_LOOSE_CHECK
 
 #endif				/* GLAMOR_PRIV_H */
diff --git a/glamor_putimage.c b/glamor_putimage.c
index d1e3a83..34e86a1 100644
--- a/glamor_putimage.c
+++ b/glamor_putimage.c
@@ -295,9 +295,9 @@ _glamor_put_image(DrawablePtr drawable, GCPtr gc, int depth, int x, int y,
 
 		temp_pixmap_priv = glamor_get_pixmap_private(temp_pixmap);
 
-		if (pixmap_priv->is_picture) {
-			temp_pixmap_priv->pict_format = pixmap_priv->pict_format;
-			temp_pixmap_priv->is_picture = pixmap_priv->is_picture;
+		if (GLAMOR_PIXMAP_PRIV_IS_PICTURE(pixmap_priv)) {
+			temp_pixmap_priv->base.picture = pixmap_priv->base.picture;
+			temp_pixmap_priv->base.is_picture = pixmap_priv->base.is_picture;
 		}
 
 		glamor_upload_sub_pixmap_to_texture(temp_pixmap, 0, 0, w, h,
@@ -307,7 +307,7 @@ _glamor_put_image(DrawablePtr drawable, GCPtr gc, int depth, int x, int y,
 		glamor_destroy_pixmap(temp_pixmap);
 	} else
 		glamor_upload_sub_pixmap_to_texture(pixmap, x + drawable->x + x_off, y + drawable->y + y_off,
-						    w, h, pixmap->devKind, bits, 0);
+						    w, h, PixmapBytePad(w, depth), bits, 0);
 	ret = TRUE;
 	goto done;
 
diff --git a/glamor_render.c b/glamor_render.c
index b729e98..9b80295 100644
--- a/glamor_render.c
+++ b/glamor_render.c
@@ -37,20 +37,12 @@
 #ifdef RENDER
 #include "mipict.h"
 #include "fbpict.h"
-
-struct shader_key {
-	enum shader_source source;
-	enum shader_mask mask;
-	enum shader_in in;
-};
-
-struct blendinfo {
-	Bool dest_alpha;
-	Bool source_alpha;
-	GLenum source_blend;
-	GLenum dest_blend;
-};
-
+#if 0
+//#define DEBUGF(str, ...)  do {} while(0)
+#define DEBUGF(str, ...) ErrorF(str, ##__VA_ARGS__)
+//#define DEBUGRegionPrint(x) do {} while (0)
+#define DEBUGRegionPrint RegionPrint
+#endif
 static struct blendinfo composite_op_info[] = {
 	[PictOpClear] = {0, 0, GL_ZERO, GL_ZERO},
 	[PictOpSrc] = {0, 0, GL_ONE, GL_ZERO},
@@ -82,20 +74,20 @@ glamor_create_composite_fs(glamor_gl_dispatch * dispatch,
 	    "uniform int 			mask_repeat_mode;\n";
 	const char *relocate_texture =
 	    GLAMOR_DEFAULT_PRECISION
-	    "vec2 rel_tex_coord(vec2 texture, vec2 wh, int repeat) \n"
+	    "vec2 rel_tex_coord(vec2 texture, vec4 wh, int repeat) \n"
 	    "{\n"
 	    "   vec2 rel_tex; \n"
-	    "   rel_tex = texture * wh; \n"
+	    "   rel_tex = texture * wh.xy; \n"
 	    "	if (repeat == RepeatNone)\n"
 	    "		return rel_tex; \n"
 	    "   else if (repeat == RepeatNormal) \n"
-	    "   	rel_tex = floor(rel_tex) + (fract(rel_tex) / wh); \n"
+	    "   	rel_tex = floor(rel_tex) + (fract(rel_tex) / wh.xy); 	\n"
 	    "   else if(repeat == RepeatPad) { \n"
-	    "           if (rel_tex.x > 1.0) rel_tex.x = 1.0;		  \n"
-	    "		else if(rel_tex.x < 0.0) rel_tex.x = 0.0;		  \n"
-	    "           if (rel_tex.y > 1.0) rel_tex.y = 1.0;		  \n"
+	    "           if (rel_tex.x >= 1.0) rel_tex.x = 1.0 - wh.z * wh.x / 2.;  	\n"
+	    "		else if(rel_tex.x < 0.0) rel_tex.x = 0.0;	  	\n"
+	    "           if (rel_tex.y >= 1.0) rel_tex.y = 1.0 - wh.w * wh.y / 2.;	\n"
 	    "		else if(rel_tex.y < 0.0) rel_tex.y = 0.0;	\n"
-	    "   	rel_tex = rel_tex / wh; \n"
+	    "   	rel_tex = rel_tex / wh.xy; \n"
 	    "    } \n"
 	    "   else if(repeat == RepeatReflect) {\n"
 	    "		if ((1.0 - mod(abs(floor(rel_tex.x)), 2.0)) < 0.001)\n"
@@ -112,14 +104,14 @@ glamor_create_composite_fs(glamor_gl_dispatch * dispatch,
 	/* The texture and the pixmap size is not match eaxctly, so can't sample it directly.
 	 * rel_sampler will recalculate the texture coords.*/
 	const char *rel_sampler =
-	    " vec4 rel_sampler(sampler2D tex_image, vec2 tex, vec2 wh, int repeat, int set_alpha)\n"
+	    " vec4 rel_sampler(sampler2D tex_image, vec2 tex, vec4 wh, int repeat, int set_alpha)\n"
 	    "{\n"
 	    "	tex = rel_tex_coord(tex, wh, repeat - RepeatFix);\n"
 	    "   if (repeat == RepeatFix) {\n"
-	    "		if (!(tex.x >= 0.0 && tex.x <= 1.0 \n"
-	    "		    && tex.y >= 0.0 && tex.y <= 1.0))\n"
+	    "		if (!(tex.x >= 0.0 && tex.x < 1.0 \n"
+	    "		    && tex.y >= 0.0 && tex.y < 1.0))\n"
 	    "			return vec4(0.0, 0.0, 0.0, set_alpha);\n"
-	    "		tex = (fract(tex) / wh);\n"
+	    "		tex = (fract(tex) / wh.xy);\n"
 	    "	}\n"
 	    "	if (set_alpha != 1)\n"
 	    "		return texture2D(tex_image, tex);\n"
@@ -135,7 +127,7 @@ glamor_create_composite_fs(glamor_gl_dispatch * dispatch,
 	    GLAMOR_DEFAULT_PRECISION
 	    "varying vec2 source_texture;\n"
 	    "uniform sampler2D source_sampler;\n"
-	    "uniform vec2 source_wh;"
+	    "uniform vec4 source_wh;"
 	    "vec4 get_source()\n"
 	    "{\n"
 	    "   if (source_repeat_mode < RepeatFix)\n"
@@ -147,7 +139,7 @@ glamor_create_composite_fs(glamor_gl_dispatch * dispatch,
 	const char *source_pixmap_fetch =
 	    GLAMOR_DEFAULT_PRECISION "varying vec2 source_texture;\n"
 	    "uniform sampler2D source_sampler;\n"
-	    "uniform vec2 source_wh;\n"
+	    "uniform vec4 source_wh;\n"
 	    "vec4 get_source()\n"
 	    "{\n"
 	    "   if (source_repeat_mode < RepeatFix) \n"
@@ -162,7 +154,7 @@ glamor_create_composite_fs(glamor_gl_dispatch * dispatch,
 	const char *mask_alpha_pixmap_fetch =
 	    GLAMOR_DEFAULT_PRECISION "varying vec2 mask_texture;\n"
 	    "uniform sampler2D mask_sampler;\n"
-	    "uniform vec2 mask_wh;\n"
+	    "uniform vec4 mask_wh;\n"
 	    "vec4 get_mask()\n"
 	    "{\n"
 	    "   if (mask_repeat_mode < RepeatFix) \n"
@@ -174,7 +166,7 @@ glamor_create_composite_fs(glamor_gl_dispatch * dispatch,
 	const char *mask_pixmap_fetch =
 	    GLAMOR_DEFAULT_PRECISION "varying vec2 mask_texture;\n"
 	    "uniform sampler2D mask_sampler;\n"
-	    "uniform vec2 mask_wh;\n"
+	    "uniform vec4 mask_wh;\n"
 	    "vec4 get_mask()\n"
 	    "{\n"
 	    "   if (mask_repeat_mode < RepeatFix) \n"
@@ -380,8 +372,6 @@ glamor_lookup_composite_shader(ScreenPtr screen, struct
 	return shader;
 }
 
-#define GLAMOR_COMPOSITE_VBO_VERT_CNT 1024
-
 static void
 glamor_init_eb(unsigned short *eb, int vert_cnt)
 {
@@ -483,13 +473,11 @@ glamor_fini_composite_shaders(ScreenPtr screen)
 
 static Bool
 glamor_set_composite_op(ScreenPtr screen,
-			CARD8 op, PicturePtr dest, PicturePtr mask)
+			CARD8 op, struct blendinfo *op_info_result,
+			PicturePtr dest, PicturePtr mask)
 {
 	GLenum source_blend, dest_blend;
 	struct blendinfo *op_info;
-	glamor_screen_private *glamor_priv =
-	    glamor_get_screen_private(screen);
-	glamor_gl_dispatch *dispatch;
 
 	if (op >= ARRAY_SIZE(composite_op_info)) {
 		glamor_fallback("unsupported render op %d \n", op);
@@ -520,32 +508,27 @@ glamor_set_composite_op(ScreenPtr screen,
 			dest_blend = GL_ONE_MINUS_SRC_COLOR;
 	}
 
-	dispatch = glamor_get_dispatch(glamor_priv);
-	if (source_blend == GL_ONE && dest_blend == GL_ZERO) {
-		dispatch->glDisable(GL_BLEND);
-	} else {
-		dispatch->glEnable(GL_BLEND);
-		dispatch->glBlendFunc(source_blend, dest_blend);
-	}
-	glamor_put_dispatch(glamor_priv);
+	op_info_result->source_blend = source_blend;
+	op_info_result->dest_blend = dest_blend;
+	op_info_result->source_alpha = op_info->source_alpha;
+	op_info_result->dest_alpha = op_info->dest_alpha;
+
 	return TRUE;
 }
 
 static void
-glamor_set_composite_texture(ScreenPtr screen, int unit,
+glamor_set_composite_texture(glamor_screen_private *glamor_priv, int unit,
 			     PicturePtr picture,
 			     glamor_pixmap_private * pixmap_priv,
 			     GLuint wh_location, GLuint repeat_location)
 {
-	glamor_screen_private *glamor_priv =
-	    glamor_get_screen_private(screen);
 	glamor_gl_dispatch *dispatch;
-	float wh[2];
+	float wh[4];
 	int repeat_type;
 
 	dispatch = glamor_get_dispatch(glamor_priv);
 	dispatch->glActiveTexture(GL_TEXTURE0 + unit);
-	dispatch->glBindTexture(GL_TEXTURE_2D, pixmap_priv->fbo->tex);
+	dispatch->glBindTexture(GL_TEXTURE_2D, pixmap_priv->base.fbo->tex);
 	repeat_type = picture->repeatType;
 	switch (picture->repeatType) {
 	case RepeatNone:
@@ -604,20 +587,27 @@ glamor_set_composite_texture(ScreenPtr screen, int unit,
 #ifndef GLAMOR_GLES2
 	dispatch->glEnable(GL_TEXTURE_2D);
 #endif
-	/* XXX may be we can eaxctly check whether we need to touch
-	 * the out-of-box area then determine whether we need to fix.
-	 * */
+
+	/*
+	 *  GLES2 doesn't support RepeatNone. We need to fix it anyway.
+	 *
+	 **/
 	if (repeat_type != RepeatNone)
 		repeat_type += RepeatFix;
-	else if (glamor_priv->gl_flavor == GLAMOR_GL_ES2) {
+	else if (glamor_priv->gl_flavor == GLAMOR_GL_ES2
+		 || pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
 		if (picture->transform
 		   || (GLAMOR_PIXMAP_FBO_NOT_EAXCT_SIZE(pixmap_priv)))
 			repeat_type += RepeatFix;
 	}
-
 	if (repeat_type >= RepeatFix) {
 		glamor_pixmap_fbo_fix_wh_ratio(wh, pixmap_priv);
-		dispatch->glUniform2fv(wh_location, 1, wh);
+		if ((wh[0] != 1.0 || wh[1] != 1.0 )
+		     || (glamor_priv->gl_flavor == GLAMOR_GL_ES2
+			  && repeat_type == RepeatFix))
+			dispatch->glUniform4fv(wh_location, 1, wh);
+		else
+			repeat_type -= RepeatFix;
 	}
 	dispatch->glUniform1i(repeat_location, repeat_type);
 	glamor_put_dispatch(glamor_priv);
@@ -687,82 +677,85 @@ glamor_composite_with_copy(CARD8 op,
 			   INT16 x_source,
 			   INT16 y_source,
 			   INT16 x_dest,
-			   INT16 y_dest, CARD16 width, CARD16 height)
+			   INT16 y_dest,
+			   RegionPtr region)
 {
-	RegionRec region;
 	int ret = FALSE;
-
 	if (!source->pDrawable)
 		return FALSE;
 
 	if (!compatible_formats(op, dest, source))
 		return FALSE;
 
-	if (source->repeat || source->transform)
+	if (source->repeat || source->transform) {
 		return FALSE;
+	}
 
 	x_dest += dest->pDrawable->x;
 	y_dest += dest->pDrawable->y;
 	x_source += source->pDrawable->x;
 	y_source += source->pDrawable->y;
-	if (!miComputeCompositeRegion(&region,
-				      source, NULL, dest,
-				      x_source, y_source,
-				      0, 0, x_dest, y_dest, width, height))
-		return TRUE;
-
 	if (PICT_FORMAT_A(source->format) == 0) {
 		/* Fallback if we sample outside the source so that we
 		 * swizzle the correct clear color for out-of-bounds texels.
 		 */
-		if (region.extents.x1 + x_source - x_dest < 0)
+		if (region->extents.x1 + x_source - x_dest < 0)
 			goto cleanup_region;
-		if (region.extents.x2 + x_source - x_dest > source->pDrawable->width)
+		if (region->extents.x2 + x_source - x_dest > source->pDrawable->width)
 			goto cleanup_region;
 
-		if (region.extents.y1 + y_source - y_dest < 0)
+		if (region->extents.y1 + y_source - y_dest < 0)
 			goto cleanup_region;
-		if (region.extents.y2 + y_source - y_dest > source->pDrawable->height)
+		if (region->extents.y2 + y_source - y_dest > source->pDrawable->height)
 			goto cleanup_region;
 	}
-
 	ret = glamor_copy_n_to_n_nf(source->pDrawable,
 				    dest->pDrawable, NULL,
-				    REGION_RECTS(&region),
-				    REGION_NUM_RECTS(&region),
+				    RegionRects(region), RegionNumRects(region),
 				    x_source - x_dest, y_source - y_dest,
 				    FALSE, FALSE, 0, NULL);
 cleanup_region:
-	REGION_UNINIT(dest->pDrawable->pScreen, &region);
 	return ret;
 }
 
-static void
+void
 glamor_setup_composite_vbo(ScreenPtr screen, int n_verts)
 {
 	glamor_screen_private *glamor_priv =
 	    glamor_get_screen_private(screen);
 	glamor_gl_dispatch *dispatch;
+	int vert_size;
 
-	glamor_priv->vbo_offset = 0;
-	glamor_priv->vbo_offset = 0;
 	glamor_priv->render_nr_verts = 0;
-	glamor_priv->vbo_size = n_verts * sizeof(float) * 2;
-
 	glamor_priv->vb_stride = 2 * sizeof(float);
 	if (glamor_priv->has_source_coords)
 		glamor_priv->vb_stride += 2 * sizeof(float);
 	if (glamor_priv->has_mask_coords)
 		glamor_priv->vb_stride += 2 * sizeof(float);
 
+	vert_size = n_verts * glamor_priv->vb_stride;
+
 	dispatch = glamor_get_dispatch(glamor_priv);
 	dispatch->glBindBuffer(GL_ARRAY_BUFFER, glamor_priv->vbo);
 	if (glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP) {
-		dispatch->glBufferData(GL_ARRAY_BUFFER,
-				       n_verts * sizeof(float) * 2,
-				       NULL, GL_DYNAMIC_DRAW);
-		glamor_priv->vb = dispatch->glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
-	}
+		if (glamor_priv->vbo_size < (glamor_priv->vbo_offset + vert_size)) {
+			glamor_priv->vbo_size = GLAMOR_COMPOSITE_VBO_VERT_CNT *
+				glamor_priv->vb_stride;
+			glamor_priv->vbo_offset = 0;
+			dispatch->glBufferData(GL_ARRAY_BUFFER,
+					       glamor_priv->vbo_size,
+					       NULL, GL_STREAM_DRAW);
+		}
+
+		glamor_priv->vb = dispatch->glMapBufferRange(GL_ARRAY_BUFFER,
+							     glamor_priv->vbo_offset,
+							     vert_size,
+							     GL_MAP_WRITE_BIT | GL_MAP_UNSYNCHRONIZED_BIT);
+		assert(glamor_priv->vb != NULL);
+		glamor_priv->vb -= glamor_priv->vbo_offset;
+	} else
+		glamor_priv->vbo_offset = 0;
+
 	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, glamor_priv->ebo);
 
 	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_POS, 2, GL_FLOAT,
@@ -798,7 +791,7 @@ glamor_setup_composite_vbo(ScreenPtr screen, int n_verts)
 	glamor_put_dispatch(glamor_priv);
 }
 
-static void
+void
 glamor_emit_composite_vert(ScreenPtr screen,
 			   const float *src_coords,
 			   const float *mask_coords,
@@ -824,6 +817,8 @@ glamor_emit_composite_vert(ScreenPtr screen,
 	glamor_priv->vbo_offset += glamor_priv->vb_stride;
 }
 
+
+
 static void
 glamor_flush_composite_rects(ScreenPtr screen)
 {
@@ -831,9 +826,6 @@ glamor_flush_composite_rects(ScreenPtr screen)
 	    glamor_get_screen_private(screen);
 	glamor_gl_dispatch *dispatch;
 
-	if (!glamor_priv->render_nr_verts)
-		return;
-
 	dispatch = glamor_get_dispatch(glamor_priv);
 	if (glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP)
 		dispatch->glUnmapBuffer(GL_ARRAY_BUFFER);
@@ -845,27 +837,14 @@ glamor_flush_composite_rects(ScreenPtr screen)
 				       glamor_priv->vb, GL_DYNAMIC_DRAW);
 	}
 
+	if (!glamor_priv->render_nr_verts)
+		return;
+
 	dispatch->glDrawElements(GL_TRIANGLES, (glamor_priv->render_nr_verts * 3) / 2,
 				 GL_UNSIGNED_SHORT, NULL);
 	glamor_put_dispatch(glamor_priv);
 }
 
-static void
-glamor_emit_composite_rect(ScreenPtr screen,
-			   const float *src_coords,
-			   const float *mask_coords,
-			   const float *dst_coords)
-{
-	glamor_emit_composite_vert(screen, src_coords, mask_coords,
-				   dst_coords, 0);
-	glamor_emit_composite_vert(screen, src_coords, mask_coords,
-				   dst_coords, 1);
-	glamor_emit_composite_vert(screen, src_coords, mask_coords,
-				   dst_coords, 2);
-	glamor_emit_composite_vert(screen, src_coords, mask_coords,
-				   dst_coords, 3);
-}
-
 int pict_format_combine_tab[][3] = {
 	{PICT_TYPE_ARGB, PICT_TYPE_A, PICT_TYPE_ARGB},
 	{PICT_TYPE_ABGR, PICT_TYPE_A, PICT_TYPE_ABGR},
@@ -930,69 +909,100 @@ combine_pict_format(PictFormatShort * des, const PictFormatShort src,
 	return FALSE;
 }
 
-static Bool
-glamor_composite_with_shader(CARD8 op,
-			     PicturePtr source,
-			     PicturePtr mask,
-			     PicturePtr dest,
-			     int nrect, glamor_composite_rect_t * rects)
+static void
+glamor_set_normalize_tcoords_generic(glamor_pixmap_private *priv,
+				     int repeat_type,
+				     float *matrix,
+				     float xscale, float yscale,
+				     int x1, int y1, int x2, int y2,
+				     int yInverted, float *texcoords,
+				     int stride)
+{
+	if (!matrix && repeat_type == RepeatNone)
+		glamor_set_normalize_tcoords_ext(priv, xscale, yscale,
+					     x1, y1,
+					     x2, y2,
+					     yInverted,
+					     texcoords, stride);
+	else if (matrix && repeat_type == RepeatNone)
+		glamor_set_transformed_normalize_tcoords_ext(priv, matrix, xscale,
+							 yscale, x1, y1,
+							 x2, y2,
+							 yInverted,
+							 texcoords, stride);
+	else if (!matrix && repeat_type != RepeatNone)
+		glamor_set_repeat_normalize_tcoords_ext(priv, repeat_type,
+						    xscale, yscale,
+						    x1, y1,
+						    x2, y2,
+						    yInverted,
+						    texcoords, stride);
+	else if (matrix && repeat_type != RepeatNone)
+		glamor_set_repeat_transformed_normalize_tcoords_ext(priv, repeat_type,
+								matrix, xscale, yscale,
+								x1, y1,
+								x2, y2,
+								yInverted,
+								texcoords, stride);
+}
+
+Bool glamor_composite_choose_shader(CARD8 op,
+                                    PicturePtr source,
+                                    PicturePtr mask,
+                                    PicturePtr dest,
+			     	    glamor_pixmap_private *source_pixmap_priv,
+			     	    glamor_pixmap_private *mask_pixmap_priv,
+			     	    glamor_pixmap_private *dest_pixmap_priv,
+                                    struct shader_key *s_key,
+				    glamor_composite_shader **shader,
+				    struct blendinfo *op_info,
+                                    PictFormatShort *psaved_source_format)
 {
 	ScreenPtr screen = dest->pDrawable->pScreen;
-	glamor_screen_private *glamor_priv =
-	    glamor_get_screen_private(screen);
-	glamor_gl_dispatch *dispatch;
-	PixmapPtr dest_pixmap =
-	    glamor_get_drawable_pixmap(dest->pDrawable);
-	PixmapPtr source_pixmap = NULL, mask_pixmap = NULL;
-	glamor_pixmap_private *source_pixmap_priv = NULL;
-	glamor_pixmap_private *mask_pixmap_priv = NULL;
-	glamor_pixmap_private *dest_pixmap_priv = NULL;
-	GLfloat dst_xscale, dst_yscale;
-	GLfloat mask_xscale = 1, mask_yscale = 1, src_xscale =
-	    1, src_yscale = 1;
-	struct shader_key key;
-	glamor_composite_shader *shader;
-	float vertices[8], source_texcoords[8], mask_texcoords[8];
-	int dest_x_off, dest_y_off;
-	int source_x_off, source_y_off;
-	int mask_x_off, mask_y_off;
+	PixmapPtr dest_pixmap = dest_pixmap_priv->base.pixmap;
+	PixmapPtr source_pixmap = NULL;
+	PixmapPtr mask_pixmap = NULL;
 	enum glamor_pixmap_status source_status = GLAMOR_NONE;
 	enum glamor_pixmap_status mask_status = GLAMOR_NONE;
 	PictFormatShort saved_source_format = 0;
-	float src_matrix[9], mask_matrix[9];
-	GLfloat source_solid_color[4], mask_solid_color[4];
-	dest_pixmap_priv = glamor_get_pixmap_private(dest_pixmap);
-	int vert_stride = 4;
-	int nrect_max;
+	struct shader_key key;
+	GLfloat source_solid_color[4];
+	GLfloat mask_solid_color[4];
 	Bool ret = FALSE;
 
 	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(dest_pixmap_priv)) {
 		glamor_fallback("dest has no fbo.\n");
 		goto fail;
 	}
+
 	memset(&key, 0, sizeof(key));
-	if (!source->pDrawable) {
-		if (source->pSourcePict->type == SourcePictTypeSolidFill) {
-			key.source = SHADER_SOURCE_SOLID;
-			glamor_get_rgba_from_pixel(source->
-						   pSourcePict->solidFill.
-						   color,
-						   &source_solid_color[0],
-						   &source_solid_color[1],
-						   &source_solid_color[2],
-						   &source_solid_color[3],
-						   PICT_a8r8g8b8);
-		} else {
-			glamor_fallback("gradient source\n");
+	if (!source) {
+		key.source = SHADER_SOURCE_SOLID;
+		source_solid_color[0] = 0.0;
+		source_solid_color[1] = 0.0;
+		source_solid_color[2] = 0.0;
+		source_solid_color[3] = 0.0;
+	} else if (!source->pDrawable) {
+			if (source->pSourcePict->type == SourcePictTypeSolidFill) {
+				key.source = SHADER_SOURCE_SOLID;
+				glamor_get_rgba_from_pixel(source->
+							   pSourcePict->solidFill.
+							   color,
+							   &source_solid_color[0],
+							   &source_solid_color[1],
+							   &source_solid_color[2],
+							   &source_solid_color[3],
+							   PICT_a8r8g8b8);
+		} else
 			goto fail;
-		}
 	} else {
 		key.source = SHADER_SOURCE_TEXTURE_ALPHA;
 	}
+
 	if (mask) {
 		if (!mask->pDrawable) {
 			if (mask->pSourcePict->type ==
-			    SourcePictTypeSolidFill) {
+			     SourcePictTypeSolidFill) {
 				key.mask = SHADER_MASK_SOLID;
 				glamor_get_rgba_from_pixel
 				    (mask->pSourcePict->solidFill.color,
@@ -1000,10 +1010,8 @@ glamor_composite_with_shader(CARD8 op,
 				     &mask_solid_color[1],
 				     &mask_solid_color[2],
 				     &mask_solid_color[3], PICT_a8r8g8b8);
-			} else {
-				glamor_fallback("gradient mask\n");
+			} else
 				goto fail;
-			}
 		} else {
 			key.mask = SHADER_MASK_TEXTURE_ALPHA;
 		}
@@ -1014,14 +1022,13 @@ glamor_composite_with_shader(CARD8 op,
 			if (op == PictOpClear)
 				key.mask = SHADER_MASK_NONE;
 			else if (op == PictOpSrc || op == PictOpAdd
-				 || op == PictOpIn || op == PictOpOut
-				 || op == PictOpOverReverse)
+			         || op == PictOpIn || op == PictOpOut
+			         || op == PictOpOverReverse)
 				key.in = SHADER_IN_CA_SOURCE;
 			else if (op == PictOpOutReverse || op == PictOpInReverse) {
 				key.in = SHADER_IN_CA_ALPHA;
 			} else {
-				glamor_fallback
-				    ("Unsupported component alpha op: %d\n", op);
+				glamor_fallback("Unsupported component alpha op: %d\n", op);
 				goto fail;
 			}
 		}
@@ -1030,7 +1037,7 @@ glamor_composite_with_shader(CARD8 op,
 		key.in = SHADER_IN_SOURCE_ONLY;
 	}
 
-	if (source->alphaMap) {
+	if (source && source->alphaMap) {
 		glamor_fallback("source alphaMap\n");
 		goto fail;
 	}
@@ -1038,20 +1045,19 @@ glamor_composite_with_shader(CARD8 op,
 		glamor_fallback("mask alphaMap\n");
 		goto fail;
 	}
+
 	if (key.source == SHADER_SOURCE_TEXTURE ||
 	    key.source == SHADER_SOURCE_TEXTURE_ALPHA) {
-		source_pixmap =
-		    glamor_get_drawable_pixmap(source->pDrawable);
-		source_pixmap_priv =
-		    glamor_get_pixmap_private(source_pixmap);
+		source_pixmap = source_pixmap_priv->base.pixmap;
 		if (source_pixmap == dest_pixmap) {
+			/* XXX source and the dest share the same texture.
+			 * Does it need special handle? */
 			glamor_fallback("source == dest\n");
-			goto fail;
 		}
-		if (!source_pixmap_priv || source_pixmap_priv->gl_fbo == 0) {
-			/* XXX in Xephyr, we may have gl_fbo equal to 1 but gl_tex 
+		if (source_pixmap_priv->base.gl_fbo == 0) {
+			/* XXX in Xephyr, we may have gl_fbo equal to 1 but gl_tex
 			 * equal to zero when the pixmap is screen pixmap. Then we may
-			 * refer the tex zero directly latter in the composition. 
+			 * refer the tex zero directly latter in the composition.
 			 * It seems that it works fine, but it may have potential problem*/
 #ifdef GLAMOR_PIXMAP_DYNAMIC_UPLOAD
 			source_status = GLAMOR_UPLOAD_PENDING;
@@ -1061,15 +1067,15 @@ glamor_composite_with_shader(CARD8 op,
 #endif
 		}
 	}
+
 	if (key.mask == SHADER_MASK_TEXTURE ||
 	    key.mask == SHADER_MASK_TEXTURE_ALPHA) {
-		mask_pixmap = glamor_get_drawable_pixmap(mask->pDrawable);
-		mask_pixmap_priv = glamor_get_pixmap_private(mask_pixmap);
+		mask_pixmap = mask_pixmap_priv->base.pixmap;
 		if (mask_pixmap == dest_pixmap) {
 			glamor_fallback("mask == dest\n");
 			goto fail;
 		}
-		if (!mask_pixmap_priv || mask_pixmap_priv->gl_fbo == 0) {
+		if (mask_pixmap_priv->base.gl_fbo == 0) {
 #ifdef GLAMOR_PIXMAP_DYNAMIC_UPLOAD
 			mask_status = GLAMOR_UPLOAD_PENDING;
 #else
@@ -1078,49 +1084,48 @@ glamor_composite_with_shader(CARD8 op,
 #endif
 		}
 	}
+
 #ifdef GLAMOR_PIXMAP_DYNAMIC_UPLOAD
 	if (source_status == GLAMOR_UPLOAD_PENDING
-	    && mask_status == GLAMOR_UPLOAD_PENDING
-	    && source_pixmap == mask_pixmap) {
+	     && mask_status == GLAMOR_UPLOAD_PENDING
+	     && source_pixmap == mask_pixmap) {
 
 		if (source->format != mask->format) {
 			saved_source_format = source->format;
 
-			if (!combine_pict_format
-			    (&source->format, source->format,
-			     mask->format, key.in)) {
-				glamor_fallback
-				    ("combine source %x mask %x failed.\n",
-				     source->format, mask->format);
+			if (!combine_pict_format(&source->format, source->format,
+			                         mask->format, key.in)) {
+				glamor_fallback("combine source %x mask %x failed.\n",
+				                source->format, mask->format);
 				goto fail;
 			}
 
 			if (source->format != saved_source_format) {
 				glamor_picture_format_fixup(source,
-							    source_pixmap_priv);
+				        source_pixmap_priv);
 			}
-			/* XXX  
+			/* XXX
 			 * By default, glamor_upload_picture_to_texture will wire alpha to 1
-			 * if one picture doesn't have alpha. So we don't do that again in 
+			 * if one picture doesn't have alpha. So we don't do that again in
 			 * rendering function. But here is a special case, as source and
-			 * mask share the same texture but may have different formats. For 
+			 * mask share the same texture but may have different formats. For
 			 * example, source doesn't have alpha, but mask has alpha. Then the
 			 * texture will have the alpha value for the mask. And will not wire
 			 * to 1 for the source. In this case, we have to use different shader
 			 * to wire the source's alpha to 1.
 			 *
-			 * But this may cause a potential problem if the source's repeat mode 
+			 * But this may cause a potential problem if the source's repeat mode
 			 * is REPEAT_NONE, and if the source is smaller than the dest, then
 			 * for the region not covered by the source may be painted incorrectly.
 			 * because we wire the alpha to 1.
 			 *
 			 **/
 			if (!PICT_FORMAT_A(saved_source_format)
-			    && PICT_FORMAT_A(mask->format))
+			     && PICT_FORMAT_A(mask->format))
 				key.source = SHADER_SOURCE_TEXTURE;
 
 			if (!PICT_FORMAT_A(mask->format)
-			    && PICT_FORMAT_A(saved_source_format))
+			     && PICT_FORMAT_A(saved_source_format))
 				key.mask = SHADER_MASK_TEXTURE;
 
 			mask_status = GLAMOR_NONE;
@@ -1128,16 +1133,14 @@ glamor_composite_with_shader(CARD8 op,
 
 		source_status = glamor_upload_picture_to_texture(source);
 		if (source_status != GLAMOR_UPLOAD_DONE) {
-			glamor_fallback
-			    ("Failed to upload source texture.\n");
+			glamor_fallback("Failed to upload source texture.\n");
 			goto fail;
 		}
 	} else {
 		if (source_status == GLAMOR_UPLOAD_PENDING) {
 			source_status = glamor_upload_picture_to_texture(source);
 			if (source_status != GLAMOR_UPLOAD_DONE) {
-				glamor_fallback
-				    ("Failed to upload source texture.\n");
+				glamor_fallback("Failed to upload source texture.\n");
 				goto fail;
 			}
 		}
@@ -1145,8 +1148,7 @@ glamor_composite_with_shader(CARD8 op,
 		if (mask_status == GLAMOR_UPLOAD_PENDING) {
 			mask_status = glamor_upload_picture_to_texture(mask);
 			if (mask_status != GLAMOR_UPLOAD_DONE) {
-				glamor_fallback
-				    ("Failed to upload mask texture.\n");
+				glamor_fallback("Failed to upload mask texture.\n");
 				goto fail;
 			}
 		}
@@ -1157,77 +1159,200 @@ glamor_composite_with_shader(CARD8 op,
 	 * transformed source and mask, if the transform is not int translate. */
 	if (key.source != SHADER_SOURCE_SOLID
 	    && source->transform
-	    && !pixman_transform_is_int_translate(source->transform)) {
+	    && !pixman_transform_is_int_translate(source->transform)
+	    && source_pixmap_priv->type != GLAMOR_TEXTURE_LARGE) {
 		if (!glamor_fixup_pixmap_priv(screen, source_pixmap_priv))
 			goto fail;
 	}
 	if (key.mask != SHADER_MASK_NONE && key.mask != SHADER_MASK_SOLID
 	    && mask->transform
-	    && !pixman_transform_is_int_translate(mask->transform)) {
+	    && !pixman_transform_is_int_translate(mask->transform)
+	    && mask_pixmap_priv->type != GLAMOR_TEXTURE_LARGE) {
 		if (!glamor_fixup_pixmap_priv(screen, mask_pixmap_priv))
 			goto fail;
 	}
 
-	glamor_set_destination_pixmap_priv_nc(dest_pixmap_priv);
 
-	if (!glamor_set_composite_op(screen, op, dest, mask)) {
+	if (!glamor_set_composite_op(screen, op, op_info, dest, mask))
 		goto fail;
-	}
 
-	shader = glamor_lookup_composite_shader(screen, &key);
-	if (shader->prog == 0) {
-		glamor_fallback
-		    ("no shader program for this render acccel mode\n");
+	*shader = glamor_lookup_composite_shader(screen, &key);
+	if ((*shader)->prog == 0) {
+		glamor_fallback("no shader program for this"
+		                "render acccel mode\n");
 		goto fail;
 	}
 
+	if (key.source == SHADER_SOURCE_SOLID)
+		memcpy(&(*shader)->source_solid_color[0],
+			source_solid_color, 4*sizeof(float));
+	else {
+		(*shader)->source_priv = source_pixmap_priv;
+		(*shader)->source = source;
+	}
+
+	if (key.mask == SHADER_MASK_SOLID)
+		memcpy(&(*shader)->mask_solid_color[0],
+			mask_solid_color, 4*sizeof(float));
+	else {
+		(*shader)->mask_priv = mask_pixmap_priv;
+		(*shader)->mask = mask;
+	}
+
+	ret = TRUE;
+	memcpy(s_key, &key, sizeof(key));
+	*psaved_source_format = saved_source_format;
+	goto done;
+
+fail:
+	if (saved_source_format)
+		source->format = saved_source_format;
+done:
+	return ret;
+}
+
+void
+glamor_composite_set_shader_blend(glamor_pixmap_private *dest_priv,
+				  struct shader_key *key,
+				  glamor_composite_shader *shader,
+				  struct blendinfo *op_info)
+{
+	glamor_gl_dispatch *dispatch;
+	glamor_screen_private *glamor_priv;
+
+	glamor_priv = dest_priv->base.glamor_priv;
+
 	dispatch = glamor_get_dispatch(glamor_priv);
 	dispatch->glUseProgram(shader->prog);
 
-	if (key.source == SHADER_SOURCE_SOLID) {
-		glamor_set_composite_solid(dispatch, source_solid_color,
-					   shader->source_uniform_location);
+	if (key->source == SHADER_SOURCE_SOLID) {
+		glamor_set_composite_solid(dispatch,
+			shader->source_solid_color,
+		        shader->source_uniform_location);
 	} else {
-		glamor_set_composite_texture(screen, 0, source,
-					     source_pixmap_priv, shader->source_wh,
-					     shader->source_repeat_mode);
+		glamor_set_composite_texture(glamor_priv, 0,
+			shader->source,
+		        shader->source_priv, shader->source_wh,
+		        shader->source_repeat_mode);
 	}
-	if (key.mask != SHADER_MASK_NONE) {
-		if (key.mask == SHADER_MASK_SOLID) {
+
+	if (key->mask != SHADER_MASK_NONE) {
+		if (key->mask == SHADER_MASK_SOLID) {
 			glamor_set_composite_solid(dispatch,
-						   mask_solid_color,
-						   shader->mask_uniform_location);
+			        shader->mask_solid_color,
+			        shader->mask_uniform_location);
 		} else {
-			glamor_set_composite_texture(screen, 1, mask,
-						     mask_pixmap_priv, shader->mask_wh,
-						     shader->mask_repeat_mode);
+			glamor_set_composite_texture(glamor_priv, 1,
+				shader->mask,
+			        shader->mask_priv, shader->mask_wh,
+			        shader->mask_repeat_mode);
 		}
 	}
 
+	if (op_info->source_blend == GL_ONE
+	    && op_info->dest_blend == GL_ZERO) {
+		dispatch->glDisable(GL_BLEND);
+	} else {
+		dispatch->glEnable(GL_BLEND);
+		dispatch->glBlendFunc(op_info->source_blend,
+				      op_info->dest_blend);
+	}
+
+	glamor_put_dispatch(glamor_priv);
+}
+
+static Bool
+glamor_composite_with_shader(CARD8 op,
+			     PicturePtr source,
+			     PicturePtr mask,
+			     PicturePtr dest,
+			     glamor_pixmap_private *source_pixmap_priv,
+			     glamor_pixmap_private *mask_pixmap_priv,
+			     glamor_pixmap_private *dest_pixmap_priv,
+			     int nrect, glamor_composite_rect_t * rects,
+			     Bool two_pass_ca)
+{
+	ScreenPtr screen = dest->pDrawable->pScreen;
+	glamor_screen_private *glamor_priv = dest_pixmap_priv->base.glamor_priv;
+	PixmapPtr dest_pixmap = dest_pixmap_priv->base.pixmap;
+	PixmapPtr source_pixmap = NULL;
+	PixmapPtr mask_pixmap = NULL;
+	glamor_gl_dispatch *dispatch = NULL;
+	GLfloat dst_xscale, dst_yscale;
+	GLfloat mask_xscale = 1, mask_yscale = 1,
+	        src_xscale = 1, src_yscale = 1;
+	struct shader_key key, key_ca;
+	float *vertices;
+	int dest_x_off, dest_y_off;
+	int source_x_off, source_y_off;
+	int mask_x_off, mask_y_off;
+	PictFormatShort saved_source_format = 0;
+	float src_matrix[9], mask_matrix[9];
+	float *psrc_matrix = NULL, *pmask_matrix = NULL;
+	int vert_stride = 4;
+	int nrect_max;
+	Bool ret = FALSE;
+	glamor_composite_shader *shader = NULL, *shader_ca = NULL;
+	struct blendinfo op_info, op_info_ca;
+
+	if(!glamor_composite_choose_shader(op, source, mask, dest,
+					   source_pixmap_priv, mask_pixmap_priv,
+					   dest_pixmap_priv,
+	                                   &key, &shader, &op_info,
+					   &saved_source_format)) {
+		glamor_fallback("glamor_composite_choose_shader failed\n");
+		return ret;
+	}
+	if (two_pass_ca) {
+		if(!glamor_composite_choose_shader(PictOpAdd, source, mask, dest,
+						   source_pixmap_priv, mask_pixmap_priv,
+						   dest_pixmap_priv,
+						   &key_ca, &shader_ca, &op_info_ca,
+						   &saved_source_format)) {
+			glamor_fallback("glamor_composite_choose_shader failed\n");
+			return ret;
+		}
+	}
+
+	glamor_set_destination_pixmap_priv_nc(dest_pixmap_priv);
+	glamor_composite_set_shader_blend(dest_pixmap_priv, &key, shader, &op_info);
+
+	dispatch = glamor_get_dispatch(glamor_priv);
+
 	glamor_priv->has_source_coords = key.source != SHADER_SOURCE_SOLID;
 	glamor_priv->has_mask_coords = (key.mask != SHADER_MASK_NONE &&
 					key.mask != SHADER_MASK_SOLID);
 
+	dest_pixmap = glamor_get_drawable_pixmap(dest->pDrawable);
+	dest_pixmap_priv = glamor_get_pixmap_private(dest_pixmap);
 	glamor_get_drawable_deltas(dest->pDrawable, dest_pixmap,
 				   &dest_x_off, &dest_y_off);
-	pixmap_priv_get_scale(dest_pixmap_priv, &dst_xscale, &dst_yscale);
+	pixmap_priv_get_dest_scale(dest_pixmap_priv, &dst_xscale, &dst_yscale);
 
 	if (glamor_priv->has_source_coords) {
+		source_pixmap = source_pixmap_priv->base.pixmap;
 		glamor_get_drawable_deltas(source->pDrawable,
 					   source_pixmap, &source_x_off,
 					   &source_y_off);
 		pixmap_priv_get_scale(source_pixmap_priv, &src_xscale,
 				      &src_yscale);
-		glamor_picture_get_matrixf(source, src_matrix);
+		if (source->transform) {
+			psrc_matrix = src_matrix;
+			glamor_picture_get_matrixf(source, psrc_matrix);
+		}
 		vert_stride += 4;
 	}
 
 	if (glamor_priv->has_mask_coords) {
+		mask_pixmap = mask_pixmap_priv->base.pixmap;
 		glamor_get_drawable_deltas(mask->pDrawable, mask_pixmap,
 					   &mask_x_off, &mask_y_off);
 		pixmap_priv_get_scale(mask_pixmap_priv, &mask_xscale,
 				      &mask_yscale);
-		glamor_picture_get_matrixf(mask, mask_matrix);
+		if (mask->transform) {
+			pmask_matrix = mask_matrix;
+			glamor_picture_get_matrixf(mask, pmask_matrix);
+		}
 		vert_stride += 4;
 	}
 
@@ -1236,11 +1361,12 @@ glamor_composite_with_shader(CARD8 op,
 
 	while(nrect) {
 		int mrect, rect_processed;
+		int vb_stride;
 
 		mrect = nrect > nrect_max ? nrect_max : nrect ;
 		glamor_setup_composite_vbo(screen, mrect * vert_stride);
 		rect_processed = mrect;
-
+		vb_stride = glamor_priv->vb_stride/sizeof(float);
 		while (mrect--) {
 			INT16 x_source;
 			INT16 y_source;
@@ -1253,63 +1379,57 @@ glamor_composite_with_shader(CARD8 op,
 
 			x_dest = rects->x_dst + dest_x_off;
 			y_dest = rects->y_dst + dest_y_off;
-			x_source = rects->x_src + source_x_off;;
+			x_source = rects->x_src + source_x_off;
 			y_source = rects->y_src + source_y_off;
 			x_mask = rects->x_mask + mask_x_off;
 			y_mask = rects->y_mask + mask_y_off;
 			width = rects->width;
 			height = rects->height;
 
-			glamor_set_normalize_vcoords(dst_xscale,
+			DEBUGF("dest(%d,%d) source(%d %d) mask (%d %d), width %d height %d \n",
+				x_dest, y_dest, x_source, y_source,x_mask,y_mask,width,height);
+			vertices = (float*)(glamor_priv->vb + glamor_priv->vbo_offset);
+			assert(glamor_priv->vbo_offset < glamor_priv->vbo_size - glamor_priv->vb_stride);
+			glamor_set_normalize_vcoords_ext(dest_pixmap_priv, dst_xscale,
 						     dst_yscale,
 						     x_dest, y_dest,
 						     x_dest + width, y_dest + height,
 						     glamor_priv->yInverted,
-						     vertices);
-
+						     vertices, vb_stride);
+			vertices += 2;
 			if (key.source != SHADER_SOURCE_SOLID) {
-				if (source->transform)
-					glamor_set_transformed_normalize_tcoords
-						(src_matrix, src_xscale,
-						 src_yscale, x_source, y_source,
-						 x_source + width, y_source + height,
-						 glamor_priv->yInverted,
-						 source_texcoords);
-				else
-					glamor_set_normalize_tcoords
-						(src_xscale, src_yscale,
-						 x_source, y_source,
-						 x_source + width, y_source + height,
-						 glamor_priv->yInverted,
-						 source_texcoords);
+				glamor_set_normalize_tcoords_generic(
+					source_pixmap_priv, source->repeatType, psrc_matrix,
+					src_xscale, src_yscale, x_source, y_source,
+					x_source + width, y_source + height,
+					glamor_priv->yInverted, vertices, vb_stride);
+				vertices += 2;
 			}
 
 			if (key.mask != SHADER_MASK_NONE
 			    && key.mask != SHADER_MASK_SOLID) {
-				if (mask->transform)
-					glamor_set_transformed_normalize_tcoords
-						(mask_matrix,
-						 mask_xscale,
-						 mask_yscale, x_mask, y_mask,
-						 x_mask + width, y_mask + height,
-						 glamor_priv->yInverted,
-						 mask_texcoords);
-				else
-					glamor_set_normalize_tcoords
-						(mask_xscale,
-						 mask_yscale, x_mask, y_mask,
-						 x_mask + width, y_mask + height,
-						 glamor_priv->yInverted,
-						 mask_texcoords);
+				glamor_set_normalize_tcoords_generic(
+					mask_pixmap_priv, mask->repeatType, pmask_matrix,
+					mask_xscale, mask_yscale, x_mask, y_mask,
+					x_mask + width, y_mask + height,
+					glamor_priv->yInverted, vertices, vb_stride);
 			}
-			glamor_emit_composite_rect(screen,
-						   source_texcoords,
-						   mask_texcoords,
-						   vertices);
+			glamor_priv->render_nr_verts += 4;
+			glamor_priv->vbo_offset += glamor_priv->vb_stride * 4;
 			rects++;
 		}
 		glamor_flush_composite_rects(screen);
 		nrect -= rect_processed;
+		if (two_pass_ca) {
+			glamor_composite_set_shader_blend(dest_pixmap_priv,
+							&key_ca, shader_ca,
+							&op_info_ca);
+			glamor_flush_composite_rects(screen);
+			if (nrect)
+				glamor_composite_set_shader_blend(dest_pixmap_priv,
+								&key, shader,
+								&op_info);
+		}
 	}
 
 	dispatch->glBindBuffer(GL_ARRAY_BUFFER, 0);
@@ -1324,1748 +1444,152 @@ glamor_composite_with_shader(CARD8 op,
 	dispatch->glActiveTexture(GL_TEXTURE1);
 	dispatch->glDisable(GL_TEXTURE_2D);
 #endif
+	DEBUGF("finish rendering.\n");
 	dispatch->glUseProgram(0);
+	glamor_priv->state = RENDER_STATE;
+	glamor_priv->render_idle_cnt = 0;
 	if (saved_source_format)
 		source->format = saved_source_format;
 	glamor_put_dispatch(glamor_priv);
 
 	ret = TRUE;
-	goto done;
-
-fail:
-	if (saved_source_format)
-		source->format = saved_source_format;
-done:
 	return ret;
 }
 
-#ifdef GLAMOR_GRADIENT_SHADER
-static GLint
-_glamor_create_getcolor_fs_program(ScreenPtr screen, int stops_count, int use_array)
+PicturePtr
+glamor_convert_gradient_picture(ScreenPtr screen,
+                                PicturePtr source,
+                                int x_source,
+                                int y_source, int width, int height)
 {
-	glamor_screen_private *glamor_priv;
-	glamor_gl_dispatch *dispatch;
-
-	char *gradient_fs = NULL;
-	GLint fs_getcolor_prog;
+	PixmapPtr pixmap;
+	PicturePtr dst = NULL;
+	int error;
+	PictFormatShort format;
+	if (!source->pDrawable)
+		format = PICT_a8r8g8b8;
+	else
+		format = source->format;
+#ifdef GLAMOR_GRADIENT_SHADER
+	if (!source->pDrawable) {
+		if (source->pSourcePict->type == SourcePictTypeLinear) {
+			dst = glamor_generate_linear_gradient_picture(screen,
+				source, x_source, y_source, width, height, format);
+		} else if (source->pSourcePict->type == SourcePictTypeRadial) {
+			dst = glamor_generate_radial_gradient_picture(screen,
+		                  source, x_source, y_source, width, height, format);
+		}
 
-	const char *gradient_fs_getcolor =
-	    GLAMOR_DEFAULT_PRECISION
-	    "uniform int n_stop;\n"
-	    "uniform float stops[%d];\n"
-	    "uniform vec4 stop_colors[%d];\n"
-	    "vec4 get_color(float stop_len)\n"
-	    "{\n"
-	    "    int i = 0;\n"
-	    "    float new_alpha; \n"
-	    "    vec4 gradient_color;\n"
-	    "    float percentage; \n"
-	    "    for(i = 0; i < n_stop - 1; i++) {\n"
-	    "        if(stop_len < stops[i])\n"
-	    "            break; \n"
-	    "    }\n"
-	    "    \n"
-	    "    percentage = (stop_len - stops[i-1])/(stops[i] - stops[i-1]);\n"
-	    "    if(stops[i] - stops[i-1] > 2.0)\n"
-	    "        percentage = 0.0;\n" //For comply with pixman, walker->stepper overflow.
-	    "    new_alpha = percentage * stop_colors[i].a + \n"
-	    "                       (1.0-percentage) * stop_colors[i-1].a; \n"
-	    "    gradient_color = vec4((percentage * stop_colors[i].rgb \n"
-	    "                          + (1.0-percentage) * stop_colors[i-1].rgb)*new_alpha, \n"
-	    "                          new_alpha);\n"
-	    "    \n"
-	    "    return gradient_color;\n"
-	    "}\n";
+		if (dst) {
+#if 0			/* Debug to compare it to pixman, Enable it if needed. */
+			glamor_compare_pictures(screen, source,
+					dst, x_source, y_source, width, height,
+					0, 3);
+#endif
+			return dst;
+		}
+	}
+#endif
+	pixmap = glamor_create_pixmap(screen,
+				      width,
+				      height,
+				      PIXMAN_FORMAT_DEPTH(format),
+				      GLAMOR_CREATE_PIXMAP_CPU);
 
-	/* Because the array access for shader is very slow, the performance is very low
-	   if use array. So use global uniform to replace for it if the number of n_stops is small.*/
-	const char *gradient_fs_getcolor_no_array =
-	    GLAMOR_DEFAULT_PRECISION
-	    "uniform int n_stop;\n"
-	    "uniform float stop0;\n"
-	    "uniform float stop1;\n"
-	    "uniform float stop2;\n"
-	    "uniform float stop3;\n"
-	    "uniform float stop4;\n"
-	    "uniform float stop5;\n"
-	    "uniform float stop6;\n"
-	    "uniform float stop7;\n"
-	    "uniform vec4 stop_color0;\n"
-	    "uniform vec4 stop_color1;\n"
-	    "uniform vec4 stop_color2;\n"
-	    "uniform vec4 stop_color3;\n"
-	    "uniform vec4 stop_color4;\n"
-	    "uniform vec4 stop_color5;\n"
-	    "uniform vec4 stop_color6;\n"
-	    "uniform vec4 stop_color7;\n"
-	    "\n"
-	    "vec4 get_color(float stop_len)\n"
-	    "{\n"
-	    "    float stop_after;\n"
-	    "    float stop_before;\n"
-	    "    vec4 stop_color_before;\n"
-	    "    vec4 stop_color_after;\n"
-	    "    float new_alpha; \n"
-	    "    vec4 gradient_color;\n"
-	    "    float percentage; \n"
-	    "    \n"
-	    "    if((stop_len < stop0) && (n_stop >= 1)) {\n"
-	    "        stop_color_before = stop_color0;\n"
-	    "        stop_color_after = stop_color0;\n"
-	    "        stop_after = stop0;\n"
-	    "        stop_before = stop0;\n"
-	    "        percentage = 0.0;\n"
-	    "    } else if((stop_len < stop1) && (n_stop >= 2)) {\n"
-	    "        stop_color_before = stop_color0;\n"
-	    "        stop_color_after = stop_color1;\n"
-	    "        stop_after = stop1;\n"
-	    "        stop_before = stop0;\n"
-	    "        percentage = (stop_len - stop0)/(stop1 - stop0);\n"
-	    "    } else if((stop_len < stop2) && (n_stop >= 3)) {\n"
-	    "        stop_color_before = stop_color1;\n"
-	    "        stop_color_after = stop_color2;\n"
-	    "        stop_after = stop2;\n"
-	    "        stop_before = stop1;\n"
-	    "        percentage = (stop_len - stop1)/(stop2 - stop1);\n"
-	    "    } else if((stop_len < stop3) && (n_stop >= 4)){\n"
-	    "        stop_color_before = stop_color2;\n"
-	    "        stop_color_after = stop_color3;\n"
-	    "        stop_after = stop3;\n"
-	    "        stop_before = stop2;\n"
-	    "        percentage = (stop_len - stop2)/(stop3 - stop2);\n"
-	    "    } else if((stop_len < stop4) && (n_stop >= 5)){\n"
-	    "        stop_color_before = stop_color3;\n"
-	    "        stop_color_after = stop_color4;\n"
-	    "        stop_after = stop4;\n"
-	    "        stop_before = stop3;\n"
-	    "        percentage = (stop_len - stop3)/(stop4 - stop3);\n"
-	    "    } else if((stop_len < stop5) && (n_stop >= 6)){\n"
-	    "        stop_color_before = stop_color4;\n"
-	    "        stop_color_after = stop_color5;\n"
-	    "        stop_after = stop5;\n"
-	    "        stop_before = stop4;\n"
-	    "        percentage = (stop_len - stop4)/(stop5 - stop4);\n"
-	    "    } else if((stop_len < stop6) && (n_stop >= 7)){\n"
-	    "        stop_color_before = stop_color5;\n"
-	    "        stop_color_after = stop_color6;\n"
-	    "        stop_after = stop6;\n"
-	    "        stop_before = stop5;\n"
-	    "        percentage = (stop_len - stop5)/(stop6 - stop5);\n"
-	    "    } else if((stop_len < stop7) && (n_stop >= 8)){\n"
-	    "        stop_color_before = stop_color6;\n"
-	    "        stop_color_after = stop_color7;\n"
-	    "        stop_after = stop7;\n"
-	    "        stop_before = stop6;\n"
-	    "        percentage = (stop_len - stop6)/(stop7 - stop6);\n"
-	    "    } else {\n"
-	    "        stop_color_before = stop_color7;\n"
-	    "        stop_color_after = stop_color7;\n"
-	    "        stop_after = stop7;\n"
-	    "        stop_before = stop7;\n"
-	    "        percentage = 0.0;\n"
-	    "    }\n"
-	    "    if(stop_after - stop_before > 2.0)\n"
-	    "        percentage = 0.0;\n"//For comply with pixman, walker->stepper overflow.
-	    "    new_alpha = percentage * stop_color_after.a + \n"
-	    "                       (1.0-percentage) * stop_color_before.a; \n"
-	    "    gradient_color = vec4((percentage * stop_color_after.rgb \n"
-	    "                          + (1.0-percentage) * stop_color_before.rgb)*new_alpha, \n"
-	    "                          new_alpha);\n"
-	    "    \n"
-	    "    return gradient_color;\n"
-	    "}\n";
+	if (!pixmap)
+		return NULL;
 
-	glamor_priv = glamor_get_screen_private(screen);
-	dispatch = glamor_get_dispatch(glamor_priv);
+	dst = CreatePicture(0,
+	                    &pixmap->drawable,
+	                    PictureMatchFormat(screen,
+	                                       PIXMAN_FORMAT_DEPTH(format),
+	                                       format),
+	                    0, 0, serverClient, &error);
+	glamor_destroy_pixmap(pixmap);
+	if (!dst)
+		return NULL;
 
-	if(use_array) {
-		XNFasprintf(&gradient_fs,
-		    gradient_fs_getcolor, stops_count, stops_count);
-		fs_getcolor_prog = glamor_compile_glsl_prog(dispatch, GL_FRAGMENT_SHADER,
-		                                            gradient_fs);
-		free(gradient_fs);
-	} else {
-		fs_getcolor_prog = glamor_compile_glsl_prog(dispatch, GL_FRAGMENT_SHADER,
-		                                            gradient_fs_getcolor_no_array);
-	}
+	ValidatePicture(dst);
 
-	return fs_getcolor_prog;
+	fbComposite(PictOpSrc, source, NULL, dst, x_source, y_source,
+	            0, 0, 0, 0, width, height);
+	return dst;
 }
 
-static void
-_glamor_create_radial_gradient_program(ScreenPtr screen, int stops_count, int dyn_gen)
+Bool
+glamor_composite_clipped_region(CARD8 op,
+				PicturePtr source,
+				PicturePtr mask,
+				PicturePtr dest,
+				glamor_pixmap_private *source_pixmap_priv,
+				glamor_pixmap_private *mask_pixmap_priv,
+				glamor_pixmap_private *dest_pixmap_priv,
+				RegionPtr region,
+				int x_source,
+				int y_source,
+				int x_mask,
+				int y_mask,
+				int x_dest,
+				int y_dest)
 {
-	glamor_screen_private *glamor_priv;
-	glamor_gl_dispatch *dispatch;
-	int index;
+	ScreenPtr screen = dest->pDrawable->pScreen;
+	PixmapPtr source_pixmap = NULL, mask_pixmap = NULL;
+	PicturePtr temp_src = source, temp_mask = mask;
+	glamor_pixmap_private *temp_src_priv = source_pixmap_priv;
+	glamor_pixmap_private *temp_mask_priv = mask_pixmap_priv;
+	int x_temp_src, y_temp_src, x_temp_mask, y_temp_mask;
+	BoxPtr extent;
+	glamor_composite_rect_t rect[10];
+	glamor_composite_rect_t *prect = rect;
+	int prect_size = ARRAY_SIZE(rect);
+	int ok = FALSE;
+	int i;
+	int width;
+	int height;
+	BoxPtr box;
+	int nbox;
+	Bool two_pass_ca = FALSE;
 
-	GLint gradient_prog = 0;
-	char *gradient_fs = NULL;
-	GLint fs_main_prog, fs_getcolor_prog, vs_prog;
+	extent = RegionExtents(region);
+	box = RegionRects(region);
+	nbox = RegionNumRects(region);
+	width = extent->x2 - extent->x1;
+	height = extent->y2 - extent->y1;
 
-	const char *gradient_vs =
-	    GLAMOR_DEFAULT_PRECISION
-	    "attribute vec4 v_position;\n"
-	    "attribute vec4 v_texcoord;\n"
-	    "varying vec2 source_texture;\n"
-	    "\n"
-	    "void main()\n"
-	    "{\n"
-	    "    gl_Position = v_position;\n"
-	    "    source_texture = v_texcoord.xy;\n"
-	    "}\n";
+	x_temp_src = x_source;
+	y_temp_src = y_source;
+	x_temp_mask = x_mask;
+	y_temp_mask = y_mask;
 
-	/*
-	 *     Refer to pixman radial gradient.
-	 *
-	 *     The problem is given the two circles of c1 and c2 with the radius of r1 and
-	 *     r1, we need to caculate the t, which is used to do interpolate with stops,
-	 *     using the fomula:
-	 *     length((1-t)*c1 + t*c2 - p) = (1-t)*r1 + t*r2
-	 *     expand the fomula with xy coond, get the following:
-	 *     sqrt(sqr((1-t)*c1.x + t*c2.x - p.x) + sqr((1-t)*c1.y + t*c2.y - p.y))
-	 *           = (1-t)r1 + t*r2
-	 *     <====> At*t- 2Bt + C = 0
-	 *     where A = sqr(c2.x - c1.x) + sqr(c2.y - c1.y) - sqr(r2 -r1)
-	 *           B = (p.x - c1.x)*(c2.x - c1.x) + (p.y - c1.y)*(c2.y - c1.y) + r1*(r2 -r1)
-	 *           C = sqr(p.x - c1.x) + sqr(p.y - c1.y) - r1*r1
-	 *
-	 *     solve the fomula and we get the result of
-	 *     t = (B + sqrt(B*B - A*C)) / A  or
-	 *     t = (B - sqrt(B*B - A*C)) / A  (quadratic equation have two solutions)
-	 *
-	 *     The solution we are going to prefer is the bigger one, unless the
-	 *     radius associated to it is negative (or it falls outside the valid t range)
-	 */
-
-	const char *gradient_fs_template =
-	    GLAMOR_DEFAULT_PRECISION
-	    "uniform mat3 transform_mat;\n"
-	    "uniform int repeat_type;\n"
-	    "uniform float A_value;\n"
-	    "uniform vec2 c1;\n"
-	    "uniform float r1;\n"
-	    "uniform vec2 c2;\n"
-	    "uniform float r2;\n"
-	    "varying vec2 source_texture;\n"
-	    "\n"
-	    "vec4 get_color(float stop_len);\n"
-	    "\n"
-	    "int t_invalid;\n"
-	    "\n"
-	    "float get_stop_len()\n"
-	    "{\n"
-	    "    float t = 0.0;\n"
-	    "    float sqrt_value;\n"
-	    "    int revserse = 0;\n"
-	    "    t_invalid = 0;\n"
-	    "    \n"
-	    "    vec3 tmp = vec3(source_texture.x, source_texture.y, 1.0);\n"
-	    "    vec3 source_texture_trans = transform_mat * tmp;\n"
-	    "    source_texture_trans.xy = source_texture_trans.xy/source_texture_trans.z;\n"
-	    "    float B_value = (source_texture_trans.x - c1.x) * (c2.x - c1.x)\n"
-	    "                     + (source_texture_trans.y - c1.y) * (c2.y - c1.y)\n"
-	    "                     + r1 * (r2 - r1);\n"
-	    "    float C_value = (source_texture_trans.x - c1.x) * (source_texture_trans.x - c1.x)\n"
-	    "                     + (source_texture_trans.y - c1.y) * (source_texture_trans.y - c1.y)\n"
-	    "                     - r1*r1;\n"
-	    "    if(abs(A_value) < 0.00001) {\n"
-	    "        if(B_value == 0.0) {\n"
-	    "            t_invalid = 1;\n"
-	    "            return t;\n"
-	    "        }\n"
-	    "        t = 0.5 * C_value / B_value;"
-	    "    } else {\n"
-	    "        sqrt_value = B_value * B_value - A_value * C_value;\n"
-	    "        if(sqrt_value < 0.0) {\n"
-	    "            t_invalid = 1;\n"
-	    "            return t;\n"
-	    "        }\n"
-	    "        sqrt_value = sqrt(sqrt_value);\n"
-	    "        t = (B_value + sqrt_value) / A_value;\n"
-	    "    }\n"
-	    "    if(repeat_type == %d) {\n" // RepeatNone case.
-	    "        if((t <= 0.0) || (t > 1.0))\n"
-	    //           try another if first one invalid
-	    "            t = (B_value - sqrt_value) / A_value;\n"
-	    "        \n"
-	    "        if((t <= 0.0) || (t > 1.0)) {\n" //still invalid, return.
-	    "            t_invalid = 1;\n"
-	    "            return t;\n"
-	    "        }\n"
-	    "    } else {\n"
-	    "        if(t * (r2 - r1) <= -1.0 * r1)\n"
-	    //           try another if first one invalid
-	    "            t = (B_value - sqrt_value) / A_value;\n"
-	    "        \n"
-	    "        if(t * (r2 -r1) <= -1.0 * r1) {\n" //still invalid, return.
-	    "            t_invalid = 1;\n"
-	    "            return t;\n"
-	    "        }\n"
-	    "    }\n"
-	    "    \n"
-	    "    if(repeat_type == %d){\n" // repeat normal
-	    "        while(t > 1.0) \n"
-	    "            t = t - 1.0; \n"
-	    "        while(t < 0.0) \n"
-	    "            t = t + 1.0; \n"
-	    "    }\n"
-	    "    \n"
-	    "    if(repeat_type == %d) {\n" // repeat reflect
-	    "        while(t > 1.0) {\n"
-	    "            t = t - 1.0; \n"
-	    "            if(revserse == 0)\n"
-	    "                revserse = 1;\n"
-	    "            else\n"
-	    "                revserse = 0;\n"
-	    "        }\n"
-	    "        while(t < 0.0) {\n"
-	    "            t = t + 1.0; \n"
-	    "            if(revserse == 0)\n"
-	    "                revserse = 1;\n"
-	    "            else\n"
-	    "                revserse = 0;\n"
-	    "        }\n"
-	    "        if(revserse == 1) {\n"
-	    "            t = 1.0 - t; \n"
-	    "        }\n"
-	    "    }\n"
-	    "    \n"
-	    "    return t;\n"
-	    "}\n"
-	    "\n"
-	    "void main()\n"
-	    "{\n"
-	    "    float stop_len = get_stop_len();\n"
-	    "    if(t_invalid == 1) {\n"
-	    "        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
-	    "    } else {\n"
-	    "        gl_FragColor = get_color(stop_len);\n"
-	    "    }\n"
-	    "}\n";
-
-	glamor_priv = glamor_get_screen_private(screen);
-
-	if ((glamor_priv->radial_max_nstops >= stops_count) && (dyn_gen)) {
-		/* Very Good, not to generate again. */
-		return;
-	}
-
-	dispatch = glamor_get_dispatch(glamor_priv);
-
-	if (dyn_gen && glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][2]) {
-		dispatch->glDeleteShader(
-		    glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_VS_PROG][2]);
-		glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_VS_PROG][2] = 0;
-
-		dispatch->glDeleteShader(
-		    glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][2]);
-		glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][2] = 0;
-
-		dispatch->glDeleteShader(
-		    glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][2]);
-		glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][2] = 0;
-
-		dispatch->glDeleteProgram(glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][2]);
-		glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][2] = 0;
-	}
-
-	gradient_prog = dispatch->glCreateProgram();
-
-	vs_prog = glamor_compile_glsl_prog(dispatch,
-	                                   GL_VERTEX_SHADER, gradient_vs);
-
-	XNFasprintf(&gradient_fs,
-	            gradient_fs_template,
-	            PIXMAN_REPEAT_NONE, PIXMAN_REPEAT_NORMAL, PIXMAN_REPEAT_REFLECT);
-
-	fs_main_prog = glamor_compile_glsl_prog(dispatch,
-	                                        GL_FRAGMENT_SHADER, gradient_fs);
-
-	free(gradient_fs);
-
-	fs_getcolor_prog =
-	    _glamor_create_getcolor_fs_program(screen, stops_count, (stops_count > 0));
-
-	dispatch->glAttachShader(gradient_prog, vs_prog);
-	dispatch->glAttachShader(gradient_prog, fs_getcolor_prog);
-	dispatch->glAttachShader(gradient_prog, fs_main_prog);
-
-	dispatch->glBindAttribLocation(gradient_prog, GLAMOR_VERTEX_POS, "v_positionsition");
-	dispatch->glBindAttribLocation(gradient_prog, GLAMOR_VERTEX_SOURCE, "v_texcoord");
-
-	glamor_link_glsl_prog(dispatch, gradient_prog);
-
-	dispatch->glUseProgram(0);
-
-	if (dyn_gen) {
-		index = 2;
-		glamor_priv->radial_max_nstops = stops_count;
-	} else if (stops_count) {
-		index = 1;
-	} else {
-		index = 0;
-	}
-
-	glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][index] = gradient_prog;
-	glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_VS_PROG][index] = vs_prog;
-	glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][index] = fs_main_prog;
-	glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][index] = fs_getcolor_prog;
-
-	glamor_put_dispatch(glamor_priv);
-}
-
-static void
-_glamor_create_linear_gradient_program(ScreenPtr screen, int stops_count, int dyn_gen)
-{
-	glamor_screen_private *glamor_priv;
-	glamor_gl_dispatch *dispatch;
-
-	int index = 0;
-	GLint gradient_prog = 0;
-	char *gradient_fs = NULL;
-	GLint fs_main_prog, fs_getcolor_prog, vs_prog;
-
-	const char *gradient_vs =
-	    GLAMOR_DEFAULT_PRECISION
-	    "attribute vec4 v_position;\n"
-	    "attribute vec4 v_texcoord;\n"
-	    "varying vec2 source_texture;\n"
-	    "\n"
-	    "void main()\n"
-	    "{\n"
-	    "    gl_Position = v_position;\n"
-	    "    source_texture = v_texcoord.xy;\n"
-	    "}\n";
-
-	/*
-	 *                                      |
-	 *                                      |\
-	 *                                      | \
-	 *                                      |  \
-	 *                                      |   \
-	 *                                      |\   \
-	 *                                      | \   \
-	 *     cos_val =                        |\ p1d \   /
-	 *      sqrt(1/(slope*slope+1.0))  ------>\ \   \ /
-	 *                                      |  \ \   \
-	 *                                      |   \ \ / \
-	 *                                      |    \ *Pt1\
-	 *         *p1                          |     \     \     *P
-	 *          \                           |    / \     \   /
-	 *           \                          |   /   \     \ /
-	 *            \                         |       pd     \
-	 *             \                        |         \   / \
-	 *            p2*                       |          \ /   \       /
-	 *        slope = (p2.y - p1.y) /       |           /     p2d   /
-	 *                    (p2.x - p1.x)     |          /       \   /
-	 *                                      |         /         \ /
-	 *                                      |        /           /
-	 *                                      |       /           /
-	 *                                      |      /           *Pt2
-	 *                                      |                 /
-	 *                                      |                /
-	 *                                      |               /
-	 *                                      |              /
-	 *                                      |             /
-	 *                               -------+---------------------------------
-	 *                                     O|
-	 *                                      |
-	 *                                      |
-	 *
-	 *	step 1: compute the distance of p, pt1 and pt2 in the slope direction.
-	 *		Caculate the distance on Y axis first and multiply cos_val to
-	 *		get the value on slope direction(pd, p1d and p2d represent the
-	 *		distance of p, pt1, and pt2 respectively).
-	 *
-	 *	step 2: caculate the percentage of (pd - p1d)/(p2d - p1d).
-	 *		If (pd - p1d) > (p2d - p1d) or < 0, then sub or add (p2d - p1d)
-	 *		to make it in the range of [0, (p2d - p1d)].
-	 *
-	 *	step 3: compare the percentage to every stop and find the stpos just
-	 *		before and after it. Use the interpolation fomula to compute RGBA.
-	 */
-
-	const char *gradient_fs_template =
-	    GLAMOR_DEFAULT_PRECISION
-	    "uniform mat3 transform_mat;\n"
-	    "uniform int repeat_type;\n"
-	    "uniform int hor_ver;\n"
-	    "uniform vec4 pt1;\n"
-	    "uniform vec4 pt2;\n"
-	    "uniform float pt_slope;\n"
-	    "uniform float cos_val;\n"
-	    "uniform float p1_distance;\n"
-	    "uniform float pt_distance;\n"
-	    "varying vec2 source_texture;\n"
-	    "\n"
-	    "vec4 get_color(float stop_len);\n"
-	    "\n"
-	    "float get_stop_len()\n"
-	    "{\n"
-	    "    vec3 tmp = vec3(source_texture.x, source_texture.y, 1.0);\n"
-	    "    float len_percentage;\n"
-	    "    float distance;\n"
-	    "    float _p1_distance;\n"
-	    "    float _pt_distance;\n"
-	    "    float y_dist;\n"
-	    "    float stop_after;\n"
-	    "    float stop_before;\n"
-	    "    vec4 stop_color_before;\n"
-	    "    vec4 stop_color_after;\n"
-	    "    float new_alpha; \n"
-	    "    int revserse = 0;\n"
-	    "    vec4 gradient_color;\n"
-	    "    float percentage; \n"
-	    "    vec3 source_texture_trans = transform_mat * tmp;\n"
-	    "    \n"
-	    "    if(hor_ver == 0) { \n" //Normal case.
-	    "        y_dist = source_texture_trans.y - source_texture_trans.x*pt_slope;\n"
-	    "        distance = y_dist * cos_val;\n"
-	    "        _p1_distance = p1_distance * source_texture_trans.z;\n"
-	    "        _pt_distance = pt_distance * source_texture_trans.z;\n"
-	    "        \n"
-	    "    } else if (hor_ver == 1) {\n"//horizontal case.
-	    "        distance = source_texture_trans.x;\n"
-	    "        _p1_distance = p1_distance * source_texture_trans.z;\n"
-	    "        _pt_distance = pt_distance * source_texture_trans.z;\n"
-	    "    } else if (hor_ver == 2) {\n"//vertical case.
-	    "        distance = source_texture_trans.y;\n"
-	    "        _p1_distance = p1_distance * source_texture_trans.z;\n"
-	    "        _pt_distance = pt_distance * source_texture_trans.z;\n"
-	    "    } \n"
-	    "    \n"
-	    "    distance = distance - _p1_distance; \n"
-	    "    \n"
-	    "    if(repeat_type == %d){\n" // repeat normal
-	    "        while(distance > _pt_distance) \n"
-	    "            distance = distance - (_pt_distance); \n"
-	    "        while(distance < 0.0) \n"
-	    "            distance = distance + (_pt_distance); \n"
-	    "    }\n"
-	    "    \n"
-	    "    if(repeat_type == %d) {\n" // repeat reflect
-	    "        while(distance > _pt_distance) {\n"
-	    "            distance = distance - (_pt_distance); \n"
-	    "            if(revserse == 0)\n"
-	    "                revserse = 1;\n"
-	    "            else\n"
-	    "                revserse = 0;\n"
-	    "        }\n"
-	    "        while(distance < 0.0) {\n"
-	    "            distance = distance + (_pt_distance); \n"
-	    "            if(revserse == 0)\n"
-	    "                revserse = 1;\n"
-	    "            else\n"
-	    "                revserse = 0;\n"
-	    "        }\n"
-	    "        if(revserse == 1) {\n"
-	    "            distance = (_pt_distance) - distance; \n"
-	    "        }\n"
-	    "    }\n"
-	    "    \n"
-	    "    len_percentage = distance/(_pt_distance);\n"
-	    "    \n"
-	    "    return len_percentage;\n"
-	    "}\n"
-	    "\n"
-	    "void main()\n"
-	    "{\n"
-	    "    float stop_len = get_stop_len();\n"
-	    "    gl_FragColor = get_color(stop_len);\n"
-	    "}\n";
-
-
-	glamor_priv = glamor_get_screen_private(screen);
-
-	if ((glamor_priv->linear_max_nstops >= stops_count) && (dyn_gen)) {
-		/* Very Good, not to generate again. */
-		return;
-	}
-
-	dispatch = glamor_get_dispatch(glamor_priv);
-	if (dyn_gen && glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][2]) {
-		dispatch->glDeleteShader(
-		    glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_VS_PROG][2]);
-		glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_VS_PROG][2] = 0;
-
-		dispatch->glDeleteShader(
-		    glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][2]);
-		glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][2] = 0;
-
-		dispatch->glDeleteShader(
-		    glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][2]);
-		glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][2] = 0;
-
-		dispatch->glDeleteProgram(glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][2]);
-		glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][2] = 0;
-	}
-
-	gradient_prog = dispatch->glCreateProgram();
-
-	vs_prog = glamor_compile_glsl_prog(dispatch,
-	                                   GL_VERTEX_SHADER, gradient_vs);
-
-	XNFasprintf(&gradient_fs,
-	            gradient_fs_template,
-	            PIXMAN_REPEAT_NORMAL, PIXMAN_REPEAT_REFLECT);
-
-	fs_main_prog = glamor_compile_glsl_prog(dispatch,
-	                                        GL_FRAGMENT_SHADER, gradient_fs);
-	free(gradient_fs);
-
-	fs_getcolor_prog =
-	    _glamor_create_getcolor_fs_program(screen, stops_count, (stops_count > 0));
-
-	dispatch->glAttachShader(gradient_prog, vs_prog);
-	dispatch->glAttachShader(gradient_prog, fs_getcolor_prog);
-	dispatch->glAttachShader(gradient_prog, fs_main_prog);
-
-	dispatch->glBindAttribLocation(gradient_prog, GLAMOR_VERTEX_POS, "v_position");
-	dispatch->glBindAttribLocation(gradient_prog, GLAMOR_VERTEX_SOURCE, "v_texcoord");
-
-	glamor_link_glsl_prog(dispatch, gradient_prog);
-
-	dispatch->glUseProgram(0);
-
-	if (dyn_gen) {
-		index = 2;
-		glamor_priv->linear_max_nstops = stops_count;
-	} else if (stops_count) {
-		index = 1;
-	} else {
-		index = 0;
-	}
-
-	glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][index] = gradient_prog;
-	glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_VS_PROG][index] = vs_prog;
-	glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][index] = fs_main_prog;
-	glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][index] = fs_getcolor_prog;
-
-	glamor_put_dispatch(glamor_priv);
-}
-
-#define LINEAR_SMALL_STOPS 6 + 2
-#define LINEAR_LARGE_STOPS 16 + 2
-
-#define RADIAL_SMALL_STOPS 6 + 2
-#define RADIAL_LARGE_STOPS 16 + 2
-
-void
-glamor_init_gradient_shader(ScreenPtr screen)
-{
-	glamor_screen_private *glamor_priv;
-	int i;
-
-	glamor_priv = glamor_get_screen_private(screen);
-
-	for (i = 0; i < 3; i++) {
-		glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][i] = 0;
-		glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_VS_PROG][i] = 0;
-		glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][i] = 0;
-		glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][i] = 0;
-
-		glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][i] = 0;
-		glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_VS_PROG][i] = 0;
-		glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][i] = 0;
-		glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][i] = 0;
-	}
-	glamor_priv->linear_max_nstops = 0;
-	glamor_priv->radial_max_nstops = 0;
-
-	_glamor_create_linear_gradient_program(screen, 0, 0);
-	_glamor_create_linear_gradient_program(screen, LINEAR_LARGE_STOPS, 0);
-
-	_glamor_create_radial_gradient_program(screen, 0, 0);
-	_glamor_create_radial_gradient_program(screen, RADIAL_LARGE_STOPS, 0);
-}
-
-void
-glamor_fini_gradient_shader(ScreenPtr screen)
-{
-	glamor_screen_private *glamor_priv;
-	glamor_gl_dispatch *dispatch;
-	int i = 0;
-
-	glamor_priv = glamor_get_screen_private(screen);
-	dispatch = glamor_get_dispatch(glamor_priv);
-
-	for (i = 0; i < 3; i++) {
-		/* Linear Gradient */
-		if (glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_VS_PROG][i])
-			dispatch->glDeleteShader(
-			    glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_VS_PROG][i]);
-
-		if (glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][i])
-			dispatch->glDeleteShader(
-			    glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][i]);
-
-		if (glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][i])
-			dispatch->glDeleteShader(
-			    glamor_priv->linear_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][i]);
-
-		if (glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][i])
-			dispatch->glDeleteProgram(glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][i]);
-
-		/* Radial Gradient */
-		if (glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_VS_PROG][i])
-			dispatch->glDeleteShader(
-			    glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_VS_PROG][i]);
-
-		if (glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][i])
-			dispatch->glDeleteShader(
-			    glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_MAIN_PROG][i]);
-
-		if (glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][i])
-			dispatch->glDeleteShader(
-			    glamor_priv->radial_gradient_shaders[SHADER_GRADIENT_FS_GETCOLOR_PROG][i]);
-
-		if (glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][i])
-			dispatch->glDeleteProgram(glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][i]);
-	}
-
-	glamor_put_dispatch(glamor_priv);
-}
-
-static void
-_glamor_gradient_convert_trans_matrix(PictTransform *from, float to[3][3],
-				      int width, int height, int normalize)
-{
-	/*
-	 * Because in the shader program, we normalize all the pixel cood to [0, 1],
-	 * so with the transform matrix, the correct logic should be:
-	 * v_s = A*T*v
-	 * v_s: point vector in shader after normalized.
-	 * A: The transition matrix from   width X height --> 1.0 X 1.0
-	 * T: The transform matrix.
-	 * v: point vector in width X height space.
-	 *
-	 * result is OK if we use this fomula. But for every point in width X height space,
-	 * we can just use their normalized point vector in shader, namely we can just
-	 * use the result of A*v in shader. So we have no chance to insert T in A*v.
-	 * We can just convert v_s = A*T*v to v_s = A*T*inv(A)*A*v, where inv(A) is the
-	 * inverse matrix of A. Now, v_s = (A*T*inv(A)) * (A*v)
-	 * So, to get the correct v_s, we need to cacula1 the matrix: (A*T*inv(A)), and
-	 * we name this matrix T_s.
-	 *
-	 * Firstly, because A is for the scale convertion, we find
-	 *      --         --
-	 *      |1/w  0   0 |
-	 * A =  | 0  1/h  0 |
-	 *      | 0   0  1.0|
-	 *      --         --
-	 * so T_s = A*T*inv(a) and result
-	 *
-	 *       --                      --
-	 *       | t11      h*t12/w  t13/w|
-	 * T_s = | w*t21/h  t22      t23/h|
-	 *       | w*t31    h*t32    t33  |
-	 *       --                      --
-	 */
-
-	to[0][0] = (float)pixman_fixed_to_double(from->matrix[0][0]);
-	to[0][1] = (float)pixman_fixed_to_double(from->matrix[0][1])
-	                        * (normalize ? (((float)height) / ((float)width)) : 1.0);
-	to[0][2] = (float)pixman_fixed_to_double(from->matrix[0][2])
-	                        / (normalize ? ((float)width) : 1.0);
-
-	to[1][0] = (float)pixman_fixed_to_double(from->matrix[1][0])
-	                        * (normalize ? (((float)width) / ((float)height)) : 1.0);
-	to[1][1] = (float)pixman_fixed_to_double(from->matrix[1][1]);
-	to[1][2] = (float)pixman_fixed_to_double(from->matrix[1][2])
-	                        / (normalize ? ((float)height) : 1.0);
-
-	to[2][0] = (float)pixman_fixed_to_double(from->matrix[2][0])
-	                        * (normalize ? ((float)width) : 1.0);
-	to[2][1] = (float)pixman_fixed_to_double(from->matrix[2][1])
-	                        * (normalize ? ((float)height) : 1.0);
-	to[2][2] = (float)pixman_fixed_to_double(from->matrix[2][2]);
-
-	DEBUGF("the transform matrix is:\n%f\t%f\t%f\n%f\t%f\t%f\n%f\t%f\t%f\n",
-	       to[0][0], to[0][1], to[0][2],
-	       to[1][0], to[1][1], to[1][2],
-	       to[2][0], to[2][1], to[2][2]);
-}
-
-static int
-_glamor_gradient_set_pixmap_destination(ScreenPtr screen,
-                                        glamor_screen_private *glamor_priv,
-                                        PicturePtr dst_picture,
-                                        GLfloat *xscale, GLfloat *yscale,
-                                        int x_source, int y_source,
-                                        float vertices[8],
-                                        float tex_vertices[8],
-					int tex_normalize)
-{
-	glamor_pixmap_private *pixmap_priv;
-	PixmapPtr pixmap = NULL;
-
-	pixmap = glamor_get_drawable_pixmap(dst_picture->pDrawable);
-	pixmap_priv = glamor_get_pixmap_private(pixmap);
-
-	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv)) { /* should always have here. */
-		return 0;
-	}
-
-	glamor_set_destination_pixmap_priv_nc(pixmap_priv);
-
-	pixmap_priv_get_scale(pixmap_priv, xscale, yscale);
-
-	glamor_priv->has_source_coords = 1;
-	glamor_priv->has_mask_coords = 0;
-	glamor_setup_composite_vbo(screen, 4*2);
-
-	DEBUGF("xscale = %f, yscale = %f,"
-	       " x_source = %d, y_source = %d, width = %d, height = %d\n",
-	       *xscale, *yscale, x_source, y_source,
-	       dst_picture->pDrawable->width, dst_picture->pDrawable->height);
-
-	glamor_set_normalize_vcoords(*xscale, *yscale,
-	                             0, 0,
-	                             (INT16)(dst_picture->pDrawable->width),
-	                             (INT16)(dst_picture->pDrawable->height),
-	                             glamor_priv->yInverted, vertices);
-
-	if (tex_normalize) {
-		glamor_set_normalize_tcoords(*xscale, *yscale,
-		                             0, 0,
-		                             (INT16)(dst_picture->pDrawable->width),
-		                             (INT16)(dst_picture->pDrawable->height),
-		                             glamor_priv->yInverted, tex_vertices);
-	} else {
-		glamor_set_tcoords(0, 0,
-		                   (INT16)(dst_picture->pDrawable->width),
-		                   (INT16)(dst_picture->pDrawable->height),
-		                   glamor_priv->yInverted, tex_vertices);
-	}
-
-	DEBUGF("vertices --> leftup : %f X %f, rightup: %f X %f,"
-	       "rightbottom: %f X %f, leftbottom : %f X %f\n",
-	       vertices[0], vertices[1], vertices[2], vertices[3],
-	       vertices[4], vertices[5], vertices[6], vertices[7]);
-	DEBUGF("tex_vertices --> leftup : %f X %f, rightup: %f X %f,"
-	       "rightbottom: %f X %f, leftbottom : %f X %f\n",
-	       tex_vertices[0], tex_vertices[1], tex_vertices[2], tex_vertices[3],
-	       tex_vertices[4], tex_vertices[5], tex_vertices[6], tex_vertices[7]);
-
-	return 1;
-}
-
-static int
-_glamor_gradient_set_stops(PicturePtr src_picture, PictGradient * pgradient,
-        GLfloat *stop_colors, GLfloat *n_stops)
-{
-	int i;
-	int count = 1;
-
-	for (i = 0; i < pgradient->nstops; i++) {
-		/* We find some gradient picture set the stops at the same percentage, which
-		   will cause the shader problem because the (stops[i] - stops[i-1]) will
-		   be used as divisor. We just keep the later one if stops[i] == stops[i-1] */
-		if (i < pgradient->nstops - 1
-		         && pgradient->stops[i].x == pgradient->stops[i+1].x)
-			continue;
-
-		stop_colors[count*4] = pixman_fixed_to_double(
-		                                pgradient->stops[i].color.red);
-		stop_colors[count*4+1] = pixman_fixed_to_double(
-		                                pgradient->stops[i].color.green);
-		stop_colors[count*4+2] = pixman_fixed_to_double(
-		                                pgradient->stops[i].color.blue);
-		stop_colors[count*4+3] = pixman_fixed_to_double(
-		                                pgradient->stops[i].color.alpha);
-
-		n_stops[count] = (GLfloat)pixman_fixed_to_double(
-		                                pgradient->stops[i].x);
-		count++;
-	}
-
-	/* for the end stop. */
-	count++;
-
-	switch (src_picture->repeatType) {
-#define REPEAT_FILL_STOPS(m, n) \
-			stop_colors[(m)*4 + 0] = stop_colors[(n)*4 + 0]; \
-			stop_colors[(m)*4 + 1] = stop_colors[(n)*4 + 1]; \
-			stop_colors[(m)*4 + 2] = stop_colors[(n)*4 + 2]; \
-			stop_colors[(m)*4 + 3] = stop_colors[(n)*4 + 3];
-
-		default:
-		case PIXMAN_REPEAT_NONE:
-			stop_colors[0] = 0.0;	   //R
-			stop_colors[1] = 0.0;	   //G
-			stop_colors[2] = 0.0;	   //B
-			stop_colors[3] = 0.0;	   //Alpha
-			n_stops[0] = -(float)INT_MAX;  //should be small enough.
-
-			stop_colors[0 + (count-1)*4] = 0.0;	 //R
-			stop_colors[1 + (count-1)*4] = 0.0;	 //G
-			stop_colors[2 + (count-1)*4] = 0.0;	 //B
-			stop_colors[3 + (count-1)*4] = 0.0;	 //Alpha
-			n_stops[count-1] = (float)INT_MAX;  //should be large enough.
-			break;
-		case PIXMAN_REPEAT_NORMAL:
-			REPEAT_FILL_STOPS(0, count - 2);
-			n_stops[0] = n_stops[count-2] - 1.0;
-
-			REPEAT_FILL_STOPS(count - 1, 1);
-			n_stops[count-1] = n_stops[1] + 1.0;
-			break;
-		case PIXMAN_REPEAT_REFLECT:
-			REPEAT_FILL_STOPS(0, 1);
-			n_stops[0] = -n_stops[1];
-
-			REPEAT_FILL_STOPS(count - 1, count - 2);
-			n_stops[count-1] = 1.0 + 1.0 - n_stops[count-2];
-			break;
-		case PIXMAN_REPEAT_PAD:
-			REPEAT_FILL_STOPS(0, 1);
-			n_stops[0] = -(float)INT_MAX;
-
-			REPEAT_FILL_STOPS(count - 1, count - 2);
-			n_stops[count-1] = (float)INT_MAX;
-			break;
-#undef REPEAT_FILL_STOPS
-	}
-
-	for (i = 0; i < count; i++) {
-		DEBUGF("n_stops[%d] = %f, color = r:%f g:%f b:%f a:%f\n",
-		       i, n_stops[i],
-		       stop_colors[i*4], stop_colors[i*4+1],
-		       stop_colors[i*4+2], stop_colors[i*4+3]);
-	}
-
-	return count;
-}
-
-static PicturePtr
-_glamor_generate_radial_gradient_picture(ScreenPtr screen,
-                                         PicturePtr src_picture,
-                                         int x_source, int y_source,
-                                         int width, int height,
-                                         PictFormatShort format)
-{
-	glamor_screen_private *glamor_priv;
-	glamor_gl_dispatch *dispatch;
-	PicturePtr dst_picture = NULL;
-	PixmapPtr pixmap = NULL;
-	GLint gradient_prog = 0;
-	int error;
-	float tex_vertices[8];
-	int stops_count;
-	int count = 0;
-	GLfloat *stop_colors = NULL;
-	GLfloat *n_stops = NULL;
-	GLfloat xscale, yscale;
-	float vertices[8];
-	float transform_mat[3][3];
-	static const float identity_mat[3][3] = {{1.0, 0.0, 0.0},
-	                                         {0.0, 1.0, 0.0},
-	                                         {0.0, 0.0, 1.0}};
-	GLfloat stop_colors_st[RADIAL_SMALL_STOPS*4];
-	GLfloat n_stops_st[RADIAL_SMALL_STOPS];
-	GLfloat A_value;
-	GLfloat cxy[4];
-	float c1x, c1y, c2x, c2y, r1, r2;
-
-	GLint transform_mat_uniform_location;
-	GLint repeat_type_uniform_location;
-	GLint n_stop_uniform_location;
-	GLint stops_uniform_location;
-	GLint stop_colors_uniform_location;
-	GLint stop0_uniform_location;
-	GLint stop1_uniform_location;
-	GLint stop2_uniform_location;
-	GLint stop3_uniform_location;
-	GLint stop4_uniform_location;
-	GLint stop5_uniform_location;
-	GLint stop6_uniform_location;
-	GLint stop7_uniform_location;
-	GLint stop_color0_uniform_location;
-	GLint stop_color1_uniform_location;
-	GLint stop_color2_uniform_location;
-	GLint stop_color3_uniform_location;
-	GLint stop_color4_uniform_location;
-	GLint stop_color5_uniform_location;
-	GLint stop_color6_uniform_location;
-	GLint stop_color7_uniform_location;
-	GLint A_value_uniform_location;
-	GLint c1_uniform_location;
-	GLint r1_uniform_location;
-	GLint c2_uniform_location;
-	GLint r2_uniform_location;
-
-	glamor_priv = glamor_get_screen_private(screen);
-	dispatch = glamor_get_dispatch(glamor_priv);
-
-	/* Create a pixmap with VBO. */
-	pixmap = glamor_create_pixmap(screen,
-	                              width, height,
-	                              PIXMAN_FORMAT_DEPTH(format),
-	                              0);
-	if (!pixmap)
-		goto GRADIENT_FAIL;
-
-	dst_picture = CreatePicture(0, &pixmap->drawable,
-	                            PictureMatchFormat(screen,
-	                                 PIXMAN_FORMAT_DEPTH(format), format),
-	                            0, 0, serverClient, &error);
-
-	/* Release the reference, picture will hold the last one. */
-	glamor_destroy_pixmap(pixmap);
-
-	if (!dst_picture)
-		goto GRADIENT_FAIL;
-
-	ValidatePicture(dst_picture);
-
-	stops_count = src_picture->pSourcePict->radial.nstops + 2;
-
-	/* Because the max value of nstops is unkown, so create a program
-	   when nstops > LINEAR_LARGE_STOPS.*/
-	if (stops_count <= RADIAL_SMALL_STOPS) {
-		gradient_prog = glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][0];
-	} else if (stops_count <= RADIAL_LARGE_STOPS) {
-		gradient_prog = glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][1];
-	} else {
-		_glamor_create_radial_gradient_program(screen, src_picture->pSourcePict->linear.nstops + 2, 1);
-		gradient_prog = glamor_priv->gradient_prog[SHADER_GRADIENT_RADIAL][2];
-	}
-
-	/* Bind all the uniform vars .*/
-	transform_mat_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "transform_mat");
-	repeat_type_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "repeat_type");
-	n_stop_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "n_stop");
-	A_value_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "A_value");
-	repeat_type_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "repeat_type");
-	c1_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "c1");
-	r1_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "r1");
-	c2_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "c2");
-	r2_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "r2");
-
-	if (src_picture->pSourcePict->radial.nstops + 2 <= RADIAL_SMALL_STOPS) {
-		stop0_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop0");
-		stop1_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop1");
-		stop2_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop2");
-		stop3_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop3");
-		stop4_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop4");
-		stop5_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop5");
-		stop6_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop6");
-		stop7_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop7");
-
-		stop_color0_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color0");
-		stop_color1_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color1");
-		stop_color2_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color2");
-		stop_color3_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color3");
-		stop_color4_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color4");
-		stop_color5_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color5");
-		stop_color6_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color6");
-		stop_color7_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color7");
-	} else {
-		stops_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stops");
-		stop_colors_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_colors");
-	}
-
-	dispatch->glUseProgram(gradient_prog);
-
-	dispatch->glUniform1i(repeat_type_uniform_location, src_picture->repeatType);
-
-
-	if (src_picture->transform) {
-		_glamor_gradient_convert_trans_matrix(src_picture->transform,
-		                                      transform_mat,
-		                                      width, height, 0);
-		dispatch->glUniformMatrix3fv(transform_mat_uniform_location,
-		                             1, 1, &transform_mat[0][0]);
-	} else {
-		dispatch->glUniformMatrix3fv(transform_mat_uniform_location,
-		                             1, 1, &identity_mat[0][0]);
-	}
-
-	if (!_glamor_gradient_set_pixmap_destination(screen, glamor_priv, dst_picture,
-	                                             &xscale, &yscale, x_source, y_source,
-	                                             vertices, tex_vertices, 0))
-		goto GRADIENT_FAIL;
-
-	/* Set all the stops and colors to shader. */
-	if (stops_count > RADIAL_SMALL_STOPS) {
-		stop_colors = malloc(4 * stops_count * sizeof(float));
-		if (stop_colors == NULL) {
-			ErrorF("Failed to allocate stop_colors memory.\n");
-			goto GRADIENT_FAIL;
-		}
-
-		n_stops = malloc(stops_count * sizeof(float));
-		if (n_stops == NULL) {
-			ErrorF("Failed to allocate n_stops memory.\n");
-			goto GRADIENT_FAIL;
-		}
-	} else {
-		stop_colors = stop_colors_st;
-		n_stops = n_stops_st;
-	}
-
-	count = _glamor_gradient_set_stops(src_picture, &src_picture->pSourcePict->gradient,
-	                                   stop_colors, n_stops);
-
-	if (src_picture->pSourcePict->linear.nstops + 2 <= RADIAL_SMALL_STOPS) {
-		int j = 0;
-		dispatch->glUniform4f(stop_color0_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color1_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color2_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color3_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color4_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color5_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color6_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color7_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-
-		j = 0;
-		dispatch->glUniform1f(stop0_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop1_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop2_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop3_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop4_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop5_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop6_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop7_uniform_location, n_stops[j++]);
-		dispatch->glUniform1i(n_stop_uniform_location, count);
-	} else {
-		dispatch->glUniform4fv(stop_colors_uniform_location, count, stop_colors);
-		dispatch->glUniform1fv(stops_uniform_location, count, n_stops);
-		dispatch->glUniform1i(n_stop_uniform_location, count);
-	}
-
-	c1x = (float)pixman_fixed_to_double(src_picture->pSourcePict->radial.c1.x);
-	c1y = (float)pixman_fixed_to_double(src_picture->pSourcePict->radial.c1.y);
-	c2x = (float)pixman_fixed_to_double(src_picture->pSourcePict->radial.c2.x);
-	c2y = (float)pixman_fixed_to_double(src_picture->pSourcePict->radial.c2.y);
-
-	r1 = (float)pixman_fixed_to_double(src_picture->pSourcePict->radial.c1.radius);
-	r2 = (float)pixman_fixed_to_double(src_picture->pSourcePict->radial.c2.radius);
-
-
-	cxy[0] = c1x;
-	cxy[1] = c1y;
-	dispatch->glUniform2fv(c1_uniform_location, 1, cxy);
-	dispatch->glUniform1f(r1_uniform_location, r1);
-
-	cxy[0] = c2x;
-	cxy[1] = c2y;
-	dispatch->glUniform2fv(c2_uniform_location, 1, cxy);
-	dispatch->glUniform1f(r2_uniform_location, r2);
-
-	A_value = (c2x - c1x) * (c2x - c1x) + (c2y - c1y) * (c2y - c1y) - (r2 - r1) * (r2 - r1);
-	dispatch->glUniform1f(A_value_uniform_location, A_value);
-
-	DEBUGF("C1:(%f, %f) R1:%f\nC2:(%f, %f) R2:%f\nA = %f\n",
-	       c1x, c1y, r1, c2x, c2y, r2, A_value);
-
-	glamor_emit_composite_rect(screen, tex_vertices, NULL, vertices);
-
-	if (glamor_priv->render_nr_verts) {
-		if (glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP)
-			dispatch->glUnmapBuffer(GL_ARRAY_BUFFER);
-		else {
-
-			dispatch->glBindBuffer(GL_ARRAY_BUFFER, glamor_priv->vbo);
-			dispatch->glBufferData(GL_ARRAY_BUFFER,
-			                       glamor_priv->vbo_offset,
-			                       glamor_priv->vb, GL_DYNAMIC_DRAW);
-		}
-
-		dispatch->glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, NULL);
-	}
-
-
-	/* Do the clear logic.*/
-	if (stops_count > RADIAL_SMALL_STOPS) {
-		free(n_stops);
-		free(stop_colors);
-	}
-
-	dispatch->glBindBuffer(GL_ARRAY_BUFFER, 0);
-	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-
-	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
-	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
-	dispatch->glUseProgram(0);
-
-	glamor_put_dispatch(glamor_priv);
-	return dst_picture;
-
-GRADIENT_FAIL:
-	if (dst_picture) {
-		FreePicture(dst_picture, 0);
-	}
-
-	if (stops_count > RADIAL_SMALL_STOPS) {
-		if (n_stops)
-			free(n_stops);
-		if (stop_colors)
-			free(stop_colors);
-	}
-
-	dispatch->glBindBuffer(GL_ARRAY_BUFFER, 0);
-	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-
-	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
-	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
-	dispatch->glUseProgram(0);
-	glamor_put_dispatch(glamor_priv);
-	return NULL;
-}
-
-static PicturePtr
-_glamor_generate_linear_gradient_picture(ScreenPtr screen,
-                                         PicturePtr src_picture,
-                                         int x_source, int y_source,
-                                         int width, int height,
-                                         PictFormatShort format)
-{
-	glamor_screen_private *glamor_priv;
-	glamor_gl_dispatch *dispatch;
-	PicturePtr dst_picture = NULL;
-	PixmapPtr pixmap = NULL;
-	GLint gradient_prog = 0;
-	int error;
-	float pt_distance;
-	float p1_distance;
-	GLfloat cos_val;
-	float tex_vertices[8];
-	int stops_count;
-	GLfloat *stop_colors = NULL;
-	GLfloat *n_stops = NULL;
-	int count = 0;
-	float slope;
-	GLfloat xscale, yscale;
-	GLfloat pt1[4], pt2[4];
-	float vertices[8];
-	float transform_mat[3][3];
-	static const float identity_mat[3][3] = {{1.0, 0.0, 0.0},
-	                                         {0.0, 1.0, 0.0},
-	                                         {0.0, 0.0, 1.0}};
-	GLfloat stop_colors_st[LINEAR_SMALL_STOPS*4];
-	GLfloat n_stops_st[LINEAR_SMALL_STOPS];
-
-	GLint transform_mat_uniform_location;
-	GLint pt1_uniform_location;
-	GLint pt2_uniform_location;
-	GLint n_stop_uniform_location;
-	GLint stops_uniform_location;
-	GLint stop0_uniform_location;
-	GLint stop1_uniform_location;
-	GLint stop2_uniform_location;
-	GLint stop3_uniform_location;
-	GLint stop4_uniform_location;
-	GLint stop5_uniform_location;
-	GLint stop6_uniform_location;
-	GLint stop7_uniform_location;
-	GLint stop_colors_uniform_location;
-	GLint stop_color0_uniform_location;
-	GLint stop_color1_uniform_location;
-	GLint stop_color2_uniform_location;
-	GLint stop_color3_uniform_location;
-	GLint stop_color4_uniform_location;
-	GLint stop_color5_uniform_location;
-	GLint stop_color6_uniform_location;
-	GLint stop_color7_uniform_location;
-	GLint pt_slope_uniform_location;
-	GLint repeat_type_uniform_location;
-	GLint hor_ver_uniform_location;
-	GLint cos_val_uniform_location;
-	GLint p1_distance_uniform_location;
-	GLint pt_distance_uniform_location;
-
-	glamor_priv = glamor_get_screen_private(screen);
-	dispatch = glamor_get_dispatch(glamor_priv);
-
-	/* Create a pixmap with VBO. */
-	pixmap = glamor_create_pixmap(screen,
-	                              width, height,
-	                              PIXMAN_FORMAT_DEPTH(format),
-	                              0);
-
-	if (!pixmap)
-		goto GRADIENT_FAIL;
-
-	dst_picture = CreatePicture(0, &pixmap->drawable,
-	                            PictureMatchFormat(screen,
-	                                    PIXMAN_FORMAT_DEPTH(format), format),
-	                            0, 0, serverClient, &error);
-
-	/* Release the reference, picture will hold the last one. */
-	glamor_destroy_pixmap(pixmap);
-
-	if (!dst_picture)
-		goto GRADIENT_FAIL;
-
-	ValidatePicture(dst_picture);
-
-	stops_count = src_picture->pSourcePict->linear.nstops + 2;
-
-	/* Because the max value of nstops is unkown, so create a program
-	   when nstops > LINEAR_LARGE_STOPS.*/
-	if (stops_count <= LINEAR_SMALL_STOPS) {
-		gradient_prog = glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][0];
-	} else if (stops_count <= LINEAR_LARGE_STOPS) {
-		gradient_prog = glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][1];
-	} else {
-		_glamor_create_linear_gradient_program(screen,
-		        src_picture->pSourcePict->linear.nstops + 2, 1);
-		gradient_prog = glamor_priv->gradient_prog[SHADER_GRADIENT_LINEAR][2];
-	}
-
-	/* Bind all the uniform vars .*/
-	pt1_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "pt1");
-	pt2_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "pt2");
-	n_stop_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "n_stop");
-	pt_slope_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "pt_slope");
-	repeat_type_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "repeat_type");
-	hor_ver_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "hor_ver");
-	transform_mat_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "transform_mat");
-	cos_val_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "cos_val");
-	p1_distance_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "p1_distance");
-	pt_distance_uniform_location =
-	    dispatch->glGetUniformLocation(gradient_prog, "pt_distance");
-
-	if (src_picture->pSourcePict->linear.nstops + 2 <= LINEAR_SMALL_STOPS) {
-		stop0_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop0");
-		stop1_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop1");
-		stop2_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop2");
-		stop3_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop3");
-		stop4_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop4");
-		stop5_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop5");
-		stop6_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop6");
-		stop7_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop7");
-
-		stop_color0_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color0");
-		stop_color1_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color1");
-		stop_color2_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color2");
-		stop_color3_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color3");
-		stop_color4_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color4");
-		stop_color5_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color5");
-		stop_color6_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color6");
-		stop_color7_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_color7");
-	} else {
-		stops_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stops");
-		stop_colors_uniform_location =
-		    dispatch->glGetUniformLocation(gradient_prog, "stop_colors");
-	}
-
-	dispatch->glUseProgram(gradient_prog);
-
-	dispatch->glUniform1i(repeat_type_uniform_location, src_picture->repeatType);
-
-	if (src_picture->transform) {
-		_glamor_gradient_convert_trans_matrix(src_picture->transform,
-		                                      transform_mat,
-		                                      width, height, 1);
-		dispatch->glUniformMatrix3fv(transform_mat_uniform_location,
-		                             1, 1, &transform_mat[0][0]);
-	} else {
-		dispatch->glUniformMatrix3fv(transform_mat_uniform_location,
-		                             1, 1, &identity_mat[0][0]);
-	}
-
-	if (!_glamor_gradient_set_pixmap_destination(screen, glamor_priv, dst_picture,
-	                                             &xscale, &yscale, x_source, y_source,
-	                                             vertices, tex_vertices, 1))
-		goto GRADIENT_FAIL;
-
-	/* Normalize the PTs. */
-	glamor_set_normalize_pt(xscale, yscale,
-	                        pixman_fixed_to_int(src_picture->pSourcePict->linear.p1.x),
-	                        x_source,
-	                        pixman_fixed_to_int(src_picture->pSourcePict->linear.p1.y),
-	                        y_source,
-	                        glamor_priv->yInverted,
-	                        pt1);
-	dispatch->glUniform4fv(pt1_uniform_location, 1, pt1);
-	DEBUGF("pt1:(%f %f)\n", pt1[0], pt1[1]);
-
-	glamor_set_normalize_pt(xscale, yscale,
-	                        pixman_fixed_to_int(src_picture->pSourcePict->linear.p2.x),
-	                        x_source,
-	                        pixman_fixed_to_int(src_picture->pSourcePict->linear.p2.y),
-	                        y_source,
-	                        glamor_priv->yInverted,
-	                        pt2);
-	dispatch->glUniform4fv(pt2_uniform_location, 1, pt2);
-	DEBUGF("pt2:(%f %f)\n", pt2[0], pt2[1]);
-
-	/* Set all the stops and colors to shader. */
-	if (stops_count > LINEAR_SMALL_STOPS) {
-		stop_colors = malloc(4 * stops_count * sizeof(float));
-		if (stop_colors == NULL) {
-			ErrorF("Failed to allocate stop_colors memory.\n");
-			goto GRADIENT_FAIL;
-		}
-
-		n_stops = malloc(stops_count * sizeof(float));
-		if (n_stops == NULL) {
-			ErrorF("Failed to allocate n_stops memory.\n");
-			goto GRADIENT_FAIL;
-		}
-	} else {
-		stop_colors = stop_colors_st;
-		n_stops = n_stops_st;
-	}
-
-	count = _glamor_gradient_set_stops(src_picture, &src_picture->pSourcePict->gradient,
-	                                   stop_colors, n_stops);
-
-	if (src_picture->pSourcePict->linear.nstops + 2 <= LINEAR_SMALL_STOPS) {
-		int j = 0;
-		dispatch->glUniform4f(stop_color0_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color1_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color2_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color3_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color4_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color5_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color6_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-		j++;
-		dispatch->glUniform4f(stop_color7_uniform_location, stop_colors[4*j+0], stop_colors[4*j+1],
-		                      stop_colors[4*j+2], stop_colors[4*j+3]);
-
-		j = 0;
-		dispatch->glUniform1f(stop0_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop1_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop2_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop3_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop4_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop5_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop6_uniform_location, n_stops[j++]);
-		dispatch->glUniform1f(stop7_uniform_location, n_stops[j++]);
-
-		dispatch->glUniform1i(n_stop_uniform_location, count);
-	} else {
-		dispatch->glUniform4fv(stop_colors_uniform_location, count, stop_colors);
-		dispatch->glUniform1fv(stops_uniform_location, count, n_stops);
-		dispatch->glUniform1i(n_stop_uniform_location, count);
-	}
-
-	if ((pt2[1] - pt1[1]) / yscale < 1.0) { // The horizontal case.
-		dispatch->glUniform1i(hor_ver_uniform_location, 1);
-		DEBUGF("p1.x: %f, p2.x: %f, enter the horizontal case\n", pt1[1], pt2[1]);
-
-		p1_distance = pt1[0];
-		pt_distance = (pt2[0] - p1_distance);
-		dispatch->glUniform1f(p1_distance_uniform_location, p1_distance);
-		dispatch->glUniform1f(pt_distance_uniform_location, pt_distance);
-	} else if ((pt2[0] - pt1[0]) / xscale < 1.0) { //The vertical case.
-		dispatch->glUniform1i(hor_ver_uniform_location, 2);
-		DEBUGF("p1.y: %f, p2.y: %f, enter the vertical case\n", pt1[0], pt2[0]);
-
-		p1_distance = pt1[1];
-		pt_distance = (pt2[1] - p1_distance);
-		dispatch->glUniform1f(p1_distance_uniform_location, p1_distance);
-		dispatch->glUniform1f(pt_distance_uniform_location, pt_distance);
-	} else {
-		/* The slope need to compute here. In shader, the viewport set will change
-		   the orginal slope and the slope which is vertical to it will not be correct.*/
-		slope = - (float)(src_picture->pSourcePict->linear.p2.x - src_picture->pSourcePict->linear.p1.x) /
-		        (float)(src_picture->pSourcePict->linear.p2.y - src_picture->pSourcePict->linear.p1.y);
-		slope = slope * yscale / xscale;
-		dispatch->glUniform1f(pt_slope_uniform_location, slope);
-		dispatch->glUniform1i(hor_ver_uniform_location, 0);
-
-		cos_val = sqrt(1.0 / (slope * slope + 1.0));
-		dispatch->glUniform1f(cos_val_uniform_location, cos_val);
-
-		p1_distance = (pt1[1] - pt1[0] * slope) * cos_val;
-		pt_distance = (pt2[1] - pt2[0] * slope) * cos_val - p1_distance;
-		dispatch->glUniform1f(p1_distance_uniform_location, p1_distance);
-		dispatch->glUniform1f(pt_distance_uniform_location, pt_distance);
-	}
-
-	/* set the transform matrix. */	/* Now rendering. */
-	glamor_emit_composite_rect(screen, tex_vertices, NULL, vertices);
-
-	if (glamor_priv->render_nr_verts) {
-		if (glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP)
-			dispatch->glUnmapBuffer(GL_ARRAY_BUFFER);
-		else {
-
-			dispatch->glBindBuffer(GL_ARRAY_BUFFER, glamor_priv->vbo);
-			dispatch->glBufferData(GL_ARRAY_BUFFER,
-			                       glamor_priv->vbo_offset,
-			                       glamor_priv->vb, GL_DYNAMIC_DRAW);
-		}
-
-		dispatch->glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, NULL);
-	}
-
-	/* Do the clear logic.*/
-	if (stops_count > LINEAR_SMALL_STOPS) {
-		free(n_stops);
-		free(stop_colors);
-	}
-
-	dispatch->glBindBuffer(GL_ARRAY_BUFFER, 0);
-	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-
-	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
-	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
-	dispatch->glUseProgram(0);
-
-	glamor_put_dispatch(glamor_priv);
-	return dst_picture;
-
-GRADIENT_FAIL:
-	if (dst_picture) {
-		FreePicture(dst_picture, 0);
-	}
-
-	if (stops_count > LINEAR_SMALL_STOPS) {
-		if (n_stops)
-			free(n_stops);
-		if (stop_colors)
-			free(stop_colors);
-	}
-
-	dispatch->glBindBuffer(GL_ARRAY_BUFFER, 0);
-	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-
-	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
-	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
-	dispatch->glUseProgram(0);
-	glamor_put_dispatch(glamor_priv);
-	return NULL;
-}
-#undef LINEAR_DEFAULT_STOPS
-#endif
-
-static PicturePtr
-glamor_convert_gradient_picture(ScreenPtr screen,
-                                PicturePtr source,
-                                int x_source,
-                                int y_source, int width, int height)
-{
-	PixmapPtr pixmap;
-	PicturePtr dst = NULL;
-	int error;
-	PictFormatShort format;
-	if (!source->pDrawable)
-		format = PICT_a8r8g8b8;
-	else
-		format = source->format;
-#ifdef GLAMOR_GRADIENT_SHADER
-	if (!source->pDrawable) {
-		if (source->pSourcePict->type == SourcePictTypeLinear) {
-			dst = _glamor_generate_linear_gradient_picture(screen,
-				source, x_source, y_source, width, height, format);
-		} else if (source->pSourcePict->type == SourcePictTypeRadial) {
-			dst = _glamor_generate_radial_gradient_picture(screen,
-		                  source, x_source, y_source, width, height, format);
-		}
-
-		if (dst) {
-#if 0			/* Debug to compare it to pixman, Enable it if needed. */
-			glamor_compare_pictures(screen, source,
-					dst, x_source, y_source, width, height,
-					0, 3);
-#endif
-			return dst;
-		}
-	}
-#endif
-	pixmap = glamor_create_pixmap(screen,
-				      width,
-				      height,
-				      PIXMAN_FORMAT_DEPTH(format),
-				      GLAMOR_CREATE_PIXMAP_CPU);
-
-	if (!pixmap)
-		return NULL;
-
-	dst = CreatePicture(0,
-	                    &pixmap->drawable,
-	                    PictureMatchFormat(screen,
-	                                       PIXMAN_FORMAT_DEPTH(format),
-	                                       format),
-	                    0, 0, serverClient, &error);
-	glamor_destroy_pixmap(pixmap);
-	if (!dst)
-		return NULL;
-
-	ValidatePicture(dst);
-
-	fbComposite(PictOpSrc, source, NULL, dst, x_source, y_source,
-	            0, 0, 0, 0, width, height);
-	return dst;
-}
-
-static Bool
-_glamor_composite(CARD8 op,
-		  PicturePtr source,
-		  PicturePtr mask,
-		  PicturePtr dest,
-		  INT16 x_source,
-		  INT16 y_source,
-		  INT16 x_mask,
-		  INT16 y_mask,
-		  INT16 x_dest, INT16 y_dest, 
-		  CARD16 width, CARD16 height, Bool fallback)
-{
-	ScreenPtr screen = dest->pDrawable->pScreen;
-	glamor_pixmap_private *dest_pixmap_priv;
-	glamor_pixmap_private *source_pixmap_priv =
-	    NULL, *mask_pixmap_priv = NULL;
-	PixmapPtr dest_pixmap =
-	    glamor_get_drawable_pixmap(dest->pDrawable);
-	PixmapPtr source_pixmap = NULL, mask_pixmap = NULL;
-	PicturePtr temp_src = source, temp_mask = mask;
-	int x_temp_src, y_temp_src, x_temp_mask, y_temp_mask;
-	glamor_composite_rect_t rect[10];
-	glamor_composite_rect_t *prect = rect;
-	int prect_size = ARRAY_SIZE(rect);
-	glamor_screen_private *glamor_priv =
-	    glamor_get_screen_private(screen);
-	Bool ret = TRUE;
-	RegionRec region;
-	BoxPtr box;
-	int nbox, i, ok = FALSE;
-	PixmapPtr sub_dest_pixmap = NULL;
-	PixmapPtr sub_source_pixmap = NULL;
-	PixmapPtr sub_mask_pixmap = NULL;
-	int dest_x_off, dest_y_off, saved_dest_x = 0, saved_dest_y = 0;
-	int source_x_off, source_y_off, saved_source_x = 0, saved_source_y = 0;
-	int mask_x_off, mask_y_off, saved_mask_x = 0, saved_mask_y = 0;
-	DrawablePtr saved_dest_drawable = NULL;
-	DrawablePtr saved_source_drawable = NULL;
-	DrawablePtr saved_mask_drawable = NULL;
-
-	x_temp_src = x_source;
-	y_temp_src = y_source;
-	x_temp_mask = x_mask;
-	y_temp_mask = y_mask;
-
-	dest_pixmap_priv = glamor_get_pixmap_private(dest_pixmap);
-	/* Currently. Always fallback to cpu if destination is in CPU memory. */
+	DEBUGF("clipped (%d %d) (%d %d) (%d %d) width %d height %d \n",
+		x_source, y_source, x_mask, y_mask, x_dest, y_dest, width, height);
 
-	if (source->pDrawable) {
-		source_pixmap = glamor_get_drawable_pixmap(source->pDrawable);
-		source_pixmap_priv = glamor_get_pixmap_private(source_pixmap);
-		if (source_pixmap_priv && source_pixmap_priv->type == GLAMOR_DRM_ONLY)
-			goto fail;
-	}
-
-	if (mask && mask->pDrawable) {
-		mask_pixmap = glamor_get_drawable_pixmap(mask->pDrawable);
-		mask_pixmap_priv = glamor_get_pixmap_private(mask_pixmap);
-		if (mask_pixmap_priv && mask_pixmap_priv->type == GLAMOR_DRM_ONLY)
-			goto fail;
-	}
-
-	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(dest_pixmap_priv)) {
-		goto fail;
-	}
+	if (source_pixmap_priv)
+		source_pixmap = source_pixmap_priv->base.pixmap;
 
-	if (op >= ARRAY_SIZE(composite_op_info))
-		goto fail;
+	if (mask_pixmap_priv)
+		mask_pixmap = mask_pixmap_priv->base.pixmap;
 
-	if ((!source->pDrawable
+	/* XXX is it possible source mask have non-zero drawable.x/y? */
+	if (source
+	    && ((!source->pDrawable
 	     && (source->pSourcePict->type != SourcePictTypeSolidFill))
 	    || (source->pDrawable
 		&& !GLAMOR_PIXMAP_PRIV_HAS_FBO(source_pixmap_priv)
-		&&
-		((width * height * 4 <
-		  (source_pixmap->drawable.width *
-		   source_pixmap->drawable.height))
-		 ||
-		 !(glamor_check_fbo_size
-		   (glamor_priv, source_pixmap->drawable.width,
-		    source_pixmap->drawable.height))))) {
+		&& (source_pixmap->drawable.width != width
+		    || source_pixmap->drawable.height != height)))) {
 		temp_src =
 		    glamor_convert_gradient_picture(screen, source,
-						    x_source, y_source,
+						    extent->x1 + x_source - x_dest,
+						    extent->y1 + y_source - y_dest,
 						    width, height);
 		if (!temp_src) {
 			temp_src = source;
-			goto fail;
+			goto out;
 		}
-		x_temp_src = y_temp_src = 0;
+		temp_src_priv = glamor_get_pixmap_private((PixmapPtr)(temp_src->pDrawable));
+		x_temp_src = - extent->x1 + x_dest;
+		y_temp_src = - extent->y1 + y_dest;
 	}
 
 	if (mask
@@ -3073,26 +1597,23 @@ _glamor_composite(CARD8 op,
 	    ((!mask->pDrawable
 	      && (mask->pSourcePict->type != SourcePictTypeSolidFill))
 	     || (mask->pDrawable
-		 && (!GLAMOR_PIXMAP_PRIV_HAS_FBO(mask_pixmap_priv))
-		 &&
-		 ((width * height * 4 <
-		   (mask_pixmap->drawable.width *
-		    mask_pixmap->drawable.height))
-		  ||
-		  !(glamor_check_fbo_size
-		    (glamor_priv, mask_pixmap->drawable.width,
-		     mask_pixmap->drawable.height)))))) {
+		 && !GLAMOR_PIXMAP_PRIV_HAS_FBO(mask_pixmap_priv)
+		 && (mask_pixmap->drawable.width != width
+		    || mask_pixmap->drawable.height != height)))) {
 		/* XXX if mask->pDrawable is the same as source->pDrawable, we have an opportunity
 		 * to do reduce one convertion. */
 		temp_mask =
 		    glamor_convert_gradient_picture(screen, mask,
-						    x_mask, y_mask,
+						    extent->x1 + x_mask - x_dest,
+						    extent->y1 + y_mask - y_dest,
 						    width, height);
 		if (!temp_mask) {
 			temp_mask = mask;
-			goto fail;
+			goto out;
 		}
-		x_temp_mask = y_temp_mask = 0;
+		temp_mask_priv = glamor_get_pixmap_private((PixmapPtr)(temp_mask->pDrawable));
+		x_temp_mask = - extent->x1 + x_dest;
+		y_temp_mask = - extent->y1 + y_dest;
 	}
 	/* Do two-pass PictOpOver componentAlpha, until we enable
 	 * dual source color blending.
@@ -3100,43 +1621,25 @@ _glamor_composite(CARD8 op,
 
 	if (mask && mask->componentAlpha) {
 		if (op == PictOpOver) {
-			glamor_composite(PictOpOutReverse,
-					 temp_src, temp_mask, dest,
-					 x_temp_src, y_temp_src,
-					 x_temp_mask, y_temp_mask,
-					 x_dest, y_dest, width, height);
-			glamor_composite(PictOpAdd,
-					 temp_src, temp_mask, dest,
-					 x_temp_src, y_temp_src,
-					 x_temp_mask, y_temp_mask,
-					 x_dest, y_dest, width, height);
-			goto done;
-
-		} else if (op == PictOpAtop
-			   || op == PictOpAtopReverse
-			   || op == PictOpXor
-			   || op >= PictOpSaturate) {
-				glamor_fallback
-					("glamor_composite(): component alpha op %x\n", op);
-				goto fail;
+			two_pass_ca = TRUE;
+			op = PictOpOutReverse;
 		}
 	}
 
-	if (!mask) {
+	if (!mask && temp_src) {
 		if (glamor_composite_with_copy(op, temp_src, dest,
 					       x_temp_src, y_temp_src,
-					       x_dest, y_dest, width,
-					       height))
-			goto done;
+					       x_dest, y_dest, region)) {
+			ok = TRUE;
+			goto out;
+		}
 	}
 
-	/*XXXXX, maybe we can make a copy of dest pixmap.*/
-	if (source_pixmap == dest_pixmap)
-		goto full_fallback;
+	/*XXXXX, self copy?*/
 
 	x_dest += dest->pDrawable->x;
 	y_dest += dest->pDrawable->y;
-	if (temp_src->pDrawable) {
+	if (temp_src && temp_src->pDrawable) {
 		x_temp_src += temp_src->pDrawable->x;
 		y_temp_src += temp_src->pDrawable->y;
 	}
@@ -3144,16 +1647,6 @@ _glamor_composite(CARD8 op,
 		x_temp_mask += temp_mask->pDrawable->x;
 		y_temp_mask += temp_mask->pDrawable->y;
 	}
-	if (!miComputeCompositeRegion(&region,
-				      temp_src, temp_mask, dest,
-				      x_temp_src, y_temp_src,
-				      x_temp_mask, y_temp_mask,
-				      x_dest, y_dest, width,
-				      height))
-		goto done;
-
-	box = REGION_RECTS(&region);
-	nbox = REGION_NUM_RECTS(&region);
 
 	if (nbox > ARRAY_SIZE(rect)) {
 		prect = calloc(nbox, sizeof(*prect));
@@ -3176,24 +1669,177 @@ _glamor_composite(CARD8 op,
 			prect[i].y_dst = box[i].y1;
 			prect[i].width = box[i].x2 - box[i].x1;
 			prect[i].height = box[i].y2 - box[i].y1;
+			DEBUGF("dest %d %d \n", prect[i].x_dst, prect[i].y_dst);
 		}
-		ok = glamor_composite_with_shader(op, temp_src, temp_mask,
-						  dest, box_cnt, prect);
+		ok = glamor_composite_with_shader(op, temp_src, temp_mask, dest,
+						  temp_src_priv, temp_mask_priv,
+						  dest_pixmap_priv,
+						  box_cnt, prect, two_pass_ca);
 		if (!ok)
 			break;
 		nbox -= box_cnt;
 		box += box_cnt;
 	}
 
+	if (prect != rect)
+		free(prect);
+out:
+	if (temp_src != source)
+		FreePicture(temp_src, 0);
+	if (temp_mask != mask)
+		FreePicture(temp_mask, 0);
+
+	return ok;
+}
+
+static Bool
+_glamor_composite(CARD8 op,
+		  PicturePtr source,
+		  PicturePtr mask,
+		  PicturePtr dest,
+		  INT16 x_source,
+		  INT16 y_source,
+		  INT16 x_mask,
+		  INT16 y_mask,
+		  INT16 x_dest, INT16 y_dest,
+		  CARD16 width, CARD16 height, Bool fallback)
+{
+	ScreenPtr screen = dest->pDrawable->pScreen;
+	glamor_pixmap_private *dest_pixmap_priv;
+	glamor_pixmap_private *source_pixmap_priv =
+	    NULL, *mask_pixmap_priv = NULL;
+	PixmapPtr dest_pixmap =
+	    glamor_get_drawable_pixmap(dest->pDrawable);
+	PixmapPtr source_pixmap = NULL, mask_pixmap = NULL;
+	glamor_screen_private *glamor_priv =
+	    glamor_get_screen_private(screen);
+	Bool ret = TRUE;
+	RegionRec region;
+	BoxPtr box, extent;
+	int nbox, ok = FALSE;
+	PixmapPtr sub_dest_pixmap = NULL;
+	PixmapPtr sub_source_pixmap = NULL;
+	PixmapPtr sub_mask_pixmap = NULL;
+	int dest_x_off, dest_y_off, saved_dest_x, saved_dest_y;
+	int source_x_off, source_y_off, saved_source_x, saved_source_y;
+	int mask_x_off, mask_y_off, saved_mask_x, saved_mask_y;
+	DrawablePtr saved_dest_drawable;
+	DrawablePtr saved_source_drawable;
+	DrawablePtr saved_mask_drawable;
+	int force_clip = 0;
+	dest_pixmap_priv = glamor_get_pixmap_private(dest_pixmap);
+
+	if (source->pDrawable) {
+		source_pixmap = glamor_get_drawable_pixmap(source->pDrawable);
+		source_pixmap_priv = glamor_get_pixmap_private(source_pixmap);
+		if (source_pixmap_priv && source_pixmap_priv->type == GLAMOR_DRM_ONLY)
+			goto fail;
+	}
+
+	if (mask && mask->pDrawable) {
+		mask_pixmap = glamor_get_drawable_pixmap(mask->pDrawable);
+		mask_pixmap_priv = glamor_get_pixmap_private(mask_pixmap);
+		if (mask_pixmap_priv && mask_pixmap_priv->type == GLAMOR_DRM_ONLY)
+			goto fail;
+	}
+
+	DEBUGF("source pixmap %p (%d %d) mask(%d %d) dest(%d %d) width %d height %d \n",
+		source_pixmap, x_source, y_source, x_mask, y_mask, x_dest, y_dest, width, height);
+
+	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(dest_pixmap_priv)) {
+		goto fail;
+	}
+
+	if (op >= ARRAY_SIZE(composite_op_info))
+		goto fail;
+
+	if (mask && mask->componentAlpha) {
+		if (op == PictOpAtop
+		    || op == PictOpAtopReverse
+		    || op == PictOpXor
+		    || op >= PictOpSaturate) {
+			glamor_fallback
+				("glamor_composite(): component alpha op %x\n", op);
+			goto fail;
+		}
+	}
+
+	if (!miComputeCompositeRegion(&region,
+				      source, mask, dest,
+				      x_source + (source_pixmap ? source->pDrawable->x : 0),
+				      y_source + (source_pixmap ? source->pDrawable->y : 0),
+				      x_mask + (mask_pixmap ? mask->pDrawable->x : 0),
+				      y_mask + (mask_pixmap ? mask->pDrawable->y : 0),
+				      x_dest + dest->pDrawable->x,
+				      y_dest + dest->pDrawable->y,
+				      width,
+				      height)) {
+		ret = TRUE;
+		goto done;
+	}
+
+	box = REGION_RECTS(&region);
+	nbox = REGION_NUM_RECTS(&region);
+	DEBUGF("first clipped when compositing.\n");
+	DEBUGRegionPrint(&region);
+	extent = RegionExtents(&region);
+	if (nbox == 0) {
+		ret = TRUE;
+		goto done;
+	}
+	/* If destination is not a large pixmap, but the region is larger
+	 * than texture size limitation, and source or mask is memory pixmap,
+	 * then there may be need to load a large memory pixmap to a
+	 * texture, and this is not permitted. Then we force to clip the
+	 * destination and make sure latter will not upload a large memory
+	 * pixmap. */
+	if (!glamor_check_fbo_size(glamor_priv,
+		extent->x2 - extent->x1, extent->y2 - extent->y1)
+	   && (dest_pixmap_priv->type != GLAMOR_TEXTURE_LARGE)
+           && ((source_pixmap_priv
+	        && (source_pixmap_priv->type == GLAMOR_MEMORY || source->repeatType == RepeatPad))
+	     || (mask_pixmap_priv
+		&& (mask_pixmap_priv->type == GLAMOR_MEMORY || mask->repeatType == RepeatPad))
+	     || (!source_pixmap_priv
+		   && (source->pSourcePict->type != SourcePictTypeSolidFill))
+	     || (!mask_pixmap_priv && mask
+		  && mask->pSourcePict->type != SourcePictTypeSolidFill)))
+		force_clip = 1;
+
+	if (force_clip || dest_pixmap_priv->type == GLAMOR_TEXTURE_LARGE
+	    || (source_pixmap_priv
+		&& source_pixmap_priv->type == GLAMOR_TEXTURE_LARGE)
+	    || (mask_pixmap_priv
+		&& mask_pixmap_priv->type == GLAMOR_TEXTURE_LARGE))
+		ok = glamor_composite_largepixmap_region(op,
+						   source, mask, dest,
+						   source_pixmap_priv,
+						   mask_pixmap_priv,
+						   dest_pixmap_priv,
+						   &region, force_clip,
+						   x_source, y_source,
+						   x_mask, y_mask,
+						   x_dest, y_dest,
+						   width, height);
+	else
+		ok = glamor_composite_clipped_region(op, source,
+						     mask, dest,
+						     source_pixmap_priv,
+						     mask_pixmap_priv,
+						     dest_pixmap_priv,
+						     &region,
+						     x_source, y_source,
+						     x_mask, y_mask,
+						     x_dest, y_dest);
+
 	REGION_UNINIT(dest->pDrawable->pScreen, &region);
 	if (ok)
 		goto done;
-
 fail:
 
 	if (!fallback
 	    && glamor_ddx_fallback_check_pixmap(&dest_pixmap->drawable)
-	    && (!source_pixmap 
+	    && (!source_pixmap
 		|| glamor_ddx_fallback_check_pixmap(&source_pixmap->drawable))
 	    && (!mask_pixmap
 		|| glamor_ddx_fallback_check_pixmap(&mask_pixmap->drawable))) {
@@ -3225,23 +1871,21 @@ fail:
 					      width, height, access);			\
 	if (sub_ ##p ##_pixmap != NULL) {						\
 		saved_ ##p ##_drawable = p->pDrawable;					\
-		p->pDrawable = &sub_ ##p ##_pixmap->drawable;				\
 		saved_ ##p ##_x = x_ ##p;						\
 		saved_ ##p ##_y = y_ ##p;						\
 		if (p->pCompositeClip)							\
 			pixman_region_translate (p->pCompositeClip,			\
 						 -p->pDrawable->x - x_ ##p,		\
 						 -p->pDrawable->y - y_ ##p);		\
+		p->pDrawable = &sub_ ##p ##_pixmap->drawable;				\
 		x_ ##p = 0;								\
 		y_ ##p = 0;								\
 	} } while(0)
-
 	GET_SUB_PICTURE(dest, GLAMOR_ACCESS_RW);
-	if (source->pDrawable)
+	if (source->pDrawable && !source->transform)
 		GET_SUB_PICTURE(source, GLAMOR_ACCESS_RO);
-	if (mask && mask->pDrawable)
+	if (mask && mask->pDrawable && !mask->transform)
 		GET_SUB_PICTURE(mask, GLAMOR_ACCESS_RO);
-
 full_fallback:
 	if (glamor_prepare_access_picture(dest, GLAMOR_ACCESS_RW)) {
 		if (source_pixmap == dest_pixmap || glamor_prepare_access_picture
@@ -3268,11 +1912,11 @@ full_fallback:
 	if (sub_ ##p ##_pixmap != NULL) {					\
 		x_ ##p = saved_ ##p ##_x;					\
 		y_ ##p = saved_ ##p ##_y;					\
+		p->pDrawable = saved_ ##p ##_drawable;				\
 		if (p->pCompositeClip)						\
 			pixman_region_translate (p->pCompositeClip,		\
 						 p->pDrawable->x + x_ ##p,	\
 						 p->pDrawable->y + y_ ##p);	\
-		p->pDrawable = saved_ ##p ##_drawable;				\
 		glamor_put_sub_pixmap(sub_ ##p ##_pixmap, p ##_pixmap,		\
 				      x_ ##p + p ##_x_off + p->pDrawable->x,	\
 				      y_ ##p + p ##_y_off + p->pDrawable->y,	\
@@ -3284,12 +1928,6 @@ full_fallback:
 		PUT_SUB_PICTURE(source, GLAMOR_ACCESS_RO);
 	PUT_SUB_PICTURE(dest, GLAMOR_ACCESS_RW);
       done:
-	if (temp_src != source)
-		FreePicture(temp_src, 0);
-	if (temp_mask != mask)
-		FreePicture(temp_mask, 0);
-	if (prect != rect)
-		free(prect);
 	return ret;
 }
 
@@ -3327,173 +1965,112 @@ glamor_composite_nf(CARD8 op,
 				 FALSE);
 }
 
-
-
-
-/**
- * Creates an appropriate picture to upload our alpha mask into (which
- * we calculated in system memory)
- */
-static PicturePtr
-glamor_create_mask_picture(ScreenPtr screen,
-			   PicturePtr dst,
-			   PictFormatPtr pict_format,
-			   CARD16 width, CARD16 height)
+static void
+glamor_get_src_rect_extent(int nrect,
+			   glamor_composite_rect_t *rects,
+			   BoxPtr extent)
 {
-	PixmapPtr pixmap;
-	PicturePtr picture;
-	int error;
-
-	if (!pict_format) {
-		if (dst->polyEdge == PolyEdgeSharp)
-			pict_format =
-			    PictureMatchFormat(screen, 1, PICT_a1);
-		else
-			pict_format =
-			    PictureMatchFormat(screen, 8, PICT_a8);
-		if (!pict_format)
-			return 0;
+	extent->x1 = MAXSHORT;
+	extent->y1 = MAXSHORT;
+	extent->x2 = MINSHORT;
+	extent->y2 = MINSHORT;
+
+	while(nrect--) {
+		if (extent->x1 > rects->x_src)
+			extent->x1 = rects->x_src;
+		if (extent->y1 > rects->y_src)
+			extent->y1 = rects->y_src;
+		if (extent->x2 < rects->x_src + rects->width)
+			extent->x2 = rects->x_src + rects->width;
+		if (extent->y2 < rects->y_src + rects->height)
+			extent->y2 = rects->y_src + rects->height;
+		rects++;
 	}
-
-	pixmap = glamor_create_pixmap(screen, 0, 0,
-				      pict_format->depth,
-				      GLAMOR_CREATE_PIXMAP_CPU);
-	if (!pixmap)
-		return 0;
-	picture = CreatePicture(0, &pixmap->drawable, pict_format,
-				0, 0, serverClient, &error);
-	screen->DestroyPixmap(pixmap);
-	return picture;
 }
 
-/**
- * glamor_trapezoids is a copy of miTrapezoids that does all the trapezoid
- * accumulation in system memory.
- */
-static Bool 
-_glamor_trapezoids(CARD8 op,
-		  PicturePtr src, PicturePtr dst,
-		  PictFormatPtr mask_format, INT16 x_src, INT16 y_src,
-		  int ntrap, xTrapezoid * traps, Bool fallback)
+static void
+glamor_composite_src_rect_translate(int nrect,
+				    glamor_composite_rect_t *rects,
+				    int x, int y)
 {
-	ScreenPtr screen = dst->pDrawable->pScreen;
-	BoxRec bounds;
-	PicturePtr picture;
-	INT16 x_dst, y_dst;
-	INT16 x_rel, y_rel;
-	int width, height, stride;
-	PixmapPtr pixmap;
-	pixman_image_t *image;
-
-	/* If a mask format wasn't provided, we get to choose, but behavior should
-	 * be as if there was no temporary mask the traps were accumulated into.
-	 */
-	if (!mask_format) {
-		if (dst->polyEdge == PolyEdgeSharp)
-			mask_format =
-			    PictureMatchFormat(screen, 1, PICT_a1);
-		else
-			mask_format =
-			    PictureMatchFormat(screen, 8, PICT_a8);
-		for (; ntrap; ntrap--, traps++)
-			glamor_trapezoids(op, src, dst, mask_format, x_src,
-					  y_src, 1, traps);
-		return TRUE;
-	}
-
-	miTrapezoidBounds(ntrap, traps, &bounds);
-
-	if (bounds.y1 >= bounds.y2 || bounds.x1 >= bounds.x2)
-		return TRUE;
-
-	x_dst = traps[0].left.p1.x >> 16;
-	y_dst = traps[0].left.p1.y >> 16;
-
-	width = bounds.x2 - bounds.x1;
-	height = bounds.y2 - bounds.y1;
-	stride = PixmapBytePad(width, mask_format->depth);
-	picture = glamor_create_mask_picture(screen, dst, mask_format,
-					     width, height);
-	if (!picture)
-		return TRUE;
-
-	image = pixman_image_create_bits(picture->format,
-					 width, height, NULL, stride);
-	if (!image) {
-		FreePicture(picture, 0);
-		return TRUE;
+	while(nrect--) {
+		rects->x_src += x;
+		rects->y_src += y;
+		rects++;
 	}
-
-	for (; ntrap; ntrap--, traps++)
-		pixman_rasterize_trapezoid(image,
-					   (pixman_trapezoid_t *) traps,
-					   -bounds.x1, -bounds.y1);
-
-	pixmap = glamor_get_drawable_pixmap(picture->pDrawable);
-
-	screen->ModifyPixmapHeader(pixmap, width, height,
-				   mask_format->depth,
-				   BitsPerPixel(mask_format->depth),
-				   PixmapBytePad(width,
-						 mask_format->depth),
-				   pixman_image_get_data(image));
-
-	x_rel = bounds.x1 + x_src - x_dst;
-	y_rel = bounds.y1 + y_src - y_dst;
-	CompositePicture(op, src, picture, dst,
-			 x_rel, y_rel,
-			 0, 0,
-			 bounds.x1, bounds.y1,
-			 bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
-
-	pixman_image_unref(image);
-
-	FreePicture(picture, 0);
-	return TRUE;
-}
-
-void
-glamor_trapezoids(CARD8 op,
-		  PicturePtr src, PicturePtr dst,
-		  PictFormatPtr mask_format, INT16 x_src, INT16 y_src,
-		  int ntrap, xTrapezoid * traps)
-{
-	_glamor_trapezoids(op, src, dst, mask_format, x_src, 
-			   y_src, ntrap, traps, TRUE);
-}
-
-Bool
-glamor_trapezoids_nf(CARD8 op,
-		     PicturePtr src, PicturePtr dst,
-		     PictFormatPtr mask_format, INT16 x_src, INT16 y_src,
-		     int ntrap, xTrapezoid * traps)
-{
-	return _glamor_trapezoids(op, src, dst, mask_format, x_src, 
-				  y_src, ntrap, traps, FALSE);
 }
 
-
-
 void
 glamor_composite_glyph_rects(CARD8 op,
 			     PicturePtr src, PicturePtr mask, PicturePtr dst,
 			     int nrect, glamor_composite_rect_t * rects)
 {
 	int n;
+	PicturePtr temp_src = NULL;
 	glamor_composite_rect_t *r;
 
 	ValidatePicture(src);
 	ValidatePicture(dst);
+	if (!(glamor_is_large_picture(src)
+	    || (mask && glamor_is_large_picture(mask))
+	    || glamor_is_large_picture(dst))) {
+		glamor_pixmap_private *src_pixmap_priv = NULL;
+		glamor_pixmap_private *mask_pixmap_priv = NULL;
+		glamor_pixmap_private *dst_pixmap_priv;
+		glamor_pixmap_private *temp_src_priv = NULL;
+		BoxRec src_extent;
+
+		dst_pixmap_priv = glamor_get_pixmap_private
+					(glamor_get_drawable_pixmap(dst->pDrawable));
+
+		if (mask && mask->pDrawable)
+			mask_pixmap_priv = glamor_get_pixmap_private
+						(glamor_get_drawable_pixmap(mask->pDrawable));
+		if (src->pDrawable)
+			src_pixmap_priv = glamor_get_pixmap_private
+						(glamor_get_drawable_pixmap(src->pDrawable));
+
+		if (!src->pDrawable
+		    && (src->pSourcePict->type != SourcePictTypeSolidFill)) {
+			glamor_get_src_rect_extent(nrect, rects, &src_extent);
+			temp_src = glamor_convert_gradient_picture(dst->pDrawable->pScreen,
+						    src,
+						    src_extent.x1, src_extent.y1,
+						    src_extent.x2 - src_extent.x1,
+						    src_extent.y2 - src_extent.y1);
+			if (!temp_src)
+				goto fallback;
+
+			temp_src_priv = glamor_get_pixmap_private
+						((PixmapPtr)(temp_src->pDrawable));
+			glamor_composite_src_rect_translate(nrect, rects,
+							-src_extent.x1, -src_extent.y1);
+		} else {
+			temp_src = src;
+			temp_src_priv = src_pixmap_priv;
+		}
 
-	if (glamor_composite_with_shader(op, src, mask, dst, nrect, rects))
-		return;
-
+		if (mask && mask->componentAlpha) {
+			if (op == PictOpOver) {
+				if (glamor_composite_with_shader(PictOpOutReverse,
+						 temp_src, mask, dst, temp_src_priv,
+						 mask_pixmap_priv, dst_pixmap_priv, nrect, rects,
+						 TRUE))
+					goto done;
+			}
+		} else {
+				if (glamor_composite_with_shader(op, temp_src, mask, dst, temp_src_priv,
+						 mask_pixmap_priv, dst_pixmap_priv, nrect, rects, FALSE))
+					goto done;
+		}
+	}
+fallback:
 	n = nrect;
 	r = rects;
 
 	while (n--) {
 		CompositePicture(op,
-				 src,
+				 temp_src ? temp_src : src,
 				 mask,
 				 dst,
 				 r->x_src, r->y_src,
@@ -3501,6 +2078,10 @@ glamor_composite_glyph_rects(CARD8 op,
 				 r->x_dst, r->y_dst, r->width, r->height);
 		r++;
 	}
+
+done:
+	if (temp_src && temp_src != src)
+		FreePicture(temp_src, 0);
 }
 
 static Bool
diff --git a/glamor_tile.c b/glamor_tile.c
index df66d05..60486cf 100644
--- a/glamor_tile.c
+++ b/glamor_tile.c
@@ -102,10 +102,9 @@ glamor_fini_tile_shader(ScreenPtr screen)
 	glamor_put_dispatch(glamor_priv);
 }
 
-Bool
-glamor_tile(PixmapPtr pixmap, PixmapPtr tile,
+static void
+_glamor_tile(PixmapPtr pixmap, PixmapPtr tile,
 	    int x, int y, int width, int height,
-	    unsigned char alu, unsigned long planemask,
 	    int tile_x, int tile_y)
 {
 	ScreenPtr screen = pixmap->drawable.pScreen;
@@ -125,54 +124,22 @@ glamor_tile(PixmapPtr pixmap, PixmapPtr tile,
 	GLfloat dst_xscale, dst_yscale, src_xscale, src_yscale;
 	glamor_pixmap_private *src_pixmap_priv;
 	glamor_pixmap_private *dst_pixmap_priv;
-	float wh[2];
-
+	float wh[4];
 	src_pixmap_priv = glamor_get_pixmap_private(tile);
 	dst_pixmap_priv = glamor_get_pixmap_private(pixmap);
 
-	if (src_pixmap_priv == NULL || dst_pixmap_priv == NULL)
-		goto fail;
-
-	if (glamor_priv->tile_prog == 0) {
-		glamor_fallback("Tiling unsupported\n");
-		goto fail;
-	}
-
-	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(dst_pixmap_priv)) {
-		glamor_fallback("dest has no fbo.\n");
-		goto fail;
-	}
-	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(src_pixmap_priv)) {
-		/* XXX dynamic uploading candidate. */
-		glamor_fallback("Non-texture tile pixmap\n");
-		goto fail;
-	}
-
-	if (!glamor_set_planemask(pixmap, planemask)) {
-		glamor_fallback("unsupported planemask %lx\n", planemask);
-		goto fail;
-	}
-
 	glamor_set_destination_pixmap_priv_nc(dst_pixmap_priv);
-	pixmap_priv_get_scale(dst_pixmap_priv, &dst_xscale, &dst_yscale);
-
-	dispatch = glamor_get_dispatch(glamor_priv);
-	if (!glamor_set_alu(dispatch, alu)) {
-		glamor_put_dispatch(glamor_priv);
-		goto fail;
-	}
-
+	pixmap_priv_get_dest_scale(dst_pixmap_priv, &dst_xscale, &dst_yscale);
 	pixmap_priv_get_scale(src_pixmap_priv, &src_xscale,
 			      &src_yscale);
+	dispatch = glamor_get_dispatch(glamor_priv);
 	dispatch->glUseProgram(glamor_priv->tile_prog);
 
-	wh[0] = (float)src_pixmap_priv->fbo->width / tile->drawable.width;
-	wh[1] = (float)src_pixmap_priv->fbo->height / tile->drawable.height;
-
+	glamor_pixmap_fbo_fix_wh_ratio(wh, src_pixmap_priv);
 	dispatch->glUniform2fv(glamor_priv->tile_wh, 1, wh);
 	dispatch->glActiveTexture(GL_TEXTURE0);
 	dispatch->glBindTexture(GL_TEXTURE_2D,
-				src_pixmap_priv->fbo->tex);
+				src_pixmap_priv->base.fbo->tex);
 	dispatch->glTexParameteri(GL_TEXTURE_2D,
 				  GL_TEXTURE_MIN_FILTER,
 				  GL_NEAREST);
@@ -186,19 +153,23 @@ glamor_tile(PixmapPtr pixmap, PixmapPtr tile,
 #ifndef GLAMOR_GLES2
 	dispatch->glEnable(GL_TEXTURE_2D);
 #endif
-	glamor_set_normalize_tcoords(src_xscale, src_yscale,
-				     tile_x1, tile_y1,
-				     tile_x2, tile_y2,
-				     glamor_priv->yInverted,
-				     source_texcoords);
+	glamor_set_repeat_normalize_tcoords
+			(src_pixmap_priv, RepeatNormal,
+			 src_xscale, src_yscale,
+			 tile_x1, tile_y1,
+			 tile_x2, tile_y2,
+			 glamor_priv->yInverted,
+			 source_texcoords);
+
 	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_SOURCE, 2,
 					GL_FLOAT, GL_FALSE,
 					2 * sizeof(float),
 					source_texcoords);
 	dispatch->glEnableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
 
-	glamor_set_normalize_vcoords(dst_xscale, dst_yscale,
-				     x1, y1, x2, y2,
+	glamor_set_normalize_vcoords(dst_pixmap_priv, dst_xscale, dst_yscale,
+				     x1, y1,
+				     x2, y2,
 				     glamor_priv->yInverted, vertices);
 
 	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_POS, 2, GL_FLOAT,
@@ -213,11 +184,142 @@ glamor_tile(PixmapPtr pixmap, PixmapPtr tile,
 #endif
 	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
 	dispatch->glUseProgram(0);
+	glamor_put_dispatch(glamor_priv);
+
+	glamor_priv->state = RENDER_STATE;
+	glamor_priv->render_idle_cnt = 0;
+}
+
+Bool
+glamor_tile(PixmapPtr pixmap, PixmapPtr tile,
+	    int x, int y, int width, int height,
+	    unsigned char alu, unsigned long planemask,
+	    int tile_x, int tile_y)
+{
+	ScreenPtr screen = pixmap->drawable.pScreen;
+	glamor_screen_private *glamor_priv =
+	    glamor_get_screen_private(screen);
+	glamor_pixmap_private *dst_pixmap_priv;
+	glamor_pixmap_private *src_pixmap_priv;
+	glamor_gl_dispatch *dispatch;
+
+	dst_pixmap_priv = glamor_get_pixmap_private(pixmap);
+	src_pixmap_priv = glamor_get_pixmap_private(tile);
+
+	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(dst_pixmap_priv))
+		return FALSE;
+
+	if (glamor_priv->tile_prog == 0) {
+		glamor_fallback("Tiling unsupported\n");
+		goto fail;
+	}
+
+	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(src_pixmap_priv)) {
+		/* XXX dynamic uploading candidate. */
+		glamor_fallback("Non-texture tile pixmap\n");
+		goto fail;
+	}
+
+	if (!glamor_set_planemask(pixmap, planemask)) {
+		glamor_fallback("unsupported planemask %lx\n", planemask);
+		goto fail;
+	}
+
+	dispatch = glamor_get_dispatch(glamor_priv);
+	if (!glamor_set_alu(dispatch, alu)) {
+		glamor_fallback("unsupported alu %x\n", alu);
+		glamor_put_dispatch(glamor_priv);
+		goto fail;
+	}
+
+	if (dst_pixmap_priv->type == GLAMOR_TEXTURE_LARGE
+	    || src_pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
+			glamor_pixmap_clipped_regions *clipped_dst_regions;
+			int n_dst_region, i, j, k;
+			BoxRec box;
+			RegionRec region;
+
+			box.x1 = x;
+			box.y1 = y;
+			box.x2 = x + width;
+			box.y2 = y + height;
+			RegionInitBoxes(&region, &box, 1);
+			clipped_dst_regions = glamor_compute_clipped_regions(dst_pixmap_priv,
+									     &region, &n_dst_region, 0, 0, 0);
+			for(i = 0; i < n_dst_region; i++)
+			{
+				int n_src_region;
+				glamor_pixmap_clipped_regions *clipped_src_regions;
+				BoxPtr current_boxes;
+				int n_current_boxes;
+
+				SET_PIXMAP_FBO_CURRENT(dst_pixmap_priv, clipped_dst_regions[i].block_idx);
+
+				if (src_pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
+					RegionTranslate(clipped_dst_regions[i].region,
+							tile_x - x, tile_y - y);
+					DEBUGF("tiled a large src pixmap. %dx%d \n", tile->drawable.width, tile->drawable.height);
+					clipped_src_regions = glamor_compute_clipped_regions(src_pixmap_priv,
+											     clipped_dst_regions[i].region,
+											     &n_src_region, 1, 0, 0);
+					DEBUGF("got %d src regions %d \n", n_src_region);
+					for (j = 0; j < n_src_region; j++)
+					{
+
+						SET_PIXMAP_FBO_CURRENT(src_pixmap_priv, clipped_src_regions[j].block_idx);
+
+						RegionTranslate(clipped_src_regions[j].region,
+								x - tile_x,
+								y - tile_y);
+						current_boxes = RegionRects(clipped_src_regions[j].region);
+						n_current_boxes = RegionNumRects(clipped_src_regions[j].region);
+						for(k = 0; k < n_current_boxes; k++)
+						{
+							DEBUGF("Tile on %d %d %d %d dst block id %d tile block id %d tilex %d tiley %d\n",
+								     current_boxes[k].x1, current_boxes[k].y1,
+								     current_boxes[k].x2 - current_boxes[k].x1,
+								     current_boxes[k].y2 - current_boxes[k].y1,
+									clipped_dst_regions[i].block_idx,
+									clipped_src_regions[j].block_idx,
+								     (tile_x + (current_boxes[k].x1 - x)),
+								     tile_y + (current_boxes[k].y1 - y));
+
+							_glamor_tile(pixmap, tile,
+								     current_boxes[k].x1, current_boxes[k].y1,
+								     current_boxes[k].x2 - current_boxes[k].x1,
+								     current_boxes[k].y2 - current_boxes[k].y1,
+								     (tile_x + (current_boxes[k].x1 - x)),
+								     (tile_y + (current_boxes[k].y1 - y)));
+						}
+
+						RegionDestroy(clipped_src_regions[j].region);
+					}
+					free(clipped_src_regions);
+				} else {
+					current_boxes = RegionRects(clipped_dst_regions[i].region);
+					n_current_boxes = RegionNumRects(clipped_dst_regions[i].region);
+					for(k = 0; k < n_current_boxes; k++)
+					{
+						_glamor_tile(pixmap, tile,
+							     current_boxes[k].x1, current_boxes[k].y1,
+							     current_boxes[k].x2 - current_boxes[k].x1,
+							     current_boxes[k].y2 - current_boxes[k].y1,
+							     (tile_x + (current_boxes[k].x1 - x)),
+							     (tile_y + (current_boxes[k].y1 - y)));
+					}
+				}
+				RegionDestroy(clipped_dst_regions[i].region);
+			}
+			free(clipped_dst_regions);
+			RegionUninit(&region);
+	}
+	else
+		_glamor_tile(pixmap, tile, x, y, width, height, tile_x, tile_y);
+
 	glamor_set_alu(dispatch, GXcopy);
-	glamor_set_planemask(pixmap, ~0);
 	glamor_put_dispatch(glamor_priv);
 	return TRUE;
-
-      fail:
+fail:
 	return FALSE;
+
 }
diff --git a/glamor_trapezoid.c b/glamor_trapezoid.c
new file mode 100644
index 0000000..fd63062
--- /dev/null
+++ b/glamor_trapezoid.c
@@ -0,0 +1,1758 @@
+/*
+ * Copyright  2009 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Junyan He <junyan.he@linux.intel.com>
+ *
+ */
+
+/** @file glamor_trapezoid.c
+ *
+ * Trapezoid acceleration implementation
+ */
+
+#include "glamor_priv.h"
+
+#ifdef RENDER
+#include "mipict.h"
+#include "fbpict.h"
+
+#ifdef GLAMOR_TRAPEZOID_SHADER
+
+#define GLAMOR_VERTEX_TOP_BOTTOM  (GLAMOR_VERTEX_SOURCE + 1)
+#define GLAMOR_VERTEX_LEFT_PARAM  (GLAMOR_VERTEX_SOURCE + 2)
+#define GLAMOR_VERTEX_RIGHT_PARAM (GLAMOR_VERTEX_SOURCE + 3)
+
+#define DEBUG_CLIP_VTX 0
+
+#define POINT_INSIDE_CLIP_RECT(point, rect)	\
+    (point[0] >= IntToxFixed(rect->x1)		\
+     && point[0] <= IntToxFixed(rect->x2) 	\
+     && point[1] >= IntToxFixed(rect->y1)	\
+     && point[1] <= IntToxFixed(rect->y2))
+
+static xFixed
+_glamor_lines_crossfixedY (xLineFixed *l, xLineFixed *r)
+{
+	xFixed dx1 = l->p2.x - l->p1.x;
+	xFixed dx2 = r->p2.x - r->p1.x;
+	xFixed dy1 = l->p2.y - l->p1.y;
+	xFixed dy2 = r->p2.y - r->p1.y;
+	xFixed_32_32 tmp = (xFixed_32_32) dy2 * dy1;
+	xFixed_32_32 dividend1 = (tmp >> 32) * (l->p1.x - r->p1.x);
+	tmp = (xFixed_32_32) dx1 * dy2;
+	xFixed_32_32 dividend2 = (tmp >> 32) * l->p1.y;
+	tmp = (xFixed_32_32) dy1 * dx2;
+	xFixed_32_32 dividend3 = (tmp >> 32) * r->p1.y;
+	xFixed_32_32 divisor = ((xFixed_32_32) dx1 * (xFixed_32_32) dy2
+	                           - (xFixed_32_32) dy1 * (xFixed_32_32) dx2) >> 32;
+
+	if (divisor)
+		return (xFixed)((dividend2 - dividend1 - dividend3) / divisor);
+
+	return 0xFFFFFFFF;
+}
+
+static xFixed
+_glamor_linefixedX (xLineFixed *l, xFixed y, Bool ceil)
+{
+	xFixed dx = l->p2.x - l->p1.x;
+	xFixed_32_32 ex = (xFixed_32_32) (y - l->p1.y) * dx;
+	xFixed dy = l->p2.y - l->p1.y;
+	if (ceil)
+		ex += (dy - 1);
+	return l->p1.x + (xFixed) (ex / dy);
+}
+
+static xFixed
+_glamor_linefixedY (xLineFixed *l, xFixed x, Bool ceil)
+{
+	xFixed dy = l->p2.y - l->p1.y;
+	xFixed_32_32 ey = (xFixed_32_32) (x - l->p1.x) * dy;
+	xFixed dx = l->p2.x - l->p1.x;
+	if (ceil)
+		ey += (dx - 1);
+	return l->p1.y + (xFixed) (ey / dx);
+}
+
+static Bool
+point_inside_trapezoid(int point[2], xTrapezoid * trap, xFixed cut_y)
+{
+	int ret = TRUE;
+	int tmp;
+	if (point[1] > trap->bottom) {
+		ret = FALSE;
+		if (DEBUG_CLIP_VTX) {
+			ErrorF("Out of Trap bottom, point[1] = %d(0x%x)), "
+			       "bottom = %d(0x%x)\n",
+			       (unsigned int)xFixedToInt(point[1]), point[1],
+			       (unsigned int)xFixedToInt(trap->bottom),
+			       (unsigned int)trap->bottom);
+		}
+
+		return ret;
+	}
+
+	if (point[1] < trap->top) {
+		ret = FALSE;
+		if (DEBUG_CLIP_VTX) {
+			ErrorF("Out of Trap top, point[1] = %d(0x%x)), "
+			       "top = %d(0x%x)\n",
+			       (unsigned int)xFixedToInt(point[1]), point[1],
+			       (unsigned int)xFixedToInt(trap->top),
+			       (unsigned int)trap->top);
+		}
+
+		return ret;
+	}
+
+	tmp = _glamor_linefixedX (&trap->left, point[1], FALSE);
+	if (point[0] < tmp) {
+		ret = FALSE;
+
+		if (abs(cut_y - trap->top) < pixman_fixed_1_minus_e &&
+		           abs(point[1] - trap->top) < pixman_fixed_1_minus_e &&
+		           tmp - point[0] < pixman_fixed_1_minus_e) {
+			ret = TRUE;
+		} else if (abs(cut_y - trap->bottom) < pixman_fixed_1_minus_e &&
+		           point[1] - trap->bottom < pixman_fixed_1_minus_e &&
+		           tmp - point[0] < pixman_fixed_1_minus_e) {
+			ret = TRUE;
+		}
+
+		if (DEBUG_CLIP_VTX && !ret) {
+			ErrorF("Out of Trap left, point[0] = %d(0x%x)), "
+			       "left = %d(0x%x)\n",
+			       (unsigned int)xFixedToInt(point[0]), point[0],
+			       (unsigned int)xFixedToInt(tmp), (unsigned int)tmp);
+		}
+
+		if (!ret)
+			return ret;
+	}
+
+	tmp = _glamor_linefixedX (&trap->right, point[1], TRUE);
+	if (point[0] > tmp) {
+		ret = FALSE;
+
+		if (abs(cut_y - trap->top) < pixman_fixed_1_minus_e &&
+		           abs(point[1] - trap->top) < pixman_fixed_1_minus_e &&
+		           point[0] - tmp < pixman_fixed_1_minus_e) {
+			ret = TRUE;
+		} else if (abs(cut_y - trap->bottom) < pixman_fixed_1_minus_e &&
+		           abs(point[1] - trap->bottom) < pixman_fixed_1_minus_e &&
+		           point[0] - tmp < pixman_fixed_1_minus_e) {
+			ret = TRUE;
+		}
+
+		if (DEBUG_CLIP_VTX && !ret) {
+			ErrorF("Out of Trap right, point[0] = %d(0x%x)), "
+			       "right = %d(0x%x)\n",
+			       (unsigned int)xFixedToInt(point[0]), point[0],
+			       (unsigned int)xFixedToInt(tmp), (unsigned int)tmp);
+		}
+
+		if (!ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+static void
+glamor_emit_composite_triangle(ScreenPtr screen,
+        const float *src_coords,
+        const float *mask_coords,
+        const float *dst_coords)
+{
+	glamor_emit_composite_vert(screen, src_coords, mask_coords,
+	        dst_coords, 0);
+	glamor_emit_composite_vert(screen, src_coords, mask_coords,
+	        dst_coords, 1);
+	glamor_emit_composite_vert(screen, src_coords, mask_coords,
+	        dst_coords, 2);
+}
+
+static void
+glamor_flush_composite_triangles(ScreenPtr screen)
+{
+	glamor_screen_private *glamor_priv =
+	    glamor_get_screen_private(screen);
+	glamor_gl_dispatch *dispatch;
+
+	dispatch = glamor_get_dispatch(glamor_priv);
+	if (glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP)
+		dispatch->glUnmapBuffer(GL_ARRAY_BUFFER);
+	else {
+
+		dispatch->glBindBuffer(GL_ARRAY_BUFFER, glamor_priv->vbo);
+		dispatch->glBufferData(GL_ARRAY_BUFFER,
+		        glamor_priv->vbo_offset,
+		        glamor_priv->vb, GL_DYNAMIC_DRAW);
+	}
+
+	if (!glamor_priv->render_nr_verts)
+		return;
+
+	dispatch->glDrawArrays(GL_TRIANGLES, 0, glamor_priv->render_nr_verts);
+	glamor_put_dispatch(glamor_priv);
+}
+
+static Bool
+_glamor_clip_trapezoid_vertex(xTrapezoid * trap, BoxPtr pbox,
+        int vertex[6], int *num)
+{
+	xFixed edge_cross_y = 0xFFFFFFFF;
+	int tl[2];
+	int bl[2];
+	int tr[2];
+	int br[2];
+	int left_cut_top[2];
+	int left_cut_left[2];
+	int left_cut_right[2];
+	int left_cut_bottom[2];
+	int right_cut_top[2];
+	int right_cut_left[2];
+	int right_cut_right[2];
+	int right_cut_bottom[2];
+	int tmp[2];
+	int tmp_vtx[20*2];
+	float tmp_vtx_slope[20];
+	BoxRec trap_bound;
+	int i = 0;
+	int vertex_num = 0;
+
+	if (DEBUG_CLIP_VTX) {
+		ErrorF("The parameter of xTrapezoid is:\ntop: %d  0x%x\tbottom: %d  0x%x\n"
+		       "left:  p1 (%d   0x%x, %d   0x%x)\tp2 (%d   0x%x, %d   0x%x)\n"
+		       "right: p1 (%d   0x%x, %d   0x%x)\tp2 (%d   0x%x, %d   0x%x)\n",
+		       xFixedToInt(trap->top), (unsigned int)trap->top,
+		       xFixedToInt(trap->bottom), (unsigned int)trap->bottom,
+		       xFixedToInt(trap->left.p1.x), (unsigned int)trap->left.p1.x,
+		       xFixedToInt(trap->left.p1.y), (unsigned int)trap->left.p1.y,
+		       xFixedToInt(trap->left.p2.x), (unsigned int)trap->left.p2.x,
+		       xFixedToInt(trap->left.p2.y), (unsigned int)trap->left.p2.y,
+		       xFixedToInt(trap->right.p1.x), (unsigned int)trap->right.p1.x,
+		       xFixedToInt(trap->right.p1.y), (unsigned int)trap->right.p1.y,
+		       xFixedToInt(trap->right.p2.x), (unsigned int)trap->right.p2.x,
+		       xFixedToInt(trap->right.p2.y), (unsigned int)trap->right.p2.y);
+	}
+
+	miTrapezoidBounds(1, trap, &trap_bound);
+	if (DEBUG_CLIP_VTX)
+		ErrorF("The bounds for this traps is: bounds.x1 = %d, bounds.x2 = %d, "
+		       "bounds.y1 = %d, bounds.y2 = %d\n", trap_bound.x1, trap_bound.x2,
+		       trap_bound.y1, trap_bound.y2);
+
+	if (trap_bound.x1 > pbox->x2 || trap_bound.x2 < pbox->x1)
+		return FALSE;
+	if (trap_bound.y1 > pbox->y2 || trap_bound.y2 < pbox->y1)
+		return FALSE;
+
+#define IS_TRAP_EDGE_VERTICAL(edge)		\
+	(edge->p1.x == edge->p2.x)
+
+#define CACULATE_CUT_VERTEX(vtx, cal_x, ceil, vh_edge, edge)		\
+	do {								\
+	    if(cal_x) {							\
+		vtx[1] = (vh_edge);					\
+		vtx[0] = (_glamor_linefixedX(				\
+			      edge, vh_edge, ceil));			\
+		if(DEBUG_CLIP_VTX)					\
+		    ErrorF("The intersection point of line y=%d and "	\
+			   "line of p1:(%d,%d) -- p2 (%d,%d) "		\
+			   "is (%d, %d)\n",				\
+			   xFixedToInt(vh_edge),			\
+			   xFixedToInt(edge->p1.x),			\
+			   xFixedToInt(edge->p1.y),			\
+			   xFixedToInt(edge->p2.x),			\
+			   xFixedToInt(edge->p2.y),			\
+			   xFixedToInt(vtx[0]),				\
+			   xFixedToInt(vtx[1]));			\
+	    } else {							\
+		vtx[0] = (vh_edge);					\
+		vtx[1] = (_glamor_linefixedY(				\
+			      edge, vh_edge, ceil));			\
+		if(DEBUG_CLIP_VTX)					\
+		    ErrorF("The intersection point of line x=%d and "	\
+			   "line of p1:(%d,%d) -- p2 (%d,%d) "		\
+			   "is (%d, %d)\n",				\
+			   xFixedToInt(vh_edge),			\
+			   xFixedToInt(edge->p1.x),			\
+			   xFixedToInt(edge->p1.y),			\
+			   xFixedToInt(edge->p2.x),			\
+			   xFixedToInt(edge->p2.y),			\
+			   xFixedToInt(vtx[0]),				\
+			   xFixedToInt(vtx[1]));			\
+	    }								\
+	} while(0)
+
+#define ADD_VERTEX_IF_INSIDE(vtx)				\
+	if(POINT_INSIDE_CLIP_RECT(vtx, pbox)			\
+	   && point_inside_trapezoid(vtx, trap, edge_cross_y)){	\
+	    tmp_vtx[vertex_num] = xFixedToInt(vtx[0]);		\
+	    tmp_vtx[vertex_num + 1] = xFixedToInt(vtx[1]);	\
+	    vertex_num += 2;					\
+	    if(DEBUG_CLIP_VTX)					\
+		ErrorF("@ Point: (%d, %d) is inside "		\
+		       "the Rect and Trapezoid\n",		\
+		       xFixedToInt(vtx[0]),			\
+		       xFixedToInt(vtx[1]));			\
+	} else if(DEBUG_CLIP_VTX){				\
+	    ErrorF("X Point: (%d, %d) is outside "		\
+		   "the Rect and Trapezoid\t",			\
+		   xFixedToInt(vtx[0]),				\
+		   xFixedToInt(vtx[1]));			\
+	    if(POINT_INSIDE_CLIP_RECT(vtx, pbox))		\
+		ErrorF("The Point is outside "			\
+		       "the Trapezoid\n");			\
+	    else						\
+		ErrorF("The Point is outside "			\
+		       "the Rect\n");				\
+	}
+
+	/*Trap's right edge cut right edge. */
+	if((!IS_TRAP_EDGE_VERTICAL((&trap->left))) ||
+	        (!IS_TRAP_EDGE_VERTICAL((&trap->right)))) {
+		edge_cross_y = _glamor_lines_crossfixedY((&trap->left), (&trap->right));
+		if (DEBUG_CLIP_VTX) {
+			ErrorF("Trap's left edge cut right edge at %d(0x%x), "
+			       "trap_top = %x, trap_bottom = %x\n",
+			       xFixedToInt(edge_cross_y), edge_cross_y,
+			       (unsigned int)trap->top, (unsigned int)trap->bottom);
+		}
+	}
+
+	/*Trap's TopLeft, BottomLeft, TopRight and BottomRight. */
+	CACULATE_CUT_VERTEX(tl, 1, FALSE, trap->top, (&trap->left));
+	CACULATE_CUT_VERTEX(bl, 1, FALSE, trap->bottom, (&trap->left));
+	CACULATE_CUT_VERTEX(tr, 1, TRUE, trap->top, (&trap->right));
+	CACULATE_CUT_VERTEX(br, 1, TRUE, trap->bottom, (&trap->right));
+
+	if (DEBUG_CLIP_VTX)
+		ErrorF("Trap's TopLeft, BottomLeft, TopRight and BottomRight\n");
+	if (DEBUG_CLIP_VTX)
+		ErrorF("Caculate the vertex of trapezoid:\n"
+		       "      (%3d, %3d)-------------------------(%3d, %3d)\n"
+		       "              /                           \\       \n"
+		       "             /                             \\      \n"
+		       "            /                               \\     \n"
+		       "  (%3d, %3d)---------------------------------(%3d, %3d)\n"
+		       "Clip with rect:\n"
+		       "  (%3d, %3d)------------------------(%3d, %3d)    \n"
+		       "           |                        |             \n"
+		       "           |                        |             \n"
+		       "           |                        |             \n"
+		       "  (%3d, %3d)------------------------(%3d, %3d)    \n",
+		       xFixedToInt(tl[0]), xFixedToInt(tl[1]), xFixedToInt(tr[0]),
+		       xFixedToInt(tr[1]), xFixedToInt(bl[0]), xFixedToInt(bl[1]),
+		       xFixedToInt(br[0]), xFixedToInt(br[1]),
+		       pbox->x1, pbox->y1, pbox->x2, pbox->y1, pbox->x1, pbox->y2,
+		       pbox->x2, pbox->y2);
+
+	ADD_VERTEX_IF_INSIDE(tl);
+	ADD_VERTEX_IF_INSIDE(bl);
+	ADD_VERTEX_IF_INSIDE(tr);
+	ADD_VERTEX_IF_INSIDE(br);
+
+	/*Trap's left edge cut Rect. */
+	if (DEBUG_CLIP_VTX)
+		ErrorF("Trap's left edge cut Rect\n");
+	CACULATE_CUT_VERTEX(left_cut_top, 1, FALSE, IntToxFixed(pbox->y1), (&trap->left));
+	ADD_VERTEX_IF_INSIDE(left_cut_top);
+	if (!IS_TRAP_EDGE_VERTICAL((&trap->left))) {
+		CACULATE_CUT_VERTEX(left_cut_left, 0, FALSE, IntToxFixed(pbox->x1), (&trap->left));
+		ADD_VERTEX_IF_INSIDE(left_cut_left);
+	}
+	CACULATE_CUT_VERTEX(left_cut_bottom, 1, FALSE, IntToxFixed(pbox->y2), (&trap->left));
+	ADD_VERTEX_IF_INSIDE(left_cut_bottom);
+	if (!IS_TRAP_EDGE_VERTICAL((&trap->left))) {
+		CACULATE_CUT_VERTEX(left_cut_right, 0, FALSE, IntToxFixed(pbox->x2), (&trap->left));
+		ADD_VERTEX_IF_INSIDE(left_cut_right);
+	}
+
+	/*Trap's right edge cut Rect. */
+	if (DEBUG_CLIP_VTX)
+		ErrorF("Trap's right edge cut Rect\n");
+	CACULATE_CUT_VERTEX(right_cut_top, 1, TRUE, IntToxFixed(pbox->y1), (&trap->right));
+	ADD_VERTEX_IF_INSIDE(right_cut_top);
+	if (!IS_TRAP_EDGE_VERTICAL((&trap->right))) {
+		CACULATE_CUT_VERTEX(right_cut_left, 0, TRUE, IntToxFixed(pbox->x1), (&trap->right));
+		ADD_VERTEX_IF_INSIDE(right_cut_left);
+	}
+	CACULATE_CUT_VERTEX(right_cut_bottom, 1, TRUE, IntToxFixed(pbox->y2), (&trap->right));
+	ADD_VERTEX_IF_INSIDE(right_cut_bottom);
+	if (!IS_TRAP_EDGE_VERTICAL((&trap->right))) {
+		CACULATE_CUT_VERTEX(right_cut_right, 0, TRUE, IntToxFixed(pbox->x2), (&trap->right));
+		ADD_VERTEX_IF_INSIDE(right_cut_right);
+	}
+
+	/* Trap's top cut Left and Right of rect. */
+	if (DEBUG_CLIP_VTX)
+		ErrorF("Trap's top cut Left and Right of rect\n");
+	tmp[0] = IntToxFixed(pbox->x1);
+	tmp[1] = trap->top;
+	ADD_VERTEX_IF_INSIDE(tmp);
+	tmp[0] = IntToxFixed(pbox->x2);
+	tmp[1] = trap->top;
+	ADD_VERTEX_IF_INSIDE(tmp);
+
+	/* Trap's bottom cut Left and Right of rect. */
+	if (DEBUG_CLIP_VTX)
+		ErrorF("Trap's bottom cut Left and Right of rect\n");
+	tmp[0] = IntToxFixed(pbox->x1);
+	tmp[1] = trap->bottom;
+	ADD_VERTEX_IF_INSIDE(tmp);
+	tmp[0] = IntToxFixed(pbox->x2);
+	tmp[1] = trap->bottom;
+	ADD_VERTEX_IF_INSIDE(tmp);
+
+	/* The orginal 4 vertex of rect. */
+	if (DEBUG_CLIP_VTX)
+		ErrorF("The orginal 4 vertex of rect\n");
+	tmp[0] = IntToxFixed(pbox->x1);
+	tmp[1] = IntToxFixed(pbox->y1);
+	ADD_VERTEX_IF_INSIDE(tmp);
+	tmp[0] = IntToxFixed(pbox->x1);
+	tmp[1] = IntToxFixed(pbox->y2);
+	ADD_VERTEX_IF_INSIDE(tmp);
+	tmp[0] = IntToxFixed(pbox->x2);
+	tmp[1] = IntToxFixed(pbox->y2);
+	ADD_VERTEX_IF_INSIDE(tmp);
+	tmp[0] = IntToxFixed(pbox->x2);
+	tmp[1] = IntToxFixed(pbox->y1);
+	ADD_VERTEX_IF_INSIDE(tmp);
+
+	if (DEBUG_CLIP_VTX) {
+		ErrorF("\nThe candidate vertex number is %d\n", vertex_num / 2);
+		for (i = 0; i < vertex_num / 2; i++) {
+			ErrorF("(%d, %d) ", tmp_vtx[2*i], tmp_vtx[2*i + 1]);
+		}
+		ErrorF("\n");
+	}
+
+	/* Sort the vertex by X and then Y. */
+	for (i = 0; i < vertex_num / 2; i++) {
+		int j;
+		for (j = 0; j < vertex_num / 2 - i - 1; j++) {
+			if (tmp_vtx[2*j] > tmp_vtx[2*(j+1)]
+			     || (tmp_vtx[2*j] == tmp_vtx[2*(j+1)]
+			         && tmp_vtx[2*j + 1] > tmp_vtx[2*(j+1) + 1])) {
+				tmp[0] = tmp_vtx[2*j];
+				tmp[1] = tmp_vtx[2*j + 1];
+				tmp_vtx[2*j] = tmp_vtx[2*(j+1)];
+				tmp_vtx[2*j + 1] = tmp_vtx[2*(j+1) + 1];
+				tmp_vtx[2*(j+1)] = tmp[0];
+				tmp_vtx[2*(j+1) + 1] = tmp[1];
+			}
+		}
+
+	}
+
+	if (DEBUG_CLIP_VTX) {
+		ErrorF("\nAfter sort vertex number is:\n");
+		for (i = 0; i < vertex_num / 2; i++) {
+			ErrorF("(%d, %d) ", tmp_vtx[2*i], tmp_vtx[2*i + 1]);
+		}
+		ErrorF("\n");
+	}
+
+	memset(vertex, -1, 2*6);
+	*num = 0;
+
+	for (i = 0; i < vertex_num / 2; i++) {
+		if (*num > 0 && vertex[2*(*num - 1)] == tmp_vtx[2*i]
+		     && vertex[2*(*num - 1) + 1] == tmp_vtx[2*i + 1]) {
+			/*same vertex.*/
+			if (DEBUG_CLIP_VTX)
+				ErrorF("X Point:(%d, %d) discard\n",
+				       tmp_vtx[2*i], tmp_vtx[2*i + 1]);
+			continue;
+		}
+
+		(*num)++;
+		if (*num > 6) {
+			if (DEBUG_CLIP_VTX)
+				FatalError("Trapezoid clip with Rect can never have vtx"
+				           "number bigger than 6\n");
+			else {
+				ErrorF("Trapezoid clip with Rect can never have vtx"
+				       "number bigger than 6\n");
+				*num = 6;
+				break;
+			}
+		}
+
+		vertex[2*(*num - 1)] = tmp_vtx[2*i];
+		vertex[2*(*num - 1) + 1] = tmp_vtx[2*i + 1];
+		if (DEBUG_CLIP_VTX)
+			ErrorF("@ Point:(%d, %d) select, num now is %d\n",
+			       tmp_vtx[2*i], tmp_vtx[2*i + 1], *num);
+	}
+
+	/* Now we need to arrange the vtx in the polygon's counter-clockwise
+	order. We first select the left and top point as the start point and
+	sort every vtx by the slope from vtx to the start vtx. */
+	for (i = 1; i < *num; i++) {
+		tmp_vtx_slope[i] = (vertex[2*i] != vertex[0] ?
+		                    (float)(vertex[2*i + 1] - vertex[1]) / (float)(vertex[2*i] - vertex[0])
+		                    : (float)INT_MAX);
+	}
+
+	if (DEBUG_CLIP_VTX) {
+		ErrorF("\nvtx number: %d, VTX and slope:\n", *num);
+		for (i = 0; i < *num; i++) {
+			ErrorF("(%d, %d):%f ",
+			       vertex[2*i], vertex[2*i + 1],
+			       tmp_vtx_slope[i]);
+		}
+		ErrorF("\n");
+	}
+
+	/* Sort the vertex by slope. */
+	for (i = 0; i < *num - 1; i++) {
+		int j;
+		float tmp_slope;
+		for (j = 1; j < *num - i - 1; j++) {
+			if (tmp_vtx_slope[j] < tmp_vtx_slope[j + 1]) {
+				tmp_slope = tmp_vtx_slope[j];
+				tmp_vtx_slope[j] = tmp_vtx_slope[j + 1];
+				tmp_vtx_slope[j + 1] = tmp_slope;
+				tmp[0] = vertex[2*j];
+				tmp[1] = vertex[2*j + 1];
+				vertex[2*j] = vertex[2*(j+1)];
+				vertex[2*j + 1] = vertex[2*(j+1) + 1];
+				vertex[2*(j+1)] = tmp[0];
+				vertex[2*(j+1) + 1] = tmp[1];
+			}
+		}
+	}
+
+	if (DEBUG_CLIP_VTX) {
+		ErrorF("\nBefore return, vtx number: %d, VTX and slope:\n", *num);
+		for (i = 0; i < *num; i++) {
+			ErrorF("(%d, %d):%f ",
+			       vertex[2*i], vertex[2*i + 1],
+			       tmp_vtx_slope[i]);
+		}
+		ErrorF("\n");
+	}
+
+	return TRUE;
+}
+
+static void
+glamor_setup_composite_vbo_for_trapezoid(ScreenPtr screen, int n_verts)
+{
+	glamor_screen_private *glamor_priv =
+	    glamor_get_screen_private(screen);
+	glamor_gl_dispatch *dispatch;
+	int stride;
+	int vert_size;
+
+	glamor_priv->render_nr_verts = 0;
+
+	/* For GLAMOR_VERTEX_POS */
+	glamor_priv->vb_stride = 2 * sizeof(float);
+
+	/* For GLAMOR_GLAMOR_VERTEX_SOURCE */
+	glamor_priv->vb_stride += 2 * sizeof(float);
+
+	/* For GLAMOR_VERTEX_TOP_BOTTOM */
+	glamor_priv->vb_stride += 2 * sizeof(float);
+
+	/* For GLAMOR_VERTEX_LEFT_PARAM */
+	glamor_priv->vb_stride += 4 * sizeof(float);
+
+	/* For GLAMOR_VERTEX_RIGHT_PARAM */
+	glamor_priv->vb_stride += 4 * sizeof(float);
+
+	vert_size = n_verts * glamor_priv->vb_stride;
+
+	dispatch = glamor_get_dispatch(glamor_priv);
+
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_TOP_BOTTOM);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_LEFT_PARAM);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_RIGHT_PARAM);
+
+	dispatch->glBindBuffer(GL_ARRAY_BUFFER, glamor_priv->vbo);
+	if (glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP) {
+		if (glamor_priv->vbo_size < (glamor_priv->vbo_offset + vert_size)) {
+			glamor_priv->vbo_size = GLAMOR_COMPOSITE_VBO_VERT_CNT *
+				glamor_priv->vb_stride;
+			glamor_priv->vbo_offset = 0;
+			dispatch->glBufferData(GL_ARRAY_BUFFER,
+					       glamor_priv->vbo_size,
+					       NULL, GL_STREAM_DRAW);
+		}
+
+		glamor_priv->vb = dispatch->glMapBufferRange(GL_ARRAY_BUFFER,
+		                                             glamor_priv->vbo_offset,
+		                                             vert_size,
+		                                             GL_MAP_WRITE_BIT | GL_MAP_UNSYNCHRONIZED_BIT);
+
+		assert(glamor_priv->vb != NULL);
+		glamor_priv->vb -= glamor_priv->vbo_offset;
+	} else {
+		glamor_priv->vbo_offset = 0;
+	}
+
+	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, glamor_priv->ebo);
+
+	/* Set the vertex pointer. */
+	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_POS, 2, GL_FLOAT,
+	        GL_FALSE, glamor_priv->vb_stride,
+	        (void *) ((long)glamor_priv->vbo_offset));
+	dispatch->glEnableVertexAttribArray(GLAMOR_VERTEX_POS);
+	stride = 2;
+
+	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_SOURCE, 2, GL_FLOAT,
+	        GL_FALSE, glamor_priv->vb_stride,
+	        (void *) ((long)glamor_priv->vbo_offset + stride * sizeof(float)));
+	dispatch->glEnableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
+	stride += 2;
+
+	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_TOP_BOTTOM, 2, GL_FLOAT,
+	        GL_FALSE, glamor_priv->vb_stride,
+	        (void *) ((long)glamor_priv->vbo_offset + stride * sizeof(float)));
+	dispatch->glEnableVertexAttribArray(GLAMOR_VERTEX_TOP_BOTTOM);
+	stride += 2;
+
+	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_LEFT_PARAM, 4, GL_FLOAT,
+	        GL_FALSE, glamor_priv->vb_stride,
+	        (void *) ((long)glamor_priv->vbo_offset + stride * sizeof(float)));
+	dispatch->glEnableVertexAttribArray(GLAMOR_VERTEX_LEFT_PARAM);
+	stride += 4;
+
+	dispatch->glVertexAttribPointer(GLAMOR_VERTEX_RIGHT_PARAM, 4, GL_FLOAT,
+	        GL_FALSE, glamor_priv->vb_stride,
+	        (void *) ((long)glamor_priv->vbo_offset + stride * sizeof(float)));
+	dispatch->glEnableVertexAttribArray(GLAMOR_VERTEX_RIGHT_PARAM);
+
+	glamor_put_dispatch(glamor_priv);
+}
+
+static Bool
+_glamor_trapezoids_with_shader(CARD8 op,
+        PicturePtr src, PicturePtr dst,
+        PictFormatPtr mask_format, INT16 x_src, INT16 y_src,
+        int ntrap, xTrapezoid * traps)
+{
+	ScreenPtr screen = dst->pDrawable->pScreen;
+	glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
+	struct shader_key key;
+	glamor_composite_shader *shader = NULL;
+	struct blendinfo op_info;
+	PictFormatShort saved_source_format = 0;
+	PixmapPtr source_pixmap = NULL;
+	PixmapPtr dest_pixmap = NULL;
+	glamor_pixmap_private *source_pixmap_priv = NULL;
+	glamor_pixmap_private *dest_pixmap_priv = NULL;
+	glamor_pixmap_private *temp_src_priv = NULL;
+	int x_temp_src, y_temp_src;
+	int src_width, src_height;
+	int source_x_off, source_y_off;
+	GLfloat src_xscale = 1, src_yscale = 1;
+	int x_dst, y_dst;
+	int dest_x_off, dest_y_off;
+	GLfloat dst_xscale, dst_yscale;
+	BoxRec bounds;
+	PicturePtr temp_src = src;
+	glamor_gl_dispatch *dispatch = NULL;
+	int vert_stride = 3;
+	int ntriangle_per_loop;
+	int nclip_rect;
+	int mclip_rect;
+	int clip_processed;
+	int clipped_vtx[6*2];
+	RegionRec region;
+	BoxPtr box = NULL;
+	BoxPtr pbox = NULL;
+	int traps_count = 0;
+	int traps_not_completed = 0;
+	xTrapezoid * ptrap = NULL;
+	int nbox;
+	float src_matrix[9];
+	Bool ret = FALSE;
+
+	/* If a mask format wasn't provided, we get to choose, but behavior should
+	 * be as if there was no temporary mask the traps were accumulated into.
+	 */
+	if (!mask_format) {
+		if (dst->polyEdge == PolyEdgeSharp)
+			mask_format = PictureMatchFormat(screen, 1, PICT_a1);
+		else
+			mask_format = PictureMatchFormat(screen, 8, PICT_a8);
+		for (; ntrap; ntrap--, traps++)
+			glamor_trapezoids(op, src, dst, mask_format, x_src,
+			                  y_src, 1, traps);
+		return TRUE;
+	}
+
+	miTrapezoidBounds(ntrap, traps, &bounds);
+	DEBUGF("The bounds for all traps is: bounds.x1 = %d, bounds.x2 = %d, "
+	       "bounds.y1 = %d, bounds.y2 = %d\n", bounds.x1, bounds.x2,
+	       bounds.y1, bounds.y2);
+
+	/* No area need to render. */
+	if (bounds.y1 >= bounds.y2 || bounds.x1 >= bounds.x2)
+		return TRUE;
+
+	dest_pixmap = glamor_get_drawable_pixmap(dst->pDrawable);
+	dest_pixmap_priv = glamor_get_pixmap_private(dest_pixmap);
+
+	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(dest_pixmap_priv)
+	    || dest_pixmap_priv->type == GLAMOR_TEXTURE_LARGE) {
+		/* Currently. Always fallback to cpu if destination is in CPU memory.*/
+		ret = FALSE;
+		DEBUGF("dst pixmap has no FBO.\n");
+		goto TRAPEZOID_OUT;
+	}
+
+	if (src->pDrawable) {
+		source_pixmap = glamor_get_drawable_pixmap(src->pDrawable);
+		source_pixmap_priv = glamor_get_pixmap_private(source_pixmap);
+		temp_src_priv = source_pixmap_priv;
+		if (source_pixmap_priv
+		    && (source_pixmap_priv->type == GLAMOR_DRM_ONLY
+		       || source_pixmap_priv->type == GLAMOR_TEXTURE_LARGE)) {
+			ret = FALSE;
+			goto TRAPEZOID_OUT;
+		}
+	}
+
+	x_dst = bounds.x1;
+	y_dst = bounds.y1;
+
+	src_width = bounds.x2 - bounds.x1;
+	src_height = bounds.y2 - bounds.y1;
+
+	x_temp_src = x_src + bounds.x1 - (traps[0].left.p1.x >> 16);
+	y_temp_src = y_src + bounds.y1 - (traps[0].left.p1.y >> 16);
+
+	if ((!src->pDrawable &&
+	     (src->pSourcePict->type != SourcePictTypeSolidFill)) //1. The Gradient case.
+	     /* 2. Has no fbo but can upload.*/
+	     || (src->pDrawable && !GLAMOR_PIXMAP_PRIV_HAS_FBO(source_pixmap_priv)
+	         && ((src_width * src_height * 4 <
+	              source_pixmap->drawable.width * source_pixmap->drawable.height)
+	             || !glamor_check_fbo_size(glamor_priv, source_pixmap->drawable.width,
+	                     source_pixmap->drawable.height)))) {
+
+		if (!glamor_check_fbo_size(glamor_priv, src_width, src_height)) {
+			ret = FALSE;
+			goto TRAPEZOID_OUT;
+		}
+		temp_src = glamor_convert_gradient_picture(screen, src,
+		           x_src, y_src,
+		           src_width, src_height);
+		if (!temp_src) {
+			temp_src = src;
+			ret = FALSE;
+			DEBUGF("Convert gradient picture failed\n");
+			goto TRAPEZOID_OUT;
+		}
+		temp_src_priv = glamor_get_pixmap_private((PixmapPtr)temp_src->pDrawable);
+		x_temp_src = y_temp_src = 0;
+	}
+
+	x_dst += dst->pDrawable->x;
+	y_dst += dst->pDrawable->y;
+	if (temp_src->pDrawable) {
+		x_temp_src += temp_src->pDrawable->x;
+		y_temp_src += temp_src->pDrawable->y;
+	}
+
+	if (!miComputeCompositeRegion(&region,
+	        temp_src, NULL, dst,
+	        x_temp_src, y_temp_src,
+	        0, 0,
+	        x_dst, y_dst,
+	        src_width, src_height)) {
+		DEBUGF("All the regions are clipped out, do nothing\n");
+		goto TRAPEZOID_OUT;
+	}
+
+	box = REGION_RECTS(&region);
+	nbox = REGION_NUM_RECTS(&region);
+	pbox = box;
+
+	ret = glamor_composite_choose_shader(op, temp_src, NULL, dst,
+					     temp_src_priv, NULL, dest_pixmap_priv,
+					     &key, &shader, &op_info, &saved_source_format);
+	if (ret == FALSE) {
+		DEBUGF("can not set the shader program for composite\n");
+		goto TRAPEZOID_RESET_GL;
+	}
+	glamor_set_destination_pixmap_priv_nc(dest_pixmap_priv);
+	glamor_composite_set_shader_blend(dest_pixmap_priv, &key, shader, &op_info);
+	glamor_priv->has_source_coords = key.source != SHADER_SOURCE_SOLID;
+	glamor_priv->has_mask_coords = (key.mask != SHADER_MASK_NONE &&
+	        key.mask != SHADER_MASK_SOLID);
+
+	dispatch = glamor_get_dispatch(glamor_priv);
+
+	glamor_get_drawable_deltas(dst->pDrawable, dest_pixmap,
+	        &dest_x_off, &dest_y_off);
+
+	pixmap_priv_get_dest_scale(dest_pixmap_priv, &dst_xscale, &dst_yscale);
+
+	if (glamor_priv->has_source_coords) {
+		source_pixmap = glamor_get_drawable_pixmap(temp_src->pDrawable);
+		source_pixmap_priv = glamor_get_pixmap_private(source_pixmap);
+		glamor_get_drawable_deltas(temp_src->pDrawable,
+		        source_pixmap,
+		        &source_x_off, &source_y_off);
+		pixmap_priv_get_scale(source_pixmap_priv,
+		        &src_xscale, &src_yscale);
+		glamor_picture_get_matrixf(temp_src, src_matrix);
+		vert_stride += 3;
+	}
+
+	if (glamor_priv->has_mask_coords) {
+		DEBUGF("Should never have mask coords here!\n");
+		ret = FALSE;
+		goto TRAPEZOID_RESET_GL;
+	}
+
+	/* A trapezoid clip with a rectangle will at most generate a hexagon,
+	   which can be devided	into 4 triangles to render. */
+	ntriangle_per_loop = (vert_stride * nbox * ntrap * 4) > GLAMOR_COMPOSITE_VBO_VERT_CNT ?
+	        (GLAMOR_COMPOSITE_VBO_VERT_CNT / vert_stride) : nbox * ntrap * 4;
+	ntriangle_per_loop = (ntriangle_per_loop / 4) * 4;
+
+	nclip_rect = nbox;
+	while (nclip_rect) {
+		mclip_rect = (nclip_rect * ntrap * 4) > ntriangle_per_loop ?
+		             (ntriangle_per_loop / (4 * ntrap)) : nclip_rect;
+
+		if (!mclip_rect) {/* Maybe too many traps. */
+			mclip_rect = 1;
+			ptrap = traps;
+			traps_count = ntriangle_per_loop / 4;
+			traps_not_completed = ntrap - traps_count;
+		} else {
+			traps_count = ntrap;
+			ptrap = traps;
+			traps_not_completed = 0;
+		}
+
+NTRAPS_LOOP_AGAIN:
+
+		glamor_setup_composite_vbo(screen,  mclip_rect * traps_count * 4 * vert_stride);
+		clip_processed = mclip_rect;
+
+
+		while (mclip_rect--) {
+			while (traps_count--) {
+				int vtx_num;
+				int i;
+				float vertices[3*2], source_texcoords[3*2];
+
+				DEBUGF("In loop of render trapezoid, nclip_rect = %d, mclip_rect = %d, "
+				       "clip_processed = %d, traps_count = %d, traps_not_completed = %d\n",
+				       nclip_rect, mclip_rect, clip_processed, traps_count, traps_not_completed);
+
+				if (_glamor_clip_trapezoid_vertex(ptrap, pbox, clipped_vtx, &vtx_num)) {
+					for (i = 0; i < vtx_num - 2; i++) {
+						int clipped_vtx_tmp[3*2];
+
+						clipped_vtx_tmp[0] = clipped_vtx[0];
+						clipped_vtx_tmp[1] = clipped_vtx[1];
+						clipped_vtx_tmp[2] = clipped_vtx[(i+1)*2];
+						clipped_vtx_tmp[3] = clipped_vtx[(i+1)*2 + 1];
+						clipped_vtx_tmp[4] = clipped_vtx[(i+2)*2];
+						clipped_vtx_tmp[5] = clipped_vtx[(i+2)*2 + 1];
+						glamor_set_normalize_tri_vcoords(
+						    dst_xscale, dst_yscale, clipped_vtx_tmp,
+						    glamor_priv->yInverted, vertices);
+						DEBUGF("vertices of triangle: (%f X %f), (%f X %f), "
+						       "(%f X %f)\n", vertices[0], vertices[1],
+						       vertices[2], vertices[3], vertices[4], vertices[5]);
+
+
+						if (key.source != SHADER_SOURCE_SOLID) {
+							if (src->transform) {
+								glamor_set_transformed_normalize_tri_tcoords(
+								    source_pixmap_priv,
+								    src_matrix, src_xscale, src_yscale,
+								    clipped_vtx_tmp,
+								    glamor_priv->yInverted,
+								    source_texcoords);
+							} else {
+								glamor_set_normalize_tri_tcoords(
+								    src_xscale, src_yscale,
+								    clipped_vtx_tmp,
+								    glamor_priv->yInverted,
+								    source_texcoords);
+							}
+
+							DEBUGF("source_texcoords of triangle: (%f X %f), "
+							       "(%f X %f), (%f X %f)\n",
+							       source_texcoords[0], source_texcoords[1],
+							       source_texcoords[2], source_texcoords[3],
+							       source_texcoords[4], source_texcoords[5]);
+						}
+
+						glamor_emit_composite_triangle(screen, source_texcoords,
+						        NULL, vertices);
+					}
+				}
+
+				ptrap++;
+			}
+
+			if (traps_not_completed) { /* one loop of ntraps not completed */
+				mclip_rect = 1;
+				traps_count = traps_not_completed > (ntriangle_per_loop / 4) ?
+				              (ntriangle_per_loop / 4) : traps_not_completed;
+				traps_not_completed -= traps_count;
+				glamor_flush_composite_triangles(screen);
+				goto NTRAPS_LOOP_AGAIN;
+			}
+
+			pbox++;
+		}
+
+		glamor_flush_composite_triangles(screen);
+
+		nclip_rect -= clip_processed;
+	}
+
+	ret = TRUE;
+
+TRAPEZOID_RESET_GL:
+	dispatch->glBindBuffer(GL_ARRAY_BUFFER, 0);
+	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_MASK);
+	dispatch->glDisable(GL_BLEND);
+#ifndef GLAMOR_GLES2
+	dispatch->glActiveTexture(GL_TEXTURE0);
+	dispatch->glDisable(GL_TEXTURE_2D);
+	dispatch->glActiveTexture(GL_TEXTURE1);
+	dispatch->glDisable(GL_TEXTURE_2D);
+#endif
+	dispatch->glUseProgram(0);
+
+TRAPEZOID_OUT:
+	if (box) {
+		REGION_UNINIT(dst->pDrawable->pScreen, &region);
+	}
+
+	if (temp_src != src) {
+		FreePicture(temp_src, 0);
+	} else {
+		if (saved_source_format) {
+			src->format = saved_source_format;
+		}
+	}
+
+	if (dispatch) {
+		glamor_put_dispatch(glamor_priv);
+	}
+
+	return ret;
+}
+
+void
+glamor_init_trapezoid_shader(ScreenPtr screen)
+{
+	glamor_screen_private *glamor_priv;
+	glamor_gl_dispatch *dispatch;
+	GLint fs_prog, vs_prog;
+
+	const char *trapezoid_vs =
+	    GLAMOR_DEFAULT_PRECISION
+	    "attribute vec4 v_position;\n"
+	    "attribute vec2 v_texcoord;\n"
+	    /* v_top_bottom, v_left_param and v_right_param contain the
+	       constant value for all the vertex of one rect. Using uniform
+	       is more suitable but we need to reset the uniform variables
+	       for every rect rendering and can not use the vbo, which causes
+	       performance loss. So we set these attributes to same value
+	       for every vertex of one rect and so it is also a constant in FS */
+	    "attribute vec2 v_top_bottom;\n"
+	    "attribute vec4 v_left_param;\n"
+	    "attribute vec4 v_right_param;\n"
+	    "\n"
+	    "varying vec2 source_texture;\n"
+	    "varying float trap_top;\n"
+	    "varying float trap_bottom;\n"
+	    "varying float trap_left_x;\n"
+	    "varying float trap_left_y;\n"
+	    "varying float trap_left_slope;\n"
+	    "varying float trap_left_vertical_f;\n"
+	    "varying float trap_right_x;\n"
+	    "varying float trap_right_y;\n"
+	    "varying float trap_right_slope;\n"
+	    "varying float trap_right_vertical_f;\n"
+	    "\n"
+	    "void main()\n"
+	    "{\n"
+	    "    gl_Position = v_position;\n"
+	    "    source_texture = v_texcoord.xy;\n"
+	    "    trap_top = v_top_bottom.x;\n"
+	    "    trap_bottom = v_top_bottom.y;\n"
+	    "    \n"
+	    "    trap_left_x = v_left_param.x;\n"
+	    "    trap_left_y = v_left_param.y;\n"
+	    "    trap_left_slope = v_left_param.z;\n"
+	    "    trap_left_vertical_f = v_left_param.w;\n"
+	    "    \n"
+	    "    trap_right_x = v_right_param.x;\n"
+	    "    trap_right_y = v_right_param.y;\n"
+	    "    trap_right_slope = v_right_param.z;\n"
+	    "    trap_right_vertical_f = v_right_param.w;\n"
+	    "}\n";
+
+	/*
+	 * Because some GL fill function do not support the MultSample
+	 * anti-alias, we need to do the MSAA here. This manner like
+	 * pixman, will caculate the value of area in trapezoid dividing
+	 * the totol area for each pixel, as follow:
+	     |
+	 ----+------------------------------------------------------>
+	     |
+	     |              -------------
+	     |             /             \
+	     |            /               \
+	     |           /                 \
+	     |          /              +----------------+
+	     |         /               |.....\          |
+	     |        /                |......\         |
+	     |       /                 |.......\        |
+	     |      /                  |........\       |
+	     |     /-------------------+---------\      |
+	     |                         |                |
+	     |                         |                |
+	     |                         +----------------+
+	     |
+	    \|/
+
+	 */
+	const char *trapezoid_fs =
+	    GLAMOR_DEFAULT_PRECISION
+	    "varying vec2 source_texture;  \n"
+	    "varying float trap_top;  \n"
+	    "varying float trap_bottom;  \n"
+	    "varying float trap_left_x;  \n"
+	    "varying float trap_left_y;  \n"
+	    "varying float trap_left_slope;  \n"
+	    "varying float trap_left_vertical_f;  \n"
+	    "varying float trap_right_x;  \n"
+	    "varying float trap_right_y;  \n"
+	    "varying float trap_right_slope;  \n"
+	    "varying float trap_right_vertical_f;  \n"
+	    "float x_per_pix = 1.0;"
+	    "float y_per_pix = 1.0;"
+	    "bool trap_left_vertical = (abs(trap_left_vertical_f - 1.0) <= 0.0001);\n"
+	    "bool trap_right_vertical = (abs(trap_right_vertical_f - 1.0) <= 0.0001);\n"
+	    "\n"
+	    "float get_alpha_val() \n"
+	    "{  \n"
+	    "    float x_up_cut_left;  \n"
+	    "    float x_bottom_cut_left;  \n"
+	    "    float x_up_cut_right;  \n"
+	    "    float x_bottom_cut_right;  \n"
+	    "    \n"
+	    "    if(trap_left_vertical == true) {  \n"
+	    "        x_up_cut_left = trap_left_x;  \n"
+	    "        x_bottom_cut_left = trap_left_x;  \n"
+	    "    } else {  \n"
+	    "        x_up_cut_left = trap_left_x  \n"
+	    "            + (source_texture.y - y_per_pix/2.0 - trap_left_y)  \n"
+	    "              / trap_left_slope;  \n"
+	    "        x_bottom_cut_left = trap_left_x  \n"
+	    "            + (source_texture.y + y_per_pix/2.0 - trap_left_y)  \n"
+	    "              / trap_left_slope;  \n"
+	    "    }  \n"
+	    "    \n"
+	    "    if(trap_right_vertical == true) {  \n"
+	    "        x_up_cut_right = trap_right_x;  \n"
+	    "        x_bottom_cut_right = trap_right_x;  \n"
+	    "    } else {  \n"
+	    "        x_up_cut_right = trap_right_x  \n"
+	    "            + (source_texture.y - y_per_pix/2.0 - trap_right_y)  \n"
+	    "              / trap_right_slope;  \n"
+	    "        x_bottom_cut_right = trap_right_x  \n"
+	    "            + (source_texture.y + y_per_pix/2.0 - trap_right_y)  \n"
+	    "              / trap_right_slope;  \n"
+	    "    }  \n"
+	    "    \n"
+	    "    if((x_up_cut_left <= source_texture.x - x_per_pix/2.0) &&  \n"
+	    "          (x_bottom_cut_left <= source_texture.x - x_per_pix/2.0) &&  \n"
+	    "          (x_up_cut_right >= source_texture.x + x_per_pix/2.0) &&  \n"
+	    "          (x_bottom_cut_right >= source_texture.x + x_per_pix/2.0) &&  \n"
+	    "          (trap_top <= source_texture.y - y_per_pix/2.0) &&  \n"
+	    "          (trap_bottom >= source_texture.y + y_per_pix/2.0)) {  \n"
+	    //       The complete inside case.
+	    "        return 1.0;  \n"
+	    "    } else if((trap_top > source_texture.y + y_per_pix/2.0) ||  \n"
+	    "                (trap_bottom < source_texture.y - y_per_pix/2.0)) {  \n"
+	    //       The complete outside. Above the top or Below the bottom.
+	    "        return 0.0;  \n"
+	    "    } else {  \n"
+	    "        if((x_up_cut_right < source_texture.x - x_per_pix/2.0 &&  \n"
+	    "                   x_bottom_cut_right < source_texture.x - x_per_pix/2.0)  \n"
+	    "            || (x_up_cut_left > source_texture.x + x_per_pix/2.0  &&  \n"
+	    "                   x_bottom_cut_left > source_texture.x + x_per_pix/2.0)) {  \n"
+	    //            The complete outside. At Left or Right of the trapezoide.
+	    "             return 0.0;  \n"
+	    "        }  \n"
+	    "    }  \n"
+	    //   Get here, the pix is partly inside the trapezoid.
+	    "    {  \n"
+	    "        float percent = 0.0;  \n"
+	    "        float up = (source_texture.y - y_per_pix/2.0) >= trap_top ?  \n"
+	    "                       (source_texture.y - y_per_pix/2.0) : trap_top;  \n"
+	    "        float bottom = (source_texture.y + y_per_pix/2.0) <= trap_bottom ?  \n"
+	    "                       (source_texture.y + y_per_pix/2.0) : trap_bottom;  \n"
+	    "        float left = source_texture.x - x_per_pix/2.0;  \n"
+	    "        float right = source_texture.x + x_per_pix/2.0;  \n"
+	    "        \n"
+	    "        percent = (bottom - up) / y_per_pix;  \n"
+	    "        \n"
+	    "	     if(trap_left_vertical == true) {  \n"
+	    "            if(trap_left_x > source_texture.x - x_per_pix/2.0 &&  \n"
+	    "                     trap_left_x < source_texture.x + x_per_pix/2.0)  \n"
+	    "                left = trap_left_x;  \n"
+	    "        }  \n"
+	    "	     if(trap_right_vertical == true) {  \n"
+	    "            if(trap_right_x > source_texture.x - x_per_pix/2.0 &&  \n"
+	    "                     trap_right_x < source_texture.x + x_per_pix/2.0)  \n"
+	    "                right = trap_right_x;  \n"
+	    "        }  \n"
+	    "        if((up >= bottom) || (left >= right))  \n"
+	    "            return 0.0;  \n"
+	    "        \n"
+	    "        percent = percent * ((right - left)/x_per_pix);  \n"
+	    "        if(trap_left_vertical == true && trap_right_vertical == true)  \n"
+	    "            return percent;  \n"
+	    "        \n"
+	    "        if(trap_left_vertical != true) {  \n"
+	    "            float area;  \n"
+	    //           the slope should never be 0.0 here
+	    "            float up_x = trap_left_x + (up - trap_left_y)/trap_left_slope;  \n"
+	    "            float bottom_x = trap_left_x + (bottom - trap_left_y)/trap_left_slope;  \n"
+	    "            if(trap_left_slope < 0.0 && up_x > left) {  \n"
+	    /*   case 1
+	         |
+	     ----+------------------------------------->
+	         |                 /
+	         |                /
+	         |           +---/--------+
+	         |           |  /.........|
+	         |           | /..........|
+	         |           |/...........|
+	         |           /............|
+	         |          /|............|
+	         |           +------------+
+	         |
+	        \|/
+	    */
+	    "                float left_y = trap_left_y + trap_left_slope*(left - trap_left_x);  \n"
+	    "                if((up_x > left) && (left_y > up)) {  \n"
+	    "                    area = 0.5 * (up_x - left) * (left_y - up);  \n"
+	    "                    if(up_x > right) {  \n"
+	    "                        float right_y = trap_left_y  \n"
+	    "                                  + trap_left_slope*(right - trap_left_x);  \n"
+	    "                        area = area - 0.5 * (up_x - right) * (right_y - up);  \n"
+	    "                    }  \n"
+	    "                    if(left_y > bottom) {  \n"
+	    "                        area = area - 0.5 * (bottom_x - left) * (left_y - bottom);  \n"
+	    "                    }  \n"
+	    "                } else {  \n"
+	    "                    area = 0.0;  \n"
+	    "                }  \n"
+	    "                percent = percent * (1.0 - (area/((right-left)*(bottom-up))));  \n"
+	    "            } else if(trap_left_slope > 0.0 && bottom_x > left) {  \n"
+	    /*   case 2
+	         |
+	     ----+------------------------------------->
+	         |          \
+	         |           \
+	         |           +\-----------+
+	         |           | \..........|
+	         |           |  \.........|
+	         |           |   \........|
+	         |           |    \.......|
+	         |           |     \......|
+	         |           +------\-----+
+	         |                   \
+	         |                    \
+	        \|/
+	    */
+	    "                float right_y = trap_left_y + trap_left_slope*(right - trap_left_x);  \n"
+	    "                if((up_x < right) && (right_y > up)) {  \n"
+	    "                    area = 0.5 * (right - up_x) * (right_y - up);  \n"
+	    "                    if(up_x < left) {  \n"
+	    "                        float left_y = trap_left_y  \n"
+	    "                                  + trap_left_slope*(left - trap_left_x);  \n"
+	    "                        area = area - 0.5 * (left - up_x) * (left_y - up);  \n"
+	    "                    }  \n"
+	    "                    if(right_y > bottom) {  \n"
+	    "                        area = area - 0.5 * (right - bottom_x) * (right_y - bottom);  \n"
+	    "                    }  \n"
+	    "                } else {  \n"
+	    "                    area = 0.0;  \n"
+	    "                }  \n"
+	    "                percent = percent * (area/((right-left)*(bottom-up)));  \n"
+	    "            }  \n"
+	    "        }  \n"
+	    "        \n"
+	    "        if(trap_right_vertical != true) {  \n"
+	    "            float area;  \n"
+	    //           the slope should never be 0.0 here
+	    "            float up_x = trap_right_x + (up - trap_right_y)/trap_right_slope;  \n"
+	    "            float bottom_x = trap_right_x + (bottom - trap_right_y)/trap_right_slope;  \n"
+	    "            if(trap_right_slope < 0.0 && bottom_x < right) {  \n"
+	    /*   case 3
+	         |
+	     ----+------------------------------------->
+	         |                     /
+	         |           +--------/---+
+	         |           |......./    |
+	         |           |....../     |
+	         |           |...../      |
+	         |           |..../       |
+	         |           |.../        |
+	         |           +--/---------+
+	         |             /
+	         |
+	        \|/
+	    */
+	    "                float left_y = trap_right_y + trap_right_slope*(left - trap_right_x);  \n"
+	    "                if((up_x > left) && (left_y > up)) {  \n"
+	    "                    area = 0.5 * (up_x - left) * (left_y - up);  \n"
+	    "                    if(up_x > right) {  \n"
+	    "                        float right_y = trap_right_y  \n"
+	    "                                  + trap_right_slope*(right - trap_right_x);  \n"
+	    "                        area = area - 0.5 * (up_x - right) * (right_y - up);  \n"
+	    "                    }  \n"
+	    "                    if(left_y > bottom) {  \n"
+	    "                        area = area - 0.5 * (bottom_x - left) * (left_y - bottom);  \n"
+	    "                    }  \n"
+	    "                } else {  \n"
+	    "                    area = 0.0;  \n"
+	    "                }  \n"
+	    "                percent = percent * (area/((right-left)*(bottom-up)));  \n"
+	    "            } else if(trap_right_slope > 0.0 && up_x < right) {  \n"
+	    /*   case 4
+	         |
+	     ----+------------------------------------->
+	         |                   \
+	         |           +--------\---+
+	         |           |.........\  |
+	         |           |..........\ |
+	         |           |...........\|
+	         |           |............\
+	         |           |............|\
+	         |           +------------+ \
+	         |                           \
+	         |
+	        \|/
+	    */
+	    "                float right_y = trap_right_y + trap_right_slope*(right - trap_right_x);  \n"
+	    "                if((up_x < right) && (right_y > up)) {  \n"
+	    "                    area = 0.5 * (right - up_x) * (right_y - up);  \n"
+	    "                    if(up_x < left) {  \n"
+	    "                        float left_y = trap_right_y  \n"
+	    "                                  + trap_right_slope*(left - trap_right_x);  \n"
+	    "                        area = area - 0.5 * (left - up_x) * (left_y - up);  \n"
+	    "                    }  \n"
+	    "                    if(right_y > bottom) {  \n"
+	    "                        area = area - 0.5 * (right - bottom_x) * (right_y - bottom);  \n"
+	    "                    }  \n"
+	    "                } else {  \n"
+	    "                    area = 0.0;  \n"
+	    "                }  \n"
+	    "                percent = percent * (1.0 - (area/((right-left)*(bottom-up))));  \n"
+	    "            }  \n"
+	    "        }  \n"
+	    "        \n"
+	    "        return percent;  \n"
+	    "    }  \n"
+	    "}  \n"
+	    "\n"
+	    "void main()  \n"
+	    "{  \n"
+	    "    float alpha_val = get_alpha_val();  \n"
+	    "    gl_FragColor = vec4(0.0, 0.0, 0.0, alpha_val);  \n"
+	    "}\n";
+
+	glamor_priv = glamor_get_screen_private(screen);
+	dispatch = glamor_get_dispatch(glamor_priv);
+
+	glamor_priv->trapezoid_prog = dispatch->glCreateProgram();
+
+	vs_prog = glamor_compile_glsl_prog(dispatch,
+	                  GL_VERTEX_SHADER, trapezoid_vs);
+	fs_prog = glamor_compile_glsl_prog(dispatch,
+	                  GL_FRAGMENT_SHADER, trapezoid_fs);
+
+	dispatch->glAttachShader(glamor_priv->trapezoid_prog, vs_prog);
+	dispatch->glAttachShader(glamor_priv->trapezoid_prog, fs_prog);
+
+	dispatch->glBindAttribLocation(glamor_priv->trapezoid_prog,
+	        GLAMOR_VERTEX_POS, "v_positionsition");
+	dispatch->glBindAttribLocation(glamor_priv->trapezoid_prog,
+	        GLAMOR_VERTEX_SOURCE, "v_texcoord");
+	dispatch->glBindAttribLocation(glamor_priv->trapezoid_prog,
+	        GLAMOR_VERTEX_TOP_BOTTOM, "v_top_bottom");
+	dispatch->glBindAttribLocation(glamor_priv->trapezoid_prog,
+	        GLAMOR_VERTEX_LEFT_PARAM, "v_left_param");
+	dispatch->glBindAttribLocation(glamor_priv->trapezoid_prog,
+	        GLAMOR_VERTEX_RIGHT_PARAM, "v_right_param");
+
+	glamor_link_glsl_prog(dispatch, glamor_priv->trapezoid_prog);
+
+	dispatch->glUseProgram(0);
+
+	glamor_put_dispatch(glamor_priv);
+}
+
+void
+glamor_fini_trapezoid_shader(ScreenPtr screen)
+{
+	glamor_screen_private *glamor_priv;
+	glamor_gl_dispatch *dispatch;
+
+	glamor_priv = glamor_get_screen_private(screen);
+	dispatch = glamor_get_dispatch(glamor_priv);
+	dispatch->glDeleteProgram(glamor_priv->trapezoid_prog);
+	glamor_put_dispatch(glamor_priv);
+}
+
+static Bool
+_glamor_generate_trapezoid_with_shader(ScreenPtr screen, PicturePtr picture,
+        xTrapezoid * traps, int ntrap, BoxRec *bounds)
+{
+	glamor_screen_private *glamor_priv;
+	glamor_gl_dispatch *dispatch;
+	glamor_pixmap_private *pixmap_priv;
+	PixmapPtr pixmap = NULL;
+	GLint trapezoid_prog;
+	float width, height;
+	GLfloat xscale, yscale;
+	float left_slope, right_slope;
+	xTrapezoid *ptrap;
+	BoxRec one_trap_bound;
+	int nrect_max;
+	int i, j;
+	float *vertices;
+	float params[4];
+
+	glamor_priv = glamor_get_screen_private(screen);
+	trapezoid_prog = glamor_priv->trapezoid_prog;
+
+	pixmap = glamor_get_drawable_pixmap(picture->pDrawable);
+	pixmap_priv = glamor_get_pixmap_private(pixmap);
+
+	if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv)
+	     || pixmap_priv->type == GLAMOR_TEXTURE_LARGE) { /* should always have here. */
+		DEBUGF("GLAMOR_PIXMAP_PRIV_HAS_FBO check failed, fallback\n");
+		return FALSE;
+	}
+
+	/* First, clear all to zero */
+	if (!glamor_solid(pixmap, 0, 0, pixmap_priv->base.pixmap->drawable.width,
+	                  pixmap_priv->base.pixmap->drawable.height,
+	                  GXclear, 0xFFFFFFFF, 0)) {
+		DEBUGF("glamor_solid failed, fallback\n");
+		return FALSE;
+	}
+
+	dispatch = glamor_get_dispatch(glamor_priv);
+
+	glamor_set_destination_pixmap_priv_nc(pixmap_priv);
+
+	pixmap_priv_get_dest_scale(pixmap_priv, (&xscale), (&yscale));
+
+	width = (float)(bounds->x2 - bounds->x1);
+	height = (float)(bounds->y2 - bounds->y1);
+
+	dispatch->glBindBuffer(GL_ARRAY_BUFFER, 0);
+	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+
+	/* Now draw the Trapezoid mask. */
+	dispatch->glUseProgram(trapezoid_prog);
+
+	dispatch->glEnable(GL_BLEND);
+	dispatch->glBlendFunc(GL_ONE, GL_ONE);
+
+	nrect_max = GLAMOR_COMPOSITE_VBO_VERT_CNT / (4 * GLAMOR_VERTEX_RIGHT_PARAM);
+
+	for (i = 0; i < ntrap;) {
+		int mrect;
+		int stride;
+
+		mrect = (ntrap - i) > nrect_max ? nrect_max : (ntrap - i);
+		glamor_setup_composite_vbo_for_trapezoid(screen, 4 * mrect);
+		stride = glamor_priv->vb_stride / sizeof(float);
+
+		for (j = 0; j < mrect; j++) {
+			ptrap = traps + i + j;
+
+			DEBUGF("--- The parameter of xTrapezoid is:\ntop: %d  0x%x\tbottom: %d  0x%x\n"
+			       "left:  p1 (%d   0x%x, %d   0x%x)\tp2 (%d   0x%x, %d   0x%x)\n"
+			       "right: p1 (%d   0x%x, %d   0x%x)\tp2 (%d   0x%x, %d   0x%x)\n",
+			       xFixedToInt(ptrap->top), ptrap->top,
+			       xFixedToInt(ptrap->bottom), ptrap->bottom,
+			       xFixedToInt(ptrap->left.p1.x), ptrap->left.p1.x,
+			       xFixedToInt(ptrap->left.p1.y), ptrap->left.p1.y,
+			       xFixedToInt(ptrap->left.p2.x), ptrap->left.p2.x,
+			       xFixedToInt(ptrap->left.p2.y), ptrap->left.p2.y,
+			       xFixedToInt(ptrap->right.p1.x), ptrap->right.p1.x,
+			       xFixedToInt(ptrap->right.p1.y), ptrap->right.p1.y,
+			       xFixedToInt(ptrap->right.p2.x), ptrap->right.p2.x,
+			       xFixedToInt(ptrap->right.p2.y), ptrap->right.p2.y);
+
+			miTrapezoidBounds(1, ptrap, &one_trap_bound);
+
+			vertices = (float*)(glamor_priv->vb + glamor_priv->vbo_offset) + 2;
+			glamor_set_tcoords_ext((pixmap_priv->base.pixmap->drawable.width),
+			        (pixmap_priv->base.pixmap->drawable.height),
+			        (one_trap_bound.x1),
+			        (one_trap_bound.y1),
+			        (one_trap_bound.x2),
+			        (one_trap_bound.y2),
+			        glamor_priv->yInverted, vertices, stride);
+			DEBUGF("tex_vertices --> leftup : %f X %f, rightup: %f X %f,"
+			       "rightbottom: %f X %f, leftbottom : %f X %f\n",
+			       vertices[0], vertices[1],
+			       vertices[1*stride], vertices[1*stride + 1],
+			       vertices[2*stride], vertices[2*stride + 1],
+			       vertices[3*stride], vertices[3*stride + 1]);
+
+			/* Need to rebase. */
+			one_trap_bound.x1 -= bounds->x1;
+			one_trap_bound.x2 -= bounds->x1;
+			one_trap_bound.y1 -= bounds->y1;
+			one_trap_bound.y2 -= bounds->y1;
+
+			vertices -= 2;
+
+			glamor_set_normalize_vcoords_ext(pixmap_priv, xscale, yscale,
+			        one_trap_bound.x1, one_trap_bound.y1,
+			        one_trap_bound.x2, one_trap_bound.y2,
+			        glamor_priv->yInverted, vertices, stride);
+			DEBUGF("vertices --> leftup : %f X %f, rightup: %f X %f,"
+			       "rightbottom: %f X %f, leftbottom : %f X %f\n",
+			       vertices[0], vertices[1],
+			       vertices[1*stride], vertices[1*stride + 1],
+			       vertices[2*stride], vertices[2*stride + 1],
+			       vertices[3*stride], vertices[3*stride + 1]);
+			vertices += 4;
+
+			/* Set the top and bottom. */
+			params[0] = ((float)ptrap->top) / 65536;
+			params[1] = ((float)ptrap->bottom) / 65536;
+			glamor_set_const_ext(params, 2, vertices, 4, stride);
+			vertices += 2;
+
+			/* Set the left params. */
+			params[0] = ((float)ptrap->left.p1.x) / 65536;
+			params[1] = ((float)ptrap->left.p1.y) / 65536;
+
+			if (ptrap->left.p1.x == ptrap->left.p2.x) {
+				left_slope = 0.0;
+				params[3] = 1.0;
+			} else {
+				left_slope = ((float)(ptrap->left.p1.y - ptrap->left.p2.y))
+				             / ((float)(ptrap->left.p1.x - ptrap->left.p2.x));
+				params[3] = 0.0;
+			}
+			params[2] = left_slope;
+			glamor_set_const_ext(params, 4, vertices, 4, stride);
+			vertices += 4;
+
+			/* Set the left params. */
+			params[0] = ((float)ptrap->right.p1.x) / 65536;
+			params[1] = ((float)ptrap->right.p1.y) / 65536;
+
+			if (ptrap->right.p1.x == ptrap->right.p2.x) {
+				right_slope = 0.0;
+				params[3] = 1.0;
+			} else {
+				right_slope = ((float)(ptrap->right.p1.y - ptrap->right.p2.y))
+				              / ((float)(ptrap->right.p1.x - ptrap->right.p2.x));
+				params[3] = 0.0;
+			}
+			params[2] = right_slope;
+			glamor_set_const_ext(params, 4, vertices, 4, stride);
+
+			DEBUGF("trap_top = %f, trap_bottom = %f, "
+			       "trap_left_x = %f, trap_left_y = %f, left_slope = %f, "
+			       "trap_right_x = %f, trap_right_y = %f, right_slope = %f\n",
+			       ((float)ptrap->top) / 65536, ((float)ptrap->bottom) / 65536,
+			       ((float)ptrap->left.p1.x) / 65536, ((float)ptrap->left.p1.y) / 65536,
+			       left_slope,
+			       ((float)ptrap->right.p1.x) / 65536, ((float)ptrap->right.p1.y) / 65536,
+			       right_slope);
+
+			glamor_priv->render_nr_verts += 4;
+			glamor_priv->vbo_offset += glamor_priv->vb_stride * 4;
+		}
+
+		i += mrect;
+
+		/* Now rendering. */
+		if (!glamor_priv->render_nr_verts)
+			continue;
+
+		if (glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP)
+			dispatch->glUnmapBuffer(GL_ARRAY_BUFFER);
+		else {
+			dispatch->glBindBuffer(GL_ARRAY_BUFFER, glamor_priv->vbo);
+			dispatch->glBufferData(GL_ARRAY_BUFFER,
+			        glamor_priv->vbo_offset,
+			        glamor_priv->vb, GL_DYNAMIC_DRAW);
+		}
+
+		dispatch->glDrawElements(GL_TRIANGLES, (glamor_priv->render_nr_verts * 3) / 2,
+		        GL_UNSIGNED_SHORT, NULL);
+	}
+
+	dispatch->glBindBuffer(GL_ARRAY_BUFFER, 0);
+	dispatch->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+	dispatch->glBlendFunc(GL_ONE, GL_ZERO);
+	dispatch->glDisable(GL_BLEND);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_TOP_BOTTOM);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_LEFT_PARAM);
+	dispatch->glDisableVertexAttribArray(GLAMOR_VERTEX_RIGHT_PARAM);
+	dispatch->glUseProgram(0);
+	glamor_put_dispatch(glamor_priv);
+	return TRUE;
+}
+
+#endif                           /*GLAMOR_TRAPEZOID_SHADER */
+
+/**
+ * Creates an appropriate picture for temp mask use.
+ */
+static PicturePtr
+glamor_create_mask_picture(ScreenPtr screen,
+        PicturePtr dst,
+        PictFormatPtr pict_format,
+        CARD16 width, CARD16 height, int gpu)
+{
+	PixmapPtr pixmap;
+	PicturePtr picture;
+	int error;
+
+	if (!pict_format) {
+		if (dst->polyEdge == PolyEdgeSharp)
+			pict_format =
+			    PictureMatchFormat(screen, 1, PICT_a1);
+		else
+			pict_format =
+			    PictureMatchFormat(screen, 8, PICT_a8);
+		if (!pict_format)
+			return 0;
+	}
+
+	if (gpu) {
+		pixmap = glamor_create_pixmap(screen, width, height,
+		         pict_format->depth, 0);
+	} else {
+		pixmap = glamor_create_pixmap(screen, 0, 0,
+		         pict_format->depth,
+		         GLAMOR_CREATE_PIXMAP_CPU);
+	}
+
+	if (!pixmap)
+		return 0;
+	picture = CreatePicture(0, &pixmap->drawable, pict_format,
+	                        0, 0, serverClient, &error);
+	glamor_destroy_pixmap(pixmap);
+	return picture;
+}
+
+/**
+ * glamor_trapezoids will first try to create a trapezoid mask using shader,
+ * if failed, miTrapezoids will generate trapezoid mask accumulating in
+ * system memory.
+ */
+static Bool
+_glamor_trapezoids(CARD8 op,
+                   PicturePtr src, PicturePtr dst,
+                   PictFormatPtr mask_format, INT16 x_src, INT16 y_src,
+                   int ntrap, xTrapezoid * traps, Bool fallback)
+{
+	ScreenPtr screen = dst->pDrawable->pScreen;
+	BoxRec bounds;
+	PicturePtr picture;
+	INT16 x_dst, y_dst;
+	INT16 x_rel, y_rel;
+	int width, height, stride;
+	PixmapPtr pixmap;
+	pixman_image_t *image = NULL;
+	int ret = 0;
+
+	/* If a mask format wasn't provided, we get to choose, but behavior should
+	 * be as if there was no temporary mask the traps were accumulated into.
+	 */
+	if (!mask_format) {
+		if (dst->polyEdge == PolyEdgeSharp)
+			mask_format =
+			    PictureMatchFormat(screen, 1, PICT_a1);
+		else
+			mask_format =
+			    PictureMatchFormat(screen, 8, PICT_a8);
+		for (; ntrap; ntrap--, traps++)
+			glamor_trapezoids(op, src, dst, mask_format, x_src,
+			                  y_src, 1, traps);
+		return TRUE;
+	}
+
+	miTrapezoidBounds(ntrap, traps, &bounds);
+	DEBUGF("The bounds for all traps is: bounds.x1 = %d, bounds.x2 = %d, "
+	       "bounds.y1 = %d, bounds.y2 = %d\n", bounds.x1, bounds.x2,
+	       bounds.y1, bounds.y2);
+
+	if (bounds.y1 >= bounds.y2 || bounds.x1 >= bounds.x2)
+		return TRUE;
+
+	x_dst = traps[0].left.p1.x >> 16;
+	y_dst = traps[0].left.p1.y >> 16;
+
+	width = bounds.x2 - bounds.x1;
+	height = bounds.y2 - bounds.y1;
+	stride = PixmapBytePad(width, mask_format->depth);
+
+#ifdef GLAMOR_TRAPEZOID_SHADER
+	/* We seperate the render to two paths.
+	   Some GL implemetation do not implement the Anti-Alias for triangles
+	   and polygen's filling. So when the edge is not vertical or horizontal,
+	   sawtooth will be obvious. The trapezoid is widely used to render wide
+	   lines and circles. In these case, the line or circle will be divided
+	   into a large number of small trapezoids to approximate it, so the sawtooth
+	   at the edge will cause the result not be acceptable.
+	   When the depth of the mask is 1, there is no Anti-Alias needed, so we
+	   use the clip logic to generate the result directly(fast path).
+	   When the depth is not 1, AA is needed and we use a shader to generate
+	   a temp mask pixmap.
+	 */
+	if(mask_format->depth == 1) {
+		ret = _glamor_trapezoids_with_shader(op, src, dst, mask_format,
+		                                     x_src, y_src, ntrap, traps);
+		if(ret)
+			return TRUE;
+	} else {
+		/*  The precise mode is that we sample the trapezoid on the centre points of
+		    an (2*n+1)x(2*n-1) subpixel grid. It is computationally expensive in shader
+		    and we use inside area ratio to replace it if the polymode == Imprecise. */
+		if(dst->polyMode == PolyModeImprecise) {
+			picture = glamor_create_mask_picture(screen, dst, mask_format,
+			          width, height, 1);
+			if (!picture)
+				return TRUE;
+
+			ret = _glamor_generate_trapezoid_with_shader(screen, picture, traps, ntrap, &bounds);
+
+			if (!ret)
+				FreePicture(picture, 0);
+		}
+	}
+#endif
+
+	if (!ret) {
+		DEBUGF("Fallback to sw rasterize of trapezoid\n");
+
+		picture = glamor_create_mask_picture(screen, dst, mask_format,
+		          width, height, 0);
+		if (!picture)
+			return TRUE;
+
+		image = pixman_image_create_bits(picture->format,
+		        width, height, NULL, stride);
+		if (!image) {
+			FreePicture(picture, 0);
+			return TRUE;
+		}
+
+		for (; ntrap; ntrap--, traps++)
+			pixman_rasterize_trapezoid(image,
+			        (pixman_trapezoid_t *) traps,
+			        -bounds.x1, -bounds.y1);
+
+		pixmap = glamor_get_drawable_pixmap(picture->pDrawable);
+
+		screen->ModifyPixmapHeader(pixmap, width, height,
+		        mask_format->depth,
+		        BitsPerPixel(mask_format->depth),
+		        PixmapBytePad(width,
+		                      mask_format->depth),
+		        pixman_image_get_data(image));
+	}
+
+	x_rel = bounds.x1 + x_src - x_dst;
+	y_rel = bounds.y1 + y_src - y_dst;
+	DEBUGF("x_src = %d, y_src = %d, x_dst = %d, y_dst = %d, "
+	       "x_rel = %d, y_rel = %d\n", x_src, y_src, x_dst,
+	       y_dst, x_rel, y_rel);
+
+	CompositePicture(op, src, picture, dst,
+	                 x_rel, y_rel,
+	                 0, 0,
+	                 bounds.x1, bounds.y1,
+	                 bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
+
+	if (image)
+		pixman_image_unref(image);
+
+	FreePicture(picture, 0);
+	return TRUE;
+}
+
+void
+glamor_trapezoids(CARD8 op,
+                  PicturePtr src, PicturePtr dst,
+                  PictFormatPtr mask_format, INT16 x_src, INT16 y_src,
+                  int ntrap, xTrapezoid * traps)
+{
+	DEBUGF("x_src = %d, y_src = %d, ntrap = %d\n", x_src, y_src, ntrap);
+
+	_glamor_trapezoids(op, src, dst, mask_format, x_src,
+	                   y_src, ntrap, traps, TRUE);
+}
+
+Bool
+glamor_trapezoids_nf(CARD8 op,
+        PicturePtr src, PicturePtr dst,
+        PictFormatPtr mask_format, INT16 x_src, INT16 y_src,
+        int ntrap, xTrapezoid * traps)
+{
+	DEBUGF("x_src = %d, y_src = %d, ntrap = %d\n", x_src, y_src, ntrap);
+
+	return _glamor_trapezoids(op, src, dst, mask_format, x_src,
+	        y_src, ntrap, traps, FALSE);
+}
+
+#endif				/* RENDER */
+
diff --git a/glamor_utils.h b/glamor_utils.h
index 9d32e6e..6eef722 100644
--- a/glamor_utils.h
+++ b/glamor_utils.h
@@ -39,22 +39,56 @@
 #define t_from_x_coord_y(_yscale_, _y_)          (1.0 - (_y_) * (_yscale_))
 #define t_from_x_coord_y_inverted(_yscale_, _y_) ((_y_) * (_yscale_))
 
+#define pixmap_priv_get_dest_scale(_pixmap_priv_, _pxscale_, _pyscale_)\
+  do {                                                                 \
+    int w,h;                                                           \
+    PIXMAP_PRIV_GET_ACTUAL_SIZE(_pixmap_priv_, w, h);                  \
+    *(_pxscale_) = 1.0 / w;                                            \
+    *(_pyscale_) = 1.0 / h;                                            \
+   } while(0)
+
 #define pixmap_priv_get_scale(_pixmap_priv_, _pxscale_, _pyscale_)	\
    do {									\
-    *(_pxscale_) = 1.0 / (_pixmap_priv_)->fbo->width;			\
-    *(_pyscale_) = 1.0 / (_pixmap_priv_)->fbo->height;			\
+    *(_pxscale_) = 1.0 / (_pixmap_priv_)->base.fbo->width;			\
+    *(_pyscale_) = 1.0 / (_pixmap_priv_)->base.fbo->height;			\
+  } while(0)
+
+#define GLAMOR_PIXMAP_FBO_NOT_EAXCT_SIZE(priv)			\
+   (priv->base.fbo->width != priv->base.pixmap->drawable.width 	\
+      || priv->base.fbo->height != priv->base.pixmap->drawable.height)	\
+
+#define PIXMAP_PRIV_GET_ACTUAL_SIZE(priv, w, h)			\
+  do {								\
+	if (unlikely(priv->type == GLAMOR_TEXTURE_LARGE)) {		\
+		w = priv->large.box.x2 - priv->large.box.x1;	\
+		h = priv->large.box.y2 - priv->large.box.y1;	\
+	} else {						\
+		w = priv->base.pixmap->drawable.width;		\
+		h = priv->base.pixmap->drawable.height;		\
+	}							\
   } while(0)
 
-#define GLAMOR_PIXMAP_FBO_NOT_EAXCT_SIZE(priv)				\
-	(priv->fbo->width != priv->container->drawable.width 	\
-	 || priv->fbo->height != priv->container->drawable.height)
+#define glamor_pixmap_fbo_fix_wh_ratio(wh, priv)  		\
+  do {								\
+	int actual_w, actual_h;					\
+	PIXMAP_PRIV_GET_ACTUAL_SIZE(priv, actual_w, actual_h);	\
+	wh[0] = (float)priv->base.fbo->width / actual_w;	\
+	wh[1] = (float)priv->base.fbo->height / actual_h;	\
+	wh[2] = 1.0 / priv->base.fbo->width;			\
+	wh[3] = 1.0 / priv->base.fbo->height;			\
+  } while(0)
 
-#define glamor_pixmap_fbo_fix_wh_ratio(wh, priv)  do {			\
-	wh[0] = (float)priv->fbo->width					\
-		/ priv->container->drawable.width;			\
-	wh[1] = (float)priv->fbo->height				\
-		/ priv->container->drawable.height;			\
-	} while(0)
+#define pixmap_priv_get_fbo_off(_priv_, _xoff_, _yoff_)		\
+   do {								\
+	if (unlikely(_priv_ && (_priv_)->type				\
+		== GLAMOR_TEXTURE_LARGE)) {			\
+		*(_xoff_) = - (_priv_)->large.box.x1;	\
+		*(_yoff_) = - (_priv_)->large.box.y1;	\
+	} else {						\
+		*(_xoff_) = 0;					\
+		*(_yoff_) = 0;					\
+	}							\
+   } while(0)
 
 #define xFixedToFloat(_val_) ((float)xFixedToInt(_val_)			\
 			      + ((float)xFixedFrac(_val_) / 65536.0))
@@ -76,115 +110,678 @@
       }									\
   }  while(0)
 
-#define glamor_set_transformed_point(matrix, xscale, yscale, texcoord,	\
-                                     x, y, yInverted)			\
+#define fmod(x, w)		(x - w * floor((float)x/w))
+
+#define fmodulus(x, w, c)	do {c = fmod(x, w);		\
+				    c = c >= 0 ? c : c + w;}	\
+				while(0)
+/* @x: is current coord
+ * @x2: is the right/bottom edge
+ * @w: is current width or height
+ * @odd: is output value, 0 means we are in an even region, 1 means we are in a
+ * odd region.
+ * @c: is output value, equal to x mod w. */
+#define fodd_repeat_mod(x, x2, w, odd, c)	\
+  do {						\
+	float shift;				\
+	fmodulus((x), w, c); 			\
+	shift = fabs((x) - (c));		\
+	shift = floor(fabs(round(shift)) / w);	\
+	odd = (int)shift & 1;			\
+	if (odd && (((x2 % w) == 0) &&		\
+	    round(fabs(x)) == x2))		\
+		odd = 0;			\
+  } while(0)
+
+/* @txy: output value, is the corrected coords.
+ * @xy: input coords to be fixed up.
+ * @cd: xy mod wh, is a input value.
+ * @wh: current width or height.
+ * @bxy1,bxy2: current box edge's x1/x2 or y1/y2
+ *
+ * case 1:
+ *  ----------
+ *  |  *     |
+ *  |        |
+ *  ----------
+ *  tx = (c - x1) mod w
+ *
+ *  case 2:
+ *     ---------
+ *  *  |       |
+ *     |       |
+ *     ---------
+ *   tx = - (c - (x1 mod w))
+ *
+ *   case 3:
+ *
+ *   ----------
+ *   |        |  *
+ *   |        |
+ *   ----------
+ *   tx = ((x2 mod x) - c) + (x2 - x1)
+ **/
+#define __glamor_repeat_reflect_fixup(txy, xy,		\
+				cd, wh, bxy1, bxy2)	\
+  do {							\
+	cd = wh - cd;					\
+	if ( xy >= bxy1 && xy < bxy2) {			\
+		cd = cd - bxy1;				\
+		fmodulus(cd, wh, txy);			\
+	} else	if (xy < bxy1) {			\
+		float bxy1_mod;				\
+		fmodulus(bxy1, wh, bxy1_mod);		\
+		txy = -(cd - bxy1_mod);			\
+	}						\
+	else if (xy >= bxy2)	{			\
+		float bxy2_mod;				\
+		fmodulus(bxy2, wh, bxy2_mod);		\
+		if (bxy2_mod == 0)			\
+			bxy2_mod = wh;			\
+		txy = (bxy2_mod - cd) + bxy2 - bxy1;	\
+	} else {assert(0); txy = 0;}			\
+  } while(0)
+
+#define _glamor_repeat_reflect_fixup(txy, xy, cd, odd,	\
+				     wh, bxy1, bxy2)	\
+  do {							\
+	if (odd) {					\
+		__glamor_repeat_reflect_fixup(txy, xy, 	\
+			cd, wh, bxy1, bxy2);		\
+	} else						\
+		txy = xy - bxy1;			\
+  } while(0)
+
+#define _glamor_get_reflect_transform_coords(priv, repeat_type,	\
+					    tx1, ty1, 		\
+				            _x1_, _y1_)		\
+  do {								\
+	int odd_x, odd_y;					\
+	float c, d;						\
+	fodd_repeat_mod(_x1_,priv->box.x2,			\
+		    priv->base.pixmap->drawable.width,		\
+		    odd_x, c);					\
+	fodd_repeat_mod(_y1_,	priv->box.y2,			\
+		    priv->base.pixmap->drawable.height,		\
+		    odd_y, d);					\
+	DEBUGF("c %f d %f oddx %d oddy %d \n",			\
+		c, d, odd_x, odd_y);				\
+	DEBUGF("x2 %d x1 %d fbo->width %d \n", priv->box.x2,	\
+		priv->box.x1, priv->base.fbo->width);		\
+	DEBUGF("y2 %d y1 %d fbo->height %d \n", priv->box.y2, 	\
+		priv->box.y1, priv->base.fbo->height);		\
+	_glamor_repeat_reflect_fixup(tx1, _x1_, c, odd_x,	\
+		priv->base.pixmap->drawable.width,		\
+		priv->box.x1, priv->box.x2);			\
+	_glamor_repeat_reflect_fixup(ty1, _y1_, d, odd_y,	\
+		priv->base.pixmap->drawable.height,		\
+		priv->box.y1, priv->box.y2);			\
+   } while(0)
+
+#define _glamor_get_repeat_coords(priv, repeat_type, tx1,	\
+				  ty1, tx2, ty2,		\
+				  _x1_, _y1_, _x2_,		\
+				  _y2_, c, d, odd_x, odd_y)	\
+  do {								\
+	if (repeat_type == RepeatReflect) {			\
+		DEBUGF("x1 y1 %d %d\n",				\
+			_x1_, _y1_ );				\
+		DEBUGF("width %d box.x1 %d \n",			\
+		       (priv)->base.pixmap->drawable.width,	\
+		       priv->box.x1);				\
+		if (odd_x) {					\
+			c = (priv)->base.pixmap->drawable.width	\
+				- c;				\
+			tx1 = c - priv->box.x1;			\
+			tx2 = tx1 - ((_x2_) - (_x1_));		\
+		} else {					\
+			tx1 = c - priv->box.x1;			\
+			tx2 = tx1 + ((_x2_) - (_x1_));		\
+		}						\
+		if (odd_y){					\
+			d = (priv)->base.pixmap->drawable.height\
+			    - d;				\
+			ty1 = d - priv->box.y1;			\
+			ty2 = ty1 - ((_y2_) - (_y1_));		\
+		} else {					\
+			ty1 = d - priv->box.y1;			\
+			ty2 = ty1 + ((_y2_) - (_y1_));		\
+		}						\
+	} else { /* RepeatNormal*/				\
+		tx1 = (c - priv->box.x1);  			\
+		ty1 = (d - priv->box.y1);			\
+		tx2 = tx1 + ((_x2_) - (_x1_));			\
+		ty2 = ty1 + ((_y2_) - (_y1_));			\
+	}							\
+   } while(0)
+
+
+/* _x1_ ... _y2_ may has fractional. */
+#define glamor_get_repeat_transform_coords(priv, repeat_type, tx1,	\
+					   ty1, _x1_, _y1_)		\
+  do {									\
+	DEBUGF("width %d box.x1 %d x2 %d y1 %d y2 %d\n",		\
+		(priv)->base.pixmap->drawable.width,			\
+		priv->box.x1, priv->box.x2, priv->box.y1,		\
+		priv->box.y2);						\
+	DEBUGF("x1 %f y1 %f \n", _x1_, _y1_);				\
+	if (repeat_type != RepeatReflect) {				\
+		tx1 = _x1_ - priv->box.x1;				\
+		ty1 = _y1_ - priv->box.y1;				\
+	} else			\
+		_glamor_get_reflect_transform_coords(priv, repeat_type, \
+				  tx1, ty1, 				\
+				  _x1_, _y1_);				\
+	DEBUGF("tx1 %f ty1 %f \n", tx1, ty1);				\
+   } while(0)
+
+/* _x1_ ... _y2_ must be integer. */
+#define glamor_get_repeat_coords(priv, repeat_type, tx1,		\
+				 ty1, tx2, ty2, _x1_, _y1_, _x2_,	\
+				 _y2_) 					\
+  do {									\
+	int c, d;							\
+	int odd_x = 0, odd_y = 0;					\
+	DEBUGF("width %d box.x1 %d x2 %d y1 %d y2 %d\n",		\
+		(priv)->base.pixmap->drawable.width,			\
+		priv->box.x1, priv->box.x2,				\
+		priv->box.y1, priv->box.y2);				\
+	modulus((_x1_), (priv)->base.pixmap->drawable.width, c); 	\
+	modulus((_y1_), (priv)->base.pixmap->drawable.height, d);	\
+	DEBUGF("c %d d %d \n", c, d);					\
+	if (repeat_type == RepeatReflect) {				\
+		odd_x = abs((_x1_ - c)					\
+			/ (priv->base.pixmap->drawable.width)) & 1;	\
+		odd_y = abs((_y1_ - d)					\
+			/ (priv->base.pixmap->drawable.height)) & 1;	\
+	}								\
+	_glamor_get_repeat_coords(priv, repeat_type, tx1, ty1, tx2, ty2,\
+				  _x1_, _y1_, _x2_, _y2_, c, d,		\
+				  odd_x, odd_y);			\
+   } while(0)
+
+#define glamor_transform_point(matrix, tx, ty, x, y)			\
   do {									\
-    float result[4];							\
     int i;								\
-    float tx, ty;							\
-									\
+    float result[4];							\
     for (i = 0; i < 3; i++) {						\
       result[i] = (matrix)[i * 3] * (x) + (matrix)[i * 3 + 1] * (y)	\
 	+ (matrix)[i * 3 + 2];						\
     }									\
     tx = result[0] / result[2];						\
     ty = result[1] / result[2];						\
+  } while(0)
+
+#define _glamor_set_normalize_tpoint(xscale, yscale, _tx_, _ty_,	\
+				     texcoord, yInverted)		\
+  do {									\
+	(texcoord)[0] = t_from_x_coord_x(xscale, _tx_);			\
+	if (likely(yInverted))						\
+		(texcoord)[1] = t_from_x_coord_y_inverted(yscale, _ty_);\
+	else								\
+		(texcoord)[1] = t_from_x_coord_y(yscale, _ty_);		\
+        DEBUGF("normalized point tx %f ty %f \n", (texcoord)[0],	\
+		(texcoord)[1]);						\
+  } while(0)
+
+#define glamor_set_transformed_point(priv, matrix, xscale,		\
+				     yscale, texcoord,			\
+                                     x, y, 				\
+				     yInverted)				\
+  do {									\
+    float tx, ty;							\
+    int fbo_x_off, fbo_y_off;						\
+    pixmap_priv_get_fbo_off(priv, &fbo_x_off, &fbo_y_off);		\
+    glamor_transform_point(matrix, tx, ty, x, y);			\
+    DEBUGF("tx %f ty %f fbooff %d %d \n",				\
+	    tx, ty, fbo_x_off, fbo_y_off);				\
 									\
+    tx += fbo_x_off;							\
+    ty += fbo_y_off;							\
     (texcoord)[0] = t_from_x_coord_x(xscale, tx);			\
-    if (yInverted)							\
+    if (likely(yInverted))							\
       (texcoord)[1] = t_from_x_coord_y_inverted(yscale, ty);		\
     else								\
       (texcoord)[1] = t_from_x_coord_y(yscale, ty);			\
+    DEBUGF("normalized tx %f ty %f \n", (texcoord)[0], (texcoord)[1]);	\
   } while(0)
 
-
-#define glamor_set_transformed_normalize_tcoords( matrix,		\
+#define glamor_set_transformed_normalize_tri_tcoords(priv,		\
+						     matrix,		\
+						     xscale,		\
+						     yscale,		\
+						     vtx,		\
+						     yInverted,		\
+						     texcoords)		\
+    do {								\
+	glamor_set_transformed_point(priv, matrix, xscale, yscale,	\
+				     texcoords, (vtx)[0], (vtx)[1],	\
+				     yInverted);			\
+	glamor_set_transformed_point(priv, matrix, xscale, yscale,	\
+				     texcoords+2, (vtx)[2], (vtx)[3],	\
+				     yInverted);			\
+	glamor_set_transformed_point(priv, matrix, xscale, yscale,	\
+				     texcoords+4, (vtx)[4], (vtx)[5],	\
+				     yInverted);			\
+    } while (0)
+
+#define glamor_set_transformed_normalize_tcoords_ext( priv,		\
+						  matrix,		\
 						  xscale,		\
 						  yscale,		\
                                                   tx1, ty1, tx2, ty2,   \
-                                                  yInverted, texcoords)	\
+                                                  yInverted, texcoords,	\
+						  stride)		\
   do {									\
-    glamor_set_transformed_point(matrix, xscale, yscale,		\
+    glamor_set_transformed_point(priv, matrix, xscale, yscale,		\
 				 texcoords, tx1, ty1,			\
 				 yInverted);				\
-    glamor_set_transformed_point(matrix, xscale, yscale,		\
-				 texcoords + 2, tx2, ty1,		\
+    glamor_set_transformed_point(priv, matrix, xscale, yscale,		\
+				 texcoords + 1 * stride, tx2, ty1,	\
 				 yInverted);				\
-    glamor_set_transformed_point(matrix, xscale, yscale,		\
-				 texcoords + 4, tx2, ty2,		\
+    glamor_set_transformed_point(priv, matrix, xscale, yscale,		\
+				 texcoords + 2 * stride, tx2, ty2,	\
 				 yInverted);				\
-    glamor_set_transformed_point(matrix, xscale, yscale,		\
-				 texcoords + 6, tx1, ty2,		\
+    glamor_set_transformed_point(priv, matrix, xscale, yscale,		\
+				 texcoords + 3 * stride, tx1, ty2,	\
 				 yInverted);				\
   } while (0)
 
-#define glamor_set_normalize_tcoords(xscale, yscale, x1, y1, x2, y2,	\
-                                     yInverted, vertices)		\
+#define glamor_set_transformed_normalize_tcoords( priv,			\
+						  matrix,		\
+						  xscale,		\
+						  yscale,		\
+                                                  tx1, ty1, tx2, ty2,   \
+                                                  yInverted, texcoords)	\
+  do {									\
+	glamor_set_transformed_normalize_tcoords_ext( priv,		\
+						  matrix,		\
+						  xscale,		\
+						  yscale,		\
+                                                  tx1, ty1, tx2, ty2,   \
+                                                  yInverted, texcoords,	\
+						  2);			\
+  } while (0)
+
+
+
+#define glamor_set_normalize_tri_tcoords(xscale,		\
+					 yscale,		\
+					 vtx,			\
+					 yInverted,		\
+					 texcoords)		\
+    do {							\
+	_glamor_set_normalize_tpoint(xscale, yscale,		\
+				(vtx)[0], (vtx)[1],		\
+				texcoords,			\
+				yInverted);			\
+	_glamor_set_normalize_tpoint(xscale, yscale,		\
+				(vtx)[2], (vtx)[3],		\
+				texcoords+2,			\
+				yInverted);			\
+	_glamor_set_normalize_tpoint(xscale, yscale,		\
+				(vtx)[4], (vtx)[5],		\
+				texcoords+4,			\
+				yInverted);			\
+    } while (0)
+
+#define glamor_set_repeat_transformed_normalize_tcoords_ext( priv,	\
+							 repeat_type,	\
+							 matrix,	\
+							 xscale,	\
+							 yscale,	\
+							 _x1_, _y1_,	\
+							 _x2_, _y2_,   	\
+							 yInverted,	\
+							 texcoords,	\
+							 stride)	\
+  do {									\
+    if (likely(priv->type != GLAMOR_TEXTURE_LARGE)) {			\
+	glamor_set_transformed_normalize_tcoords_ext(priv, matrix, xscale,	\
+						 yscale, _x1_, _y1_,	\
+						 _x2_, _y2_, yInverted,	\
+						 texcoords, stride);	\
+    } else {								\
+    float tx1, ty1, tx2, ty2, tx3, ty3, tx4, ty4;			\
+    float ttx1, tty1, ttx2, tty2, ttx3, tty3, ttx4, tty4;		\
+    DEBUGF("original coords %d %d %d %d\n", _x1_, _y1_, _x2_, _y2_);	\
+    glamor_transform_point(matrix, tx1, ty1, _x1_, _y1_);		\
+    glamor_transform_point(matrix, tx2, ty2, _x2_, _y1_);		\
+    glamor_transform_point(matrix, tx3, ty3, _x2_, _y2_);		\
+    glamor_transform_point(matrix, tx4, ty4, _x1_, _y2_);		\
+    DEBUGF("transformed %f %f %f %f %f %f %f %f\n",			\
+	   tx1, ty1, tx2, ty2, tx3, ty3, tx4, ty4);			\
+    glamor_get_repeat_transform_coords((&priv->large), repeat_type, 	\
+				       ttx1, tty1, 			\
+				       tx1, ty1);			\
+    glamor_get_repeat_transform_coords((&priv->large), repeat_type, 	\
+				       ttx2, tty2, 			\
+				       tx2, ty2);			\
+    glamor_get_repeat_transform_coords((&priv->large), repeat_type, 	\
+				       ttx3, tty3, 			\
+				       tx3, ty3);			\
+    glamor_get_repeat_transform_coords((&priv->large), repeat_type, 	\
+				       ttx4, tty4, 			\
+				       tx4, ty4);			\
+    DEBUGF("repeat transformed %f %f %f %f %f %f %f %f\n", ttx1, tty1, 	\
+	    ttx2, tty2,	ttx3, tty3, ttx4, tty4);			\
+    _glamor_set_normalize_tpoint(xscale, yscale, ttx1, tty1,		\
+				 texcoords, yInverted);			\
+    _glamor_set_normalize_tpoint(xscale, yscale, ttx2, tty2,		\
+				 texcoords + 1 * stride, yInverted);	\
+    _glamor_set_normalize_tpoint(xscale, yscale, ttx3, tty3,		\
+				 texcoords + 2 * stride, yInverted);	\
+    _glamor_set_normalize_tpoint(xscale, yscale, ttx4, tty4,		\
+				 texcoords + 3 * stride, yInverted);	\
+   }									\
+  } while (0)
+
+
+#define glamor_set_repeat_transformed_normalize_tcoords( priv,		\
+							 repeat_type,	\
+							 matrix,	\
+							 xscale,	\
+							 yscale,	\
+							 _x1_, _y1_,	\
+							 _x2_, _y2_,   	\
+							 yInverted,	\
+							 texcoords)	\
+  do {									\
+	glamor_set_repeat_transformed_normalize_tcoords_ext( priv,	\
+							 repeat_type,	\
+							 matrix,	\
+							 xscale,	\
+							 yscale,	\
+							 _x1_, _y1_,	\
+							 _x2_, _y2_,   	\
+							 yInverted,	\
+							 texcoords,	\
+							 2);	\
+  } while (0)
+
+#define _glamor_set_normalize_tcoords(xscale, yscale, tx1,		\
+				      ty1, tx2, ty2,			\
+				      yInverted, vertices, stride)	\
   do {									\
-    (vertices)[0] = t_from_x_coord_x(xscale, x1);			\
-    (vertices)[2] = t_from_x_coord_x(xscale, x2);			\
-    (vertices)[4] = (vertices)[2];					\
-    (vertices)[6] = (vertices)[0];					\
-    if (yInverted) {							\
-      (vertices)[1] = t_from_x_coord_y_inverted(yscale, y1);		\
-      (vertices)[5] = t_from_x_coord_y_inverted(yscale, y2);		\
+    /* vertices may be write-only, so we use following			\
+     * temporary variable. */ 						\
+    float _t0_, _t1_, _t2_, _t5_;					\
+    (vertices)[0] = _t0_ = t_from_x_coord_x(xscale, tx1);		\
+    (vertices)[1 * stride] = _t2_ = t_from_x_coord_x(xscale, tx2);	\
+    (vertices)[2 * stride] = _t2_;					\
+    (vertices)[3 * stride] = _t0_;					\
+    if (likely(yInverted)) {							\
+      (vertices)[1] = _t1_ = t_from_x_coord_y_inverted(yscale, ty1);	\
+      (vertices)[2 * stride + 1] = _t5_ = t_from_x_coord_y_inverted(yscale, ty2);\
     }									\
     else {								\
-      (vertices)[1] = t_from_x_coord_y(yscale, y1);			\
-      (vertices)[5] = t_from_x_coord_y(yscale, y2);			\
+      (vertices)[1] = _t1_ = t_from_x_coord_y(yscale, ty1);		\
+      (vertices)[2 * stride + 1] = _t5_ = t_from_x_coord_y(yscale, ty2);\
     }									\
-    (vertices)[3] = (vertices)[1];					\
-    (vertices)[7] = (vertices)[5];					\
+    (vertices)[1 * stride + 1] = _t1_;					\
+    (vertices)[3 * stride + 1] = _t5_;					\
   } while(0)
 
-#define glamor_set_tcoords(x1, y1, x2, y2, yInverted, vertices)	    \
-    do {                                                            \
-      (vertices)[0] = (x1);                                         \
-      (vertices)[2] = (x2);                                         \
-      (vertices)[4] = (vertices)[2];                                \
-      (vertices)[6] = (vertices)[0];                                \
-      if (yInverted) {                                              \
-          (vertices)[1] = (y1);                                     \
-          (vertices)[5] = (y2);                                     \
-      }                                                             \
-      else {                                                        \
-          (vertices)[1] = (y2);                                     \
-          (vertices)[5] = (y1);                                     \
-      }                                                             \
-      (vertices)[3] = (vertices)[1];                \
-      (vertices)[7] = (vertices)[5];                \
+#define glamor_set_normalize_tcoords_ext(priv, xscale, yscale,		\
+				     x1, y1, x2, y2,			\
+                                     yInverted, vertices, stride)	\
+  do {									\
+     if (unlikely(priv->type == GLAMOR_TEXTURE_LARGE)) {				\
+	float tx1, tx2, ty1, ty2;					\
+	int fbo_x_off, fbo_y_off;					\
+	pixmap_priv_get_fbo_off(priv, &fbo_x_off, &fbo_y_off);		\
+	tx1 = x1 + fbo_x_off; 						\
+	tx2 = x2 + fbo_x_off;						\
+	ty1 = y1 + fbo_y_off;						\
+	ty2 = y2 + fbo_y_off;						\
+	_glamor_set_normalize_tcoords(xscale, yscale, tx1, ty1,		\
+				   tx2, ty2, yInverted, vertices,	\
+				   stride);				\
+     } else								\
+	_glamor_set_normalize_tcoords(xscale, yscale, x1, y1,		\
+				   x2, y2, yInverted, vertices, stride);\
+ } while(0)
+
+
+#define glamor_set_normalize_tcoords(priv, xscale, yscale,		\
+				     x1, y1, x2, y2,			\
+                                     yInverted, vertices)		\
+  do {									\
+	glamor_set_normalize_tcoords_ext(priv, xscale, yscale,		\
+				     x1, y1, x2, y2,			\
+                                     yInverted, vertices, 2);		\
+ } while(0)
+
+#define glamor_set_repeat_normalize_tcoords_ext(priv, repeat_type,	\
+					    xscale, yscale,		\
+					    _x1_, _y1_, _x2_, _y2_,	\
+	                                    yInverted, vertices, stride)\
+  do {									\
+     if (unlikely(priv->type == GLAMOR_TEXTURE_LARGE)) {				\
+	float tx1, tx2, ty1, ty2;					\
+	if (repeat_type == RepeatPad) {					\
+		tx1 = _x1_ - priv->large.box.x1;			\
+		ty1 = _y1_ - priv->large.box.y1;			\
+		tx2 = tx1 + ((_x2_) - (_x1_));				\
+		ty2 = ty1 + ((_y2_) - (_y1_));				\
+	} else {							\
+	glamor_get_repeat_coords((&priv->large), repeat_type,		\
+				 tx1, ty1, tx2, ty2,			\
+				 _x1_, _y1_, _x2_, _y2_);		\
+	}								\
+	_glamor_set_normalize_tcoords(xscale, yscale, tx1, ty1,		\
+				   tx2, ty2, yInverted, vertices,	\
+				   stride);				\
+     } else								\
+	_glamor_set_normalize_tcoords(xscale, yscale, _x1_, _y1_,	\
+				   _x2_, _y2_, yInverted, vertices,	\
+				   stride);				\
+ } while(0)
+
+
+#define glamor_set_repeat_normalize_tcoords(priv, repeat_type,		\
+					    xscale, yscale,		\
+					    _x1_, _y1_, _x2_, _y2_,	\
+	                                    yInverted, vertices)	\
+  do {									\
+	glamor_set_repeat_normalize_tcoords_ext(priv, repeat_type,	\
+					    xscale, yscale,		\
+					    _x1_, _y1_, _x2_, _y2_,	\
+	                                    yInverted, vertices, 2);	\
+ } while(0)
+
+#define glamor_set_normalize_tcoords_tri_stripe(xscale, yscale,		\
+						x1, y1, x2, y2,		\
+						yInverted, vertices)	\
+    do {								\
+	(vertices)[0] = t_from_x_coord_x(xscale, x1);			\
+	(vertices)[2] = t_from_x_coord_x(xscale, x2);			\
+	(vertices)[6] = (vertices)[2];					\
+	(vertices)[4] = (vertices)[0];					\
+	if (likely(yInverted)) {						\
+	    (vertices)[1] = t_from_x_coord_y_inverted(yscale, y1);	\
+	    (vertices)[7] = t_from_x_coord_y_inverted(yscale, y2);	\
+	}								\
+	else {								\
+	    (vertices)[1] = t_from_x_coord_y(yscale, y1);		\
+	    (vertices)[7] = t_from_x_coord_y(yscale, y2);		\
+	}								\
+	(vertices)[3] = (vertices)[1];					\
+	(vertices)[5] = (vertices)[7];					\
     } while(0)
 
+#define glamor_set_tcoords(width, height, x1, y1, x2, y2,	\
+			   yInverted, vertices)			\
+    do {							\
+	(vertices)[0] = (x1);					\
+	(vertices)[2] = (x2);					\
+	(vertices)[4] = (vertices)[2];				\
+	(vertices)[6] = (vertices)[0];				\
+	if (likely(yInverted)) {					\
+	    (vertices)[1] = (y1);				\
+	    (vertices)[5] = (y2);				\
+	}							\
+	else {							\
+	    (vertices)[1] = height - (y2);			\
+	    (vertices)[5] = height - (y1);			\
+	}							\
+	(vertices)[3] = (vertices)[1];				\
+	(vertices)[7] = (vertices)[5];				\
+    } while(0)
 
-#define glamor_set_normalize_vcoords(xscale, yscale, x1, y1, x2, y2,	\
-                                     yInverted, vertices)		\
+#define glamor_set_tcoords_ext(width, height, x1, y1, x2, y2,	\
+			       yInverted, vertices, stride)	\
+    do {							\
+	(vertices)[0] = (x1);					\
+	(vertices)[1*stride] = (x2);				\
+	(vertices)[2*stride] = (vertices)[1*stride];		\
+	(vertices)[3*stride] = (vertices)[0];			\
+	if (likely(yInverted)) {				\
+	    (vertices)[1] = (y1);				\
+	    (vertices)[2*stride + 1] = (y2);			\
+	}							\
+	else {							\
+	    (vertices)[1] = height - (y2);			\
+	    (vertices)[2*stride + 1] = height - (y1);		\
+	}							\
+	(vertices)[1*stride + 1] = (vertices)[1];		\
+	(vertices)[3*stride + 1] = (vertices)[2*stride + 1];	\
+    } while(0)
+
+#define glamor_set_normalize_one_vcoord(xscale, yscale, x, y,		\
+					yInverted, vertices)		\
+    do {								\
+	(vertices)[0] = v_from_x_coord_x(xscale, x);			\
+	if (likely(yInverted)) {						\
+	    (vertices)[1] = v_from_x_coord_y_inverted(yscale, y);	\
+	} else {							\
+	    (vertices)[1] = v_from_x_coord_y(yscale, y);		\
+	}								\
+    } while(0)
+
+#define glamor_set_normalize_tri_vcoords(xscale, yscale, vtx,		\
+					 yInverted, vertices)		\
+    do {								\
+	glamor_set_normalize_one_vcoord(xscale, yscale,			\
+					(vtx)[0], (vtx)[1],		\
+					yInverted, vertices);		\
+	glamor_set_normalize_one_vcoord(xscale, yscale,			\
+					(vtx)[2], (vtx)[3],		\
+					yInverted, vertices+2);		\
+	glamor_set_normalize_one_vcoord(xscale, yscale,			\
+					(vtx)[4], (vtx)[5],		\
+					yInverted, vertices+4);		\
+    } while(0)
+
+#define glamor_set_tcoords_tri_strip(width, height, x1, y1, x2, y2,	\
+				     yInverted, vertices)		\
+    do {								\
+	(vertices)[0] = (x1);						\
+	(vertices)[2] = (x2);						\
+	(vertices)[6] = (vertices)[2];					\
+	(vertices)[4] = (vertices)[0];					\
+	if (likely(yInverted)) {						\
+	    (vertices)[1] = (y1);					\
+	    (vertices)[7] = (y2);					\
+	}								\
+	else {								\
+	    (vertices)[1] = height - (y2);				\
+	    (vertices)[7] = height - (y1);				\
+	}								\
+	(vertices)[3] = (vertices)[1];					\
+	(vertices)[5] = (vertices)[7];					\
+    } while(0)
+
+#define glamor_set_normalize_vcoords_ext(priv, xscale, yscale,		\
+				     x1, y1, x2, y2,			\
+                                     yInverted, vertices, stride)	\
   do {									\
-    (vertices)[0] = v_from_x_coord_x(xscale, x1);			\
-    (vertices)[2] = v_from_x_coord_x(xscale, x2);			\
-    (vertices)[4] = (vertices)[2];					\
-    (vertices)[6] = (vertices)[0];					\
-    if (yInverted) {							\
-      (vertices)[1] = v_from_x_coord_y_inverted(yscale, y1);		\
-      (vertices)[5] = v_from_x_coord_y_inverted(yscale, y2);		\
+    int fbo_x_off, fbo_y_off;						\
+    /* vertices may be write-only, so we use following			\
+     * temporary variable. */						\
+    float _t0_, _t1_, _t2_, _t5_;					\
+    pixmap_priv_get_fbo_off(priv, &fbo_x_off, &fbo_y_off);		\
+    (vertices)[0] = _t0_ = v_from_x_coord_x(xscale, x1 + fbo_x_off);	\
+    (vertices)[1 * stride] = _t2_ = v_from_x_coord_x(xscale,		\
+					x2 + fbo_x_off);		\
+    (vertices)[2 * stride] = _t2_;					\
+    (vertices)[3 * stride] = _t0_;					\
+    if (likely(yInverted)) {							\
+      (vertices)[1] = _t1_ = v_from_x_coord_y_inverted(yscale,		\
+				y1 + fbo_y_off);			\
+      (vertices)[2 * stride + 1] = _t5_ =				\
+			v_from_x_coord_y_inverted(yscale,		\
+					y2 + fbo_y_off);		\
     }									\
     else {								\
-      (vertices)[1] = v_from_x_coord_y(yscale, y1);			\
-      (vertices)[5] = v_from_x_coord_y(yscale, y2);			\
+      (vertices)[1] = _t1_ = v_from_x_coord_y(yscale, y1 + fbo_y_off);	\
+      (vertices)[2 * stride + 1] = _t5_ = v_from_x_coord_y(yscale,	\
+					y2 + fbo_y_off);		\
     }									\
-    (vertices)[3] = (vertices)[1];					\
-    (vertices)[7] = (vertices)[5];					\
+    (vertices)[1 * stride + 1] = _t1_;					\
+    (vertices)[3 * stride + 1] = _t5_;					\
+  } while(0)
+
+
+#define glamor_set_normalize_vcoords(priv, xscale, yscale,		\
+				     x1, y1, x2, y2,			\
+                                     yInverted, vertices)		\
+  do {									\
+	glamor_set_normalize_vcoords_ext(priv, xscale, yscale,		\
+				     x1, y1, x2, y2,			\
+                                     yInverted, vertices, 2);		\
   } while(0)
 
-#define glamor_set_normalize_pt(xscale, yscale, x, x_start, y, y_start,     \
-                                yInverted, pt)                              \
-    do {                                                                    \
-        (pt)[0] = t_from_x_coord_x(xscale, x - x_start);                    \
-        if (yInverted) {                                                    \
-            (pt)[1] = t_from_x_coord_y_inverted(yscale, y - y_start);       \
-        } else {                                                            \
-            (pt)[1] = t_from_x_coord_y(yscale, y - y_start);                \
-        }                                                                   \
-        (pt)[2] = (pt)[3] = 0.0;                                            \
+#define glamor_set_const_ext(params, nparam, vertices, nverts, stride)	\
+    do {								\
+	int i = 0, j = 0;						\
+	for(; i < nverts; i++) {					\
+	    for(j = 0; j < nparam; j++) {				\
+		vertices[stride*i + j] = params[j];			\
+	    }								\
+	}								\
+    } while(0)
+
+#define glamor_set_normalize_vcoords_tri_strip(xscale, yscale,		\
+					       x1, y1, x2, y2,		\
+					       yInverted, vertices)	\
+    do {								\
+	(vertices)[0] = v_from_x_coord_x(xscale, x1);			\
+	(vertices)[2] = v_from_x_coord_x(xscale, x2);			\
+	(vertices)[6] = (vertices)[2];					\
+	(vertices)[4] = (vertices)[0];					\
+	if (likely(yInverted)) {						\
+	    (vertices)[1] = v_from_x_coord_y_inverted(yscale, y1);	\
+	    (vertices)[7] = v_from_x_coord_y_inverted(yscale, y2);	\
+	}								\
+	else {								\
+	    (vertices)[1] = v_from_x_coord_y(yscale, y1);		\
+	    (vertices)[7] = v_from_x_coord_y(yscale, y2);		\
+	}								\
+	(vertices)[3] = (vertices)[1];					\
+	(vertices)[5] = (vertices)[7];					\
+    } while(0)
+
+#define glamor_set_normalize_pt(xscale, yscale, x, y,		\
+                                yInverted, pt)			\
+    do {							\
+        (pt)[0] = t_from_x_coord_x(xscale, x);			\
+        if (likely(yInverted)) {					\
+            (pt)[1] = t_from_x_coord_y_inverted(yscale, y);	\
+        } else {						\
+            (pt)[1] = t_from_x_coord_y(yscale, y);		\
+        }							\
+    } while(0)
+
+#define glamor_set_circle_centre(width, height, x, y,	\
+				 yInverted, c)		\
+    do {						\
+        (c)[0] = (float)x;				\
+        if (likely(yInverted)) {				\
+            (c)[1] = (float)y;				\
+        } else {					\
+            (c)[1] = (float)height - (float)y;		\
+        }						\
     } while(0)
 
 inline static void
@@ -213,7 +810,7 @@ glamor_calculate_boxes_bound(BoxPtr bound, BoxPtr boxes, int nbox)
 }
 
 inline static void
-glamor_transform_boxes(BoxPtr boxes, int nbox, int dx, int dy)
+glamor_translate_boxes(BoxPtr boxes, int nbox, int dx, int dy)
 {
 	int i;
 	for (i = 0; i < nbox; i++) {
@@ -224,13 +821,23 @@ glamor_transform_boxes(BoxPtr boxes, int nbox, int dx, int dy)
 	}
 }
 
+static inline Bool
+region_is_empty(pixman_region16_t *region)
+{
+	return region->data && region->data->numRects == 0;
+}
+
+#ifndef ARRAY_SIZE
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
+#endif
+
 #define ALIGN(i,m)	(((i) + (m) - 1) & ~((m) - 1))
 #define MIN(a,b)	((a) < (b) ? (a) : (b))
+#define MAX(a,b)	((a) > (b) ? (a) : (b))
 
 #define glamor_check_fbo_size(_glamor_,_w_, _h_)    ((_w_) > 0 && (_h_) > 0 \
-                                                    && (_w_) < _glamor_->max_fbo_size  \
-                                                    && (_h_) < _glamor_->max_fbo_size)
+                                                    && (_w_) <= _glamor_->max_fbo_size  \
+                                                    && (_h_) <= _glamor_->max_fbo_size)
 
 /* For 1bpp pixmap, we don't store it as texture. */
 #define glamor_check_pixmap_fbo_depth(_depth_) (			\
@@ -241,9 +848,9 @@ glamor_transform_boxes(BoxPtr boxes, int nbox, int dx, int dy)
 						|| _depth_ == 30	\
 						|| _depth_ == 32)
 
-#define GLAMOR_PIXMAP_PRIV_IS_PICTURE(pixmap_priv) (pixmap_priv && pixmap_priv->is_picture == 1)
-#define GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv)    (pixmap_priv && pixmap_priv->gl_fbo == GLAMOR_FBO_NORMAL)
-#define GLAMOR_PIXMAP_PRIV_HAS_FBO_DOWNLOADED(pixmap_priv)    (pixmap_priv && (pixmap_priv->gl_fbo == GLAMOR_FBO_DOWNLOADED))
+#define GLAMOR_PIXMAP_PRIV_IS_PICTURE(pixmap_priv) (pixmap_priv && pixmap_priv->base.is_picture == 1)
+#define GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv)    (pixmap_priv && pixmap_priv->base.gl_fbo == GLAMOR_FBO_NORMAL)
+#define GLAMOR_PIXMAP_PRIV_HAS_FBO_DOWNLOADED(pixmap_priv)    (pixmap_priv && (pixmap_priv->base.gl_fbo == GLAMOR_FBO_DOWNLOADED))
 
 /**
  * Borrow from uxa.
@@ -298,7 +905,7 @@ format_for_pixmap(PixmapPtr pixmap)
 
 	pixmap_priv = glamor_get_pixmap_private(pixmap);
 	if (GLAMOR_PIXMAP_PRIV_IS_PICTURE(pixmap_priv))
-		pict_format = pixmap_priv->pict_format;
+		pict_format = pixmap_priv->base.picture->format;
 	else
 		pict_format = format_for_depth(pixmap->drawable.depth);
 
@@ -323,7 +930,7 @@ format_for_pixmap(PixmapPtr pixmap)
 
 /*
  * Map picture's format to the correct gl texture format and type.
- * no_alpha is used to indicate whehter we need to wire alpha to 1. 
+ * no_alpha is used to indicate whehter we need to wire alpha to 1.
  *
  * Although opengl support A1/GL_BITMAP, we still don't use it
  * here, it seems that mesa has bugs when uploading a A1 bitmap.
@@ -642,7 +1249,7 @@ glamor_get_tex_format_type_from_pixmap(PixmapPtr pixmap,
 
 	pixmap_priv = glamor_get_pixmap_private(pixmap);
 	if (GLAMOR_PIXMAP_PRIV_IS_PICTURE(pixmap_priv))
-		pict_format = pixmap_priv->pict_format;
+		pict_format = pixmap_priv->base.picture->format;
 	else
 		pict_format = format_for_depth(pixmap->drawable.depth);
 
@@ -742,7 +1349,7 @@ inline static Bool glamor_ddx_fallback_check_pixmap(DrawablePtr drawable)
 {
 	PixmapPtr pixmap = glamor_get_drawable_pixmap(drawable);
 	glamor_pixmap_private *pixmap_priv = glamor_get_pixmap_private(pixmap);
-	return (!pixmap_priv 
+	return (!pixmap_priv
 		|| (pixmap_priv->type == GLAMOR_TEXTURE_DRM
 		    || pixmap_priv->type == GLAMOR_MEMORY
 		    || pixmap_priv->type == GLAMOR_DRM_ONLY));
@@ -766,6 +1373,24 @@ inline static Bool glamor_ddx_fallback_check_gc(GCPtr gc)
         }
 	return (!pixmap || glamor_ddx_fallback_check_pixmap(&pixmap->drawable));
 }
+inline static Bool glamor_is_large_pixmap(PixmapPtr pixmap)
+{
+	glamor_pixmap_private *priv;
+
+	priv = glamor_get_pixmap_private(pixmap);
+	return (priv->type == GLAMOR_TEXTURE_LARGE);
+}
+
+inline static Bool glamor_is_large_picture(PicturePtr picture)
+{
+	PixmapPtr pixmap;
+
+	if (picture->pDrawable) {
+		pixmap = glamor_get_drawable_pixmap(picture->pDrawable);
+		return glamor_is_large_pixmap(pixmap);
+	}
+	return FALSE;
+}
 
 inline static Bool glamor_tex_format_is_readable(GLenum format)
 {
@@ -886,9 +1511,9 @@ static inline void _glamor_compare_pixmaps(PixmapPtr pixmap1, PixmapPtr pixmap2,
 	int little_endian = 0;
 	unsigned char *p_test;
 	int bpp = pixmap1->drawable.depth == 8 ? 1 : 4;
+	int stride = pixmap1->devKind;
 
 	assert(pixmap1->devKind == pixmap2->devKind);
-	int stride = pixmap1->devKind;
 
 	ErrorF("stride:%d, width:%d, height:%d\n", stride, w, h);
 
@@ -1143,6 +1768,30 @@ static inline void glamor_compare_pictures( ScreenPtr screen,
 	return;
 }
 
+#ifdef __i386__
+static inline unsigned long __fls(unsigned long x)
+{
+        asm("bsr %1,%0"
+            : "=r" (x)
+            : "rm" (x));
+        return x;
+}
+#else
+static inline unsigned long __fls(unsigned long x)
+{
+   int n;
+
+   if (x == 0) return(0);
+   n = 0;
+   if (x <= 0x0000FFFF) {n = n +16; x = x <<16;}
+   if (x <= 0x00FFFFFF) {n = n + 8; x = x << 8;}
+   if (x <= 0x0FFFFFFF) {n = n + 4; x = x << 4;}
+   if (x <= 0x3FFFFFFF) {n = n + 2; x = x << 2;}
+   if (x <= 0x7FFFFFFF) {n = n + 1;}
+   return 31 - n;
+}
+#endif
+
 static inline void glamor_make_current(ScreenPtr screen)
 {
 	glamor_egl_make_current(screen);
diff --git a/glapi.h b/glapi.h
index da521aa..d510dac 100644
--- a/glapi.h
+++ b/glapi.h
@@ -79,7 +79,7 @@ extern const struct _glapi_table *_glapi_Dispatch;
 extern const void *_glapi_Context;
 
 # define GET_DISPATCH() _glapi_tls_Dispatch
-# define GET_CURRENT_CONTEXT(C)  struct gl_context *C = (struct gl_context *) _glapi_tls_Context
+# define GET_CURRENT_CONTEXT(C)  C = (typeof(C)) _glapi_tls_Context
 # define SET_CURRENT_CONTEXT(C)  _glapi_tls_Context = (void*)C
 
 #else
@@ -92,7 +92,7 @@ extern void *_glapi_Context;
 #  define GET_DISPATCH() \
      (likely(_glapi_Dispatch) ? _glapi_Dispatch : _glapi_get_dispatch())
 
-#  define GET_CURRENT_CONTEXT(C)  struct gl_context *C = (struct gl_context *) \
+#  define GET_CURRENT_CONTEXT(C)  C = (typeof(C)) \
      (likely(_glapi_Context) ? _glapi_Context : _glapi_get_context())
 
 
@@ -104,7 +104,7 @@ extern void *_glapi_Context;
 # else
 
 #  define GET_DISPATCH() _glapi_Dispatch
-#  define GET_CURRENT_CONTEXT(C)  struct gl_context *C = (struct gl_context *) _glapi_Context
+#  define GET_CURRENT_CONTEXT(C)  C = (typeof(C)) _glapi_Context
 # define SET_CURRENT_CONTEXT(C)  _glapi_Context = (void*)C
 
 # endif
